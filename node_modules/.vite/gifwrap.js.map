{
  "version": 3,
  "sources": ["../gifwrap/src/bitmapimage.js", "../gifwrap/src/gif.js", "../image-q/dist/webpack:/webpack/universalModuleDefinition", "../image-q/dist/webpack:/webpack/bootstrap cc12c561526565ac4570", "../image-q/dist/webpack:/src/iq.ts", "../image-q/dist/webpack:/src/constants/index.ts", "../image-q/dist/webpack:/src/constants/bt709.ts", "../image-q/dist/webpack:/src/conversion/index.ts", "../image-q/dist/webpack:/src/conversion/rgb2xyz.ts", "../image-q/dist/webpack:/src/conversion/rgb2hsl.ts", "../image-q/dist/webpack:/src/utils/arithmetic.ts", "../image-q/dist/webpack:/src/conversion/rgb2lab.ts", "../image-q/dist/webpack:/src/conversion/xyz2lab.ts", "../image-q/dist/webpack:/src/conversion/lab2xyz.ts", "../image-q/dist/webpack:/src/conversion/lab2rgb.ts", "../image-q/dist/webpack:/src/conversion/xyz2rgb.ts", "../image-q/dist/webpack:/src/distance/index.ts", "../image-q/dist/webpack:/src/distance/abstractDistanceCalculator.ts", "../image-q/dist/webpack:/src/distance/cie94.ts", "../image-q/dist/webpack:/src/distance/ciede2000.ts", "../image-q/dist/webpack:/src/distance/cmetric.ts", "../image-q/dist/webpack:/src/distance/euclidean.ts", "../image-q/dist/webpack:/src/distance/manhattan.ts", "../image-q/dist/webpack:/src/distance/pngQuant.ts", "../image-q/dist/webpack:/src/palette/index.ts", "../image-q/dist/webpack:/src/palette/neuquant/neuquant.ts", "../image-q/dist/webpack:/src/utils/palette.ts", "../image-q/dist/webpack:/src/utils/pointContainer.ts", "../image-q/dist/webpack:/src/utils/point.ts", "../image-q/dist/webpack:/src/palette/neuquant/neuquantFloat.ts", "../image-q/dist/webpack:/src/palette/rgbquant/rgbquant.ts", "../image-q/dist/webpack:/src/palette/rgbquant/colorHistogram.ts", "../image-q/dist/webpack:/src/utils/hueStatistics.ts", "../image-q/dist/webpack:/src/palette/wu/wuQuant.ts", "../image-q/dist/webpack:/src/image/index.ts", "../image-q/dist/webpack:/src/image/nearestColor.ts", "../image-q/dist/webpack:/src/image/array.ts", "../image-q/dist/webpack:/src/image/riemersma.ts", "../image-q/dist/webpack:/src/image/spaceFillingCurves/hilbertCurve.ts", "../image-q/dist/webpack:/src/quality/index.ts", "../image-q/dist/webpack:/src/quality/ssim.ts", "../image-q/dist/webpack:/src/utils/index.ts", "../gifwrap/src/gifframe.js", "../gifwrap/src/gifutil.js", "../gifwrap/src/gifcodec.js", "../gifwrap/src/index.js", "dep:gifwrap"],
  "sourcesContent": ["'use strict';\n\n/** @class BitmapImage */\n\nclass BitmapImage {\n\n    /**\n     * BitmapImage is a class that hold an RGBA (red, green, blue, alpha) representation of an image. It's shape is borrowed from the Jimp package to make it easy to transfer GIF image frames into Jimp and Jimp images into GIF image frames. Each instance has a `bitmap` property having the following properties:\n     * \n     * Property | Description\n     * --- | ---\n     * bitmap.width | width of image in pixels\n     * bitmap.height | height of image in pixels\n     * bitmap.data | a Buffer whose every four bytes represents a pixel, each sequential byte of a pixel corresponding to the red, green, blue, and alpha values of the pixel\n     *\n     * Its constructor supports the following signatures:\n     *\n     * * new BitmapImage(bitmap: { width: number, height: number, data: Buffer })\n     * * new BitmapImage(bitmapImage: BitmapImage)\n     * * new BitmapImage(width: number, height: number, buffer: Buffer)\n     * * new BitmapImage(width: number, height: number, backgroundRGBA?: number)\n     * \n     * When a `BitmapImage` is provided, the constructed `BitmapImage` is a deep clone of the provided one, so that each image's pixel data can subsequently be modified without affecting each other.\n     *\n     * `backgroundRGBA` is an optional parameter representing a pixel as a single number. In hex, the number is as follows: 0xRRGGBBAA, where RR is the red byte, GG the green byte, BB, the blue byte, and AA the alpha value. An AA of 0x00 is considered transparent, and all non-zero AA values are treated as opaque.\n     */\n\n    constructor(...args) {\n        // don't confirm the number of args, because a subclass may have\n        // additional args and pass them all to the superclass\n        if (args.length === 0) {\n            throw new Error(\"constructor requires parameters\");\n        }\n        const firstArg = args[0];\n        if (firstArg !== null && typeof firstArg === 'object') {\n            if (firstArg instanceof BitmapImage) {\n                // copy a provided BitmapImage\n                const sourceBitmap = firstArg.bitmap;\n                this.bitmap = {\n                    width: sourceBitmap.width,\n                    height: sourceBitmap.height,\n                    data: new Buffer(sourceBitmap.width * sourceBitmap.height * 4)\n                };\n                sourceBitmap.data.copy(this.bitmap.data);\n            }\n            else if (firstArg.width && firstArg.height && firstArg.data) {\n                // share a provided bitmap\n                this.bitmap = firstArg;\n            }\n            else {\n                throw new Error(\"unrecognized constructor parameters\");\n            }\n        }\n        else if (typeof firstArg === 'number' && typeof args[1] === 'number')\n        {\n            const width = firstArg;\n            const height = args[1];\n            const thirdArg = args[2];\n            this.bitmap = { width, height };\n\n            if (Buffer.isBuffer(thirdArg)) {\n                this.bitmap.data = thirdArg;\n            }\n            else {\n                this.bitmap.data = new Buffer(width * height * 4);\n                if (typeof thirdArg === 'number') {\n                    this.fillRGBA(thirdArg);\n                }\n            }\n        }\n        else {\n            throw new Error(\"unrecognized constructor parameters\");\n        }\n    }\n\n    /**\n     * Copy a square portion of this image into another image. \n     * \n     * @param {BitmapImage} toImage Image into which to copy the square\n     * @param {number} toX x-coord in toImage of upper-left corner of receiving square\n     * @param {number} toY y-coord in toImage of upper-left corner of receiving square\n     * @param {number} fromX x-coord in this image of upper-left corner of source square\n     * @param {number} fromY y-coord in this image of upper-left corner of source square\n     * @return {BitmapImage} The present image to allow for chaining.\n     */\n\n    blit(toImage, toX, toY, fromX, fromY, fromWidth, fromHeight) {\n        if (fromX + fromWidth > this.bitmap.width) {\n            throw new Error(\"copy exceeds width of source bitmap\");\n        }\n        if (toX + fromWidth > toImage.bitmap.width) {\n            throw new Error(\"copy exceeds width of target bitmap\");\n        }\n        if (fromY + fromHeight > this.bitmap.height) {\n            throw new Error(\"copy exceeds height of source bitmap\");\n        }\n        if (toY + fromHeight > toImage.bitmap.height) {\n            throw new Erro(\"copy exceeds height of target bitmap\");\n        }\n        \n        const sourceBuf = this.bitmap.data;\n        const targetBuf = toImage.bitmap.data;\n        const sourceByteWidth = this.bitmap.width * 4;\n        const targetByteWidth = toImage.bitmap.width * 4;\n        const copyByteWidth = fromWidth * 4;\n        let si = fromY * sourceByteWidth + fromX * 4;\n        let ti = toY * targetByteWidth + toX * 4;\n\n        while (--fromHeight >= 0) {\n            sourceBuf.copy(targetBuf, ti, si, si + copyByteWidth);\n            si += sourceByteWidth;\n            ti += targetByteWidth;\n        }\n        return this;\n    }\n\n    /**\n     * Fills the image with a single color.\n     * \n     * @param {number} rgba Color with which to fill image, expressed as a singlenumber in the form 0xRRGGBBAA, where AA is 0x00 for transparent and any other value for opaque.\n     * @return {BitmapImage} The present image to allow for chaining.\n     */\n\n    fillRGBA(rgba) {\n        const buf = this.bitmap.data;\n        const bufByteWidth = this.bitmap.height * 4;\n        \n        let bi = 0;\n        while (bi < bufByteWidth) {\n            buf.writeUInt32BE(rgba, bi);\n            bi += 4;\n        }\n        while (bi < buf.length) {\n            buf.copy(buf, bi, 0, bufByteWidth);\n            bi += bufByteWidth;\n        }\n        return this;\n    }\n\n    /**\n     * Gets the RGBA number of the pixel at the given coordinate in the form 0xRRGGBBAA, where AA is the alpha value, with alpha 0x00 encoding to transparency in GIFs.\n     * \n     * @param {number} x x-coord of pixel\n     * @param {number} y y-coord of pixel\n     * @return {number} RGBA of pixel in 0xRRGGBBAA form\n     */\n\n    getRGBA(x, y) {\n        const bi = (y * this.bitmap.width + x) * 4;\n        return this.bitmap.data.readUInt32BE(bi);\n    }\n\n    /**\n     * Gets a set of all RGBA colors found within the image.\n     * \n     * @return {Set} Set of all RGBA colors that the image contains.\n     */\n\n    getRGBASet() {\n        const rgbaSet = new Set();\n        const buf = this.bitmap.data;\n        for (let bi = 0; bi < buf.length; bi += 4) {\n            rgbaSet.add(buf.readUInt32BE(bi, true));\n        }\n        return rgbaSet;\n    }\n\n    /**\n     * Converts the image to greyscale using inferred Adobe metrics.\n     * \n     * @return {BitmapImage} The present image to allow for chaining.\n     */\n\n    greyscale() {\n        const buf = this.bitmap.data;\n        this.scan(0, 0, this.bitmap.width, this.bitmap.height, (x, y, idx) => {\n            const grey = Math.round(\n                0.299 * buf[idx] +\n                0.587 * buf[idx + 1] +\n                0.114 * buf[idx + 2]\n            );\n            buf[idx] = grey;\n            buf[idx + 1] = grey;\n            buf[idx + 2] = grey;\n        });\n        return this;\n    }\n\n    /**\n     * Reframes the image as if placing a frame around the original image and replacing the original image with the newly framed image. When the new frame is strictly within the boundaries of the original image, this method crops the image. When any of the new boundaries exceed those of the original image, the `fillRGBA` must be provided to indicate the color with which to fill the extra space added to the image.\n     * \n     * @param {number} xOffset The x-coord offset of the upper-left pixel of the desired image relative to the present image.\n     * @param {number} yOffset The y-coord offset of the upper-left pixel of the desired image relative to the present image.\n     * @param {number} width The width of the new image after reframing\n     * @param {number} height The height of the new image after reframing\n     * @param {number} fillRGBA The color with which to fill space added to the image as a result of the reframing, in 0xRRGGBBAA format, where AA is 0x00 to indicate transparent and a non-zero value to indicate opaque. This parameter is only required when the reframing exceeds the original boundaries (i.e. does not simply perform a crop).\n     * @return {BitmapImage} The present image to allow for chaining.\n     */\n\n    reframe(xOffset, yOffset, width, height, fillRGBA) {\n        const cropX = (xOffset < 0 ? 0 : xOffset);\n        const cropY = (yOffset < 0 ? 0 : yOffset);\n        const cropWidth = (width + cropX > this.bitmap.width ?\n                this.bitmap.width - cropX : width);\n        const cropHeight = (height + cropY > this.bitmap.height ?\n                this.bitmap.height - cropY : height);\n        const newX = (xOffset < 0 ? -xOffset : 0);\n        const newY = (yOffset < 0 ? -yOffset : 0);\n\n        let image;\n        if (fillRGBA === undefined) {\n            if (cropX !== xOffset || cropY != yOffset ||\n                    cropWidth !== width || cropHeight !== height)\n            {\n                throw new GifError(`fillRGBA required for this reframing`);\n            }\n            image = new BitmapImage(width, height);\n        }\n        else {\n            image = new BitmapImage(width, height, fillRGBA);\n        }\n        this.blit(image, newX, newY, cropX, cropY, cropWidth, cropHeight);\n        this.bitmap = image.bitmap;\n        return this;\n    }\n\n    /**\n     * Scales the image size up by an integer factor. Each pixel of the original image becomes a square of the same color in the new image having a size of `factor` x `factor` pixels.\n     * \n     * @param {number} factor The factor by which to scale up the image. Must be an integer >= 1.\n     * @return {BitmapImage} The present image to allow for chaining.\n     */\n\n    scale(factor) {\n        if (factor === 1) {\n            return;\n        }\n        if (!Number.isInteger(factor) || factor < 1) {\n            throw new Error(\"the scale must be an integer >= 1\");\n        }\n        const sourceWidth = this.bitmap.width;\n        const sourceHeight = this.bitmap.height;\n        const destByteWidth = sourceWidth * factor * 4;\n        const sourceBuf = this.bitmap.data;\n        const destBuf = new Buffer(sourceHeight * destByteWidth * factor);\n        let sourceIndex = 0;\n        let priorDestRowIndex;\n        let destIndex = 0;\n        for (let y = 0; y < sourceHeight; ++y) {\n            priorDestRowIndex = destIndex;\n            for (let x = 0; x < sourceWidth; ++x) {\n                const color = sourceBuf.readUInt32BE(sourceIndex, true);\n                for (let cx = 0; cx < factor; ++cx) {\n                    destBuf.writeUInt32BE(color, destIndex);\n                    destIndex += 4;\n                }\n                sourceIndex += 4;\n            }\n            for (let cy = 1; cy < factor; ++cy) {\n                destBuf.copy(destBuf, destIndex, priorDestRowIndex, destIndex);\n                destIndex += destByteWidth;\n                priorDestRowIndex += destByteWidth;\n            }\n        }\n        this.bitmap = {\n            width: sourceWidth * factor,\n            height: sourceHeight * factor,\n            data: destBuf\n        };\n        return this;\n    }\n\n    /**\n     * Scans all coordinates of the image, handing each in turn to the provided handler function.\n     *\n     * @param {function} scanHandler A function(x: number, y: number, bi: number) to be called for each pixel of the image with that pixel's x-coord, y-coord, and index into the `data` buffer. The function accesses the pixel at this coordinate by accessing the `this.data` at index `bi`.\n     * @see scanAllIndexes\n     */\n\n    scanAllCoords(scanHandler) {\n        const width = this.bitmap.width;\n        const bufferLength = this.bitmap.data.length;\n        let x = 0;\n        let y = 0;\n\n        for (let bi = 0; bi < bufferLength; bi += 4) {\n            scanHandler(x, y, bi);\n            if (++x === width) {\n                x = 0;\n                ++y;\n            }\n        }\n    }\n\n    /**\n     * Scans all pixels of the image, handing the index of each in turn to the provided handler function. Runs a bit faster than `scanAllCoords()`, should the handler not need pixel coordinates.\n     *\n     * @param {function} scanHandler A function(bi: number) to be called for each pixel of the image with that pixel's index into the `data` buffer. The pixels is found at index 'bi' within `this.data`.\n     * @see scanAllCoords\n     */\n\n    scanAllIndexes(scanHandler) {\n        const bufferLength = this.bitmap.data.length;\n        for (let bi = 0; bi < bufferLength; bi += 4) {\n            scanHandler(bi);\n        }\n    }\n}\n\nmodule.exports = BitmapImage;\n", "'use strict';\n\n/** @class Gif */\n\nclass Gif {\n\n    // width - width of GIF in pixels\n    // height - height of GIF in pixels\n    // loops - 0 = unending; (n > 0) = iterate n times\n    // usesTransparency - whether any frames have transparent pixels\n    // colorScope - scope of color tables in GIF\n    // frames - array of frames\n    // buffer - GIF-formatted data\n\n    /**\n     * Gif is a class representing an encoded GIF. It is intended to be a read-only representation of a byte-encoded GIF. Only encoders and decoders should be creating instances of this class.\n     * \n     * Property | Description\n     * --- | ---\n     * width | width of the GIF at its widest\n     * height | height of the GIF at its highest\n     * loops | the number of times the GIF should loop before stopping; 0 => loop indefinately\n     * usesTransparency | boolean indicating whether at least one frame contains at least one transparent pixel\n     * colorScope | the scope of the color tables as encoded within the GIF; either Gif.GlobalColorsOnly (== 1) or Gif.LocalColorsOnly (== 2).\n     * frames | a array of GifFrame instances, one for each frame of the GIF\n     * buffer | a Buffer holding the encoding's byte data\n     * \n     * Its constructor should only ever be called by the GIF encoder or decoder.\n     *\n     * @param {Buffer} buffer A Buffer containing the encoded bytes\n     * @param {GifFrame[]} frames Array of frames found in the encoding\n     * @param {object} spec Properties of the encoding as listed above\n     */\n\n    constructor(buffer, frames, spec) {\n        this.width = spec.width;\n        this.height = spec.height;\n        this.loops = spec.loops;\n        this.usesTransparency = spec.usesTransparency;\n        this.colorScope = spec.colorScope;\n        this.frames = frames;\n        this.buffer = buffer;\n    }\n}\n\nGif.GlobalColorsPreferred = 0;\nGif.GlobalColorsOnly = 1;\nGif.LocalColorsOnly = 2;\n\n/** @class GifError */\n\nclass GifError extends Error {\n\n    /**\n     * GifError is a class representing a GIF-related error\n     * \n     * @param {string|Error} messageOrError\n     */\n\n    constructor(messageOrError) {\n        super(messageOrError);\n        if (messageOrError instanceof Error) {\n            this.stack = 'Gif' + messageOrError.stack;\n        }\n    }\n}\n\nexports.Gif = Gif;\nexports.GifError = GifError;\n", "(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"iq\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"iq\"] = factory();\n\telse\n\t\troot[\"iq\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/", " \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap cc12c561526565ac4570\n **/", "/**\r\n * @preserve\r\n * Copyright 2015-2016 Igor Bezkrovnyi\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * iq.ts - Image Quantization Library\r\n */\r\nimport * as constants from \"./constants\"\r\nimport * as conversion from \"./conversion\"\r\nimport * as distance from \"./distance\"\r\nimport * as palette from \"./palette\"\r\nimport * as image from \"./image\"\r\nimport * as quality from \"./quality\"\r\nimport * as utils from \"./utils\"\r\n\r\nexport {\r\n    constants,\r\n    conversion,\r\n    distance,\r\n    palette,\r\n    image,\r\n    quality,\r\n    utils\r\n}\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/iq.ts\n **/", "/**\r\n * @preserve\r\n * Copyright 2015-2016 Igor Bezkrovnyi\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * constants.ts - part of Image Quantization Library\r\n */\r\nimport * as bt709 from \"./bt709\"\r\n\r\nexport {\r\n    bt709\r\n}\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/constants/index.ts\n **/", "/**\r\n * @preserve\r\n * Copyright 2015-2016 Igor Bezkrovnyi\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * constants.ts - part of Image Quantization Library\r\n */\r\n\r\n/**\r\n * sRGB (based on ITU-R Recommendation BT.709)\r\n * http://en.wikipedia.org/wiki/SRGB\r\n */\r\nenum Y {\r\n    RED = .2126, GREEN = .7152, BLUE = .0722, WHITE = 1\r\n}\r\n\r\nenum x {\r\n    RED = .6400, GREEN = .3000, BLUE = .1500, WHITE = .3127\r\n}\r\n\r\nenum y {\r\n    RED = .3300, GREEN = .6000, BLUE = .0600, WHITE = .3290\r\n}\r\n\r\nexport {\r\n    Y,\r\n    x,\r\n    y\r\n}\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/constants/bt709.ts\n **/", "/**\r\n * @preserve\r\n * Copyright 2015-2016 Igor Bezkrovnyi\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * iq.ts - Image Quantization Library\r\n */\r\nimport { rgb2xyz } from \"./rgb2xyz\"\r\nimport { rgb2hsl } from \"./rgb2hsl\"\r\nimport { rgb2lab } from \"./rgb2lab\"\r\nimport { lab2xyz } from \"./lab2xyz\"\r\nimport { lab2rgb } from \"./lab2rgb\"\r\nimport { xyz2lab } from \"./xyz2lab\"\r\nimport { xyz2rgb } from \"./xyz2rgb\"\r\n\r\nexport {\r\n    rgb2xyz,\r\n    rgb2hsl,\r\n    rgb2lab,\r\n    lab2xyz,\r\n    lab2rgb,\r\n    xyz2lab,\r\n    xyz2rgb,\r\n}\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/conversion/index.ts\n **/", "/**\r\n * @preserve\r\n * Copyright 2015-2016 Igor Bezkrovnyi\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * rgb2xyz.ts - part of Image Quantization Library\r\n */\r\nfunction correctGamma(n : number) {\r\n    return n > 0.04045 ? Math.pow((n + 0.055) / 1.055, 2.4) : n / 12.92;\r\n}\r\n\r\nexport function rgb2xyz(r : number, g : number, b : number) : { x : number; y : number; z : number } {\r\n    // gamma correction, see https://en.wikipedia.org/wiki/SRGB#The_reverse_transformation\r\n    r = correctGamma(r / 255);\r\n    g = correctGamma(g / 255);\r\n    b = correctGamma(b / 255);\r\n\r\n    // Observer. = 2\u00B0, Illuminant = D65\r\n    return {\r\n        x : r * 0.4124 + g * 0.3576 + b * 0.1805,\r\n        y : r * 0.2126 + g * 0.7152 + b * 0.0722,\r\n        z : r * 0.0193 + g * 0.1192 + b * 0.9505\r\n    }\r\n}\r\n\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/conversion/rgb2xyz.ts\n **/", "/**\r\n * @preserve\r\n * Copyright 2015-2016 Igor Bezkrovnyi\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * rgb2hsl.ts - part of Image Quantization Library\r\n */\r\nimport { min3, max3 } from \"../utils/arithmetic\"\r\n\r\n/**\r\n * Calculate HSL from RGB\r\n * Hue is in degrees [0..360]\r\n * Lightness: [0..1]\r\n * Saturation: [0..1]\r\n * http://web.archive.org/web/20060914040436/http://local.wasp.uwa.edu.au/~pbourke/colour/hsl/\r\n */\r\nexport function rgb2hsl(r : number, g : number, b : number) : {h : number; s : number; l : number} {\r\n    const min   = min3(r, g, b),\r\n          max   = max3(r, g, b),\r\n          delta = max - min,\r\n          l     = (min + max) / 510;\r\n\r\n    let s = 0;\r\n    if (l > 0 && l < 1) s = delta / (l < 0.5 ? (max + min) : (510 - max - min));\r\n\r\n    let h = 0;\r\n    if (delta > 0) {\r\n        if (max === r) {\r\n            h = (g - b) / delta;\r\n        } else if (max === g) {\r\n            h = (2 + (b - r) / delta);\r\n        } else {\r\n            h = (4 + (r - g) / delta);\r\n        }\r\n\r\n        h *= 60;\r\n        if (h < 0) h += 360;\r\n    }\r\n    return { h, s, l };\r\n}\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/conversion/rgb2hsl.ts\n **/", "export function degrees2radians(n : number) : number {\r\n    return n * (Math.PI / 180);\r\n}\r\n\r\nexport function max3(a : number, b : number, c : number) {\r\n    let m = a;\r\n    (m < b) && (m = b);\r\n    (m < c) && (m = c);\r\n    return m;\r\n}\r\n\r\nexport function min3(a : number, b : number, c : number) {\r\n    let m = a;\r\n    (m > b) && (m = b);\r\n    (m > c) && (m = c);\r\n    return m;\r\n}\r\n\r\nexport function intInRange(value : number, low : number, high : number) {\r\n    if (value > high) value = high;\r\n    if (value < low) value = low;\r\n    return value | 0;\r\n}\r\n\r\nexport function inRange0to255Rounded(n : number) {\r\n    n = Math.round(n);\r\n    if (n > 255) n = 255;\r\n    else if (n < 0) n = 0;\r\n    return n;\r\n}\r\n\r\nexport function inRange0to255(n : number) {\r\n    if (n > 255) n = 255;\r\n    else if (n < 0) n = 0;\r\n    return n;\r\n}\r\n\r\nexport function stableSort<T>(arrayToSort : T[], callback : (a : T, b : T) => number) : T[] {\r\n    const type = typeof arrayToSort[ 0 ];\r\n    let sorted : T[];\r\n\r\n    if (type === \"number\" || type === \"string\") {\r\n        const ord = Object.create(null);\r\n        for (let i = 0, l = arrayToSort.length; i < l; i++) {\r\n            const val : string = <any>arrayToSort[ i ];\r\n            if (ord[ val ] || ord[ val ] === 0) continue;\r\n            ord[ val ] = i;\r\n        }\r\n\r\n        sorted = arrayToSort.sort(function (a, b) {\r\n            return callback(a, b) || ord[ <any>a ] - ord[ <any>b ];\r\n        });\r\n    } else {\r\n        const ord2 : T[] = arrayToSort.slice(0);\r\n        sorted           = arrayToSort.sort(function (a, b) {\r\n            return callback(a, b) || ord2.indexOf(a) - ord2.indexOf(b);\r\n        });\r\n    }\r\n\r\n    return sorted;\r\n}\r\n\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/utils/arithmetic.ts\n **/", "/**\r\n * @preserve\r\n * Copyright 2015-2016 Igor Bezkrovnyi\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * rgb2lab.ts - part of Image Quantization Library\r\n */\r\nimport { rgb2xyz } from \"./rgb2xyz\"\r\nimport { xyz2lab } from \"./xyz2lab\"\r\n\r\nexport function rgb2lab(r : number, g : number, b : number) : { L : number; a : number; b : number } {\r\n    const xyz = rgb2xyz(r, g, b);\r\n    return xyz2lab(xyz.x, xyz.y, xyz.z);\r\n}\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/conversion/rgb2lab.ts\n **/", "/**\r\n * @preserve\r\n * Copyright 2015-2016 Igor Bezkrovnyi\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * xyz2lab.ts - part of Image Quantization Library\r\n */\r\nconst refX : number = 0.95047, //ref_X =  95.047   Observer= 2\u00B0, Illuminant= D65\r\n      refY : number = 1.00000, //ref_Y = 100.000\r\n      refZ : number = 1.08883; //ref_Z = 108.883\r\n\r\nfunction pivot(n : number) : number {\r\n    return n > 0.008856 ? Math.pow(n, 1 / 3) : ( 7.787 * n + 16 / 116);\r\n}\r\n\r\nexport function xyz2lab(x : number, y : number, z : number) : {L : number; a : number; b : number} {\r\n    x = pivot(x / refX);\r\n    y = pivot(y / refY);\r\n    z = pivot(z / refZ);\r\n\r\n    if (( 116 * y ) - 16 < 0) throw new Error(\"xxx\")\r\n    return {\r\n        L : Math.max(0, ( 116 * y ) - 16),\r\n        a : 500 * ( x - y ),\r\n        b : 200 * ( y - z )\r\n    }\r\n}\r\n\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/conversion/xyz2lab.ts\n **/", "/**\r\n * @preserve\r\n * Copyright 2015-2016 Igor Bezkrovnyi\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * lab2xyz.ts - part of Image Quantization Library\r\n */\r\nconst refX : number = 0.95047, //ref_X =  95.047   Observer= 2\u00B0, Illuminant = D65\r\n      refY : number = 1.00000, //ref_Y = 100.000\r\n      refZ : number = 1.08883; //ref_Z = 108.883\r\n\r\nfunction pivot(n : number) {\r\n    return n > 0.206893034 ? Math.pow(n, 3) : ( n - 16 / 116 ) / 7.787\r\n}\r\n\r\nexport function lab2xyz(L : number, a : number, b : number) : {x : number; y : number; z : number} {\r\n    const y = ( L + 16 ) / 116,\r\n          x = a / 500 + y,\r\n          z = y - b / 200;\r\n\r\n    return {\r\n        x : refX * pivot(x),\r\n        y : refY * pivot(y),\r\n        z : refZ * pivot(z)\r\n    }\r\n}\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/conversion/lab2xyz.ts\n **/", "/**\r\n * @preserve\r\n * Copyright 2015-2016 Igor Bezkrovnyi\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * lab2rgb.ts - part of Image Quantization Library\r\n */\r\nimport { lab2xyz } from \"./lab2xyz\"\r\nimport { xyz2rgb } from \"./xyz2rgb\"\r\n\r\nexport function lab2rgb(L : number, a : number, b : number) : { r : number; g : number; b : number } {\r\n    const xyz = lab2xyz(L, a, b);\r\n    return xyz2rgb(xyz.x, xyz.y, xyz.z);\r\n}\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/conversion/lab2rgb.ts\n **/", "/**\r\n * @preserve\r\n * Copyright 2015-2016 Igor Bezkrovnyi\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * xyz2rgb.ts - part of Image Quantization Library\r\n */\r\nimport { inRange0to255Rounded } from \"../utils/arithmetic\"\r\n\r\n// gamma correction, see https://en.wikipedia.org/wiki/SRGB#The_reverse_transformation\r\nfunction correctGamma(n : number) {\r\n    return n > 0.0031308 ? 1.055 * Math.pow(n, 1 / 2.4) - 0.055 : 12.92 * n;\r\n}\r\n\r\nexport function xyz2rgb(x : number, y : number, z : number) : { r : number; g : number; b : number } {\r\n    // Observer. = 2\u00B0, Illuminant = D65\r\n    const r = correctGamma(x * 3.2406 + y * -1.5372 + z * -0.4986),\r\n          g = correctGamma(x * -0.9689 + y * 1.8758 + z * 0.0415),\r\n          b = correctGamma(x * 0.0557 + y * -0.2040 + z * 1.0570);\r\n\r\n    return {\r\n        r : inRange0to255Rounded(r * 255),\r\n        g : inRange0to255Rounded(g * 255),\r\n        b : inRange0to255Rounded(b * 255)\r\n    }\r\n}\r\n\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/conversion/xyz2rgb.ts\n **/", "/**\r\n * @preserve\r\n * Copyright 2015-2016 Igor Bezkrovnyi\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * iq.ts - Image Quantization Library\r\n */\r\nimport { AbstractDistanceCalculator } from \"./abstractDistanceCalculator\"\r\nimport { CIE94Textiles, CIE94GraphicArts } from \"./cie94\"\r\nimport { CIEDE2000 } from \"./ciede2000\"\r\nimport { CMETRIC } from \"./cmetric\"\r\nimport { AbstractEuclidean, Euclidean, EuclideanRgbQuantWOAlpha, EuclideanRgbQuantWithAlpha } from \"./euclidean\"\r\nimport { AbstractManhattan, Manhattan, ManhattanSRGB, ManhattanNommyde } from \"./manhattan\"\r\nimport { PNGQUANT } from \"./pngQuant\"\r\n\r\nexport {\r\n    AbstractDistanceCalculator,\r\n    CIE94Textiles,\r\n    CIE94GraphicArts,\r\n    CIEDE2000,\r\n    CMETRIC,\r\n    PNGQUANT,\r\n\r\n    AbstractEuclidean,\r\n    Euclidean,\r\n    EuclideanRgbQuantWithAlpha,\r\n    EuclideanRgbQuantWOAlpha,\r\n\r\n    AbstractManhattan,\r\n    Manhattan,\r\n    ManhattanSRGB,\r\n    ManhattanNommyde\r\n}\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/distance/index.ts\n **/", "/**\r\n * @preserve\r\n * Copyright 2015-2016 Igor Bezkrovnyi\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * common.ts - part of Image Quantization Library\r\n */\r\nimport { Point } from \"../utils/point\"\r\n\r\nexport abstract class AbstractDistanceCalculator {\r\n    protected _maxDistance : number;\r\n    protected _whitePoint : { r : number; g : number; b : number; a : number };\r\n\r\n    constructor() {\r\n        this._setDefaults();\r\n\r\n        // set default maximal color component deltas (255 - 0 = 255)\r\n        this.setWhitePoint(255, 255, 255, 255);\r\n    }\r\n\r\n    setWhitePoint(r : number, g : number, b : number, a : number) : void {\r\n        this._whitePoint  = {\r\n            r : (r > 0) ? 255 / r : 0,\r\n            g : (g > 0) ? 255 / g : 0,\r\n            b : (b > 0) ? 255 / b : 0,\r\n            a : (a > 0) ? 255 / a : 0\r\n        };\r\n        this._maxDistance = this.calculateRaw(r, g, b, a, 0, 0, 0, 0);\r\n    }\r\n\r\n    calculateNormalized(colorA : Point, colorB : Point) : number {\r\n        return this.calculateRaw(colorA.r, colorA.g, colorA.b, colorA.a, colorB.r, colorB.g, colorB.b, colorB.a) / this._maxDistance;\r\n    }\r\n\r\n    protected _setDefaults() : void {\r\n    }\r\n\r\n    /**\r\n     * Calculate raw distance (non-normalized)\r\n     */\r\n    abstract calculateRaw(r1 : number, g1 : number, b1 : number, a1 : number, r2 : number, g2 : number, b2 : number, a2 : number) : number;\r\n}\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/distance/abstractDistanceCalculator.ts\n **/", "/**\r\n * @preserve\r\n * Copyright 2015-2016 Igor Bezkrovnyi\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * cie94.ts - part of Image Quantization Library\r\n */\r\nimport { AbstractDistanceCalculator } from \"./abstractDistanceCalculator\"\r\nimport { rgb2lab } from \"../conversion/rgb2lab\"\r\nimport { inRange0to255 } from \"../utils/arithmetic\"\r\n\r\n/**\r\n * CIE94 method of delta-e\r\n * http://en.wikipedia.org/wiki/Color_difference#CIE94\r\n */\r\nexport abstract class AbstractCIE94 extends AbstractDistanceCalculator {\r\n    /**\r\n     * Weight in distance: 0.25\r\n     * Max DeltaE: 100\r\n     * Max DeltaA: 255\r\n     */\r\n    protected _kA : number;\r\n    protected _Kl : number;\r\n    protected _K1 : number;\r\n    protected _K2 : number;\r\n\r\n    calculateRaw(r1 : number, g1 : number, b1 : number, a1 : number, r2 : number, g2 : number, b2 : number, a2 : number) : number {\r\n        const lab1 = rgb2lab(inRange0to255(r1 * this._whitePoint.r), inRange0to255(g1 * this._whitePoint.g), inRange0to255(b1 * this._whitePoint.b)),\r\n              lab2 = rgb2lab(inRange0to255(r2 * this._whitePoint.r), inRange0to255(g2 * this._whitePoint.g), inRange0to255(b2 * this._whitePoint.b));\r\n\r\n        const dL = lab1.L - lab2.L,\r\n              dA = lab1.a - lab2.a,\r\n              dB = lab1.b - lab2.b,\r\n              c1 = Math.sqrt(lab1.a * lab1.a + lab1.b * lab1.b),\r\n              c2 = Math.sqrt(lab2.a * lab2.a + lab2.b * lab2.b),\r\n              dC = c1 - c2;\r\n\r\n        let deltaH = dA * dA + dB * dB - dC * dC;\r\n        deltaH     = deltaH < 0 ? 0 : Math.sqrt(deltaH);\r\n\r\n        const dAlpha = (a2 - a1) * this._whitePoint.a * this._kA;\r\n\r\n        // TODO: add alpha channel support\r\n        return Math.sqrt(\r\n            Math.pow(dL / this._Kl, 2) +\r\n            Math.pow(dC / (1.0 + this._K1 * c1), 2) +\r\n            Math.pow(deltaH / (1.0 + this._K2 * c1), 2) +\r\n            Math.pow(dAlpha, 2)\r\n        );\r\n    }\r\n}\r\n\r\nexport class CIE94Textiles extends AbstractCIE94 {\r\n    protected _setDefaults() {\r\n        this._Kl = 2.0;\r\n        this._K1 = 0.048;\r\n        this._K2 = 0.014;\r\n        this._kA = 0.25 * 50 / 255;\r\n    }\r\n}\r\n\r\nexport class CIE94GraphicArts extends AbstractCIE94 {\r\n    protected _setDefaults() {\r\n        this._Kl = 1.0;\r\n        this._K1 = 0.045;\r\n        this._K2 = 0.015;\r\n        this._kA = 0.25 * 100 / 255;\r\n    }\r\n}\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/distance/cie94.ts\n **/", "/**\r\n * @preserve\r\n * Copyright 2015-2016 Igor Bezkrovnyi\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * ciede2000.ts - part of Image Quantization Library\r\n */\r\nimport { AbstractDistanceCalculator } from \"./abstractDistanceCalculator\";\r\nimport { rgb2lab } from \"../conversion/rgb2lab\";\r\nimport { degrees2radians, inRange0to255 } from \"../utils/arithmetic\";\r\n\r\n/**\r\n * CIEDE2000 algorithm - Adapted from Sharma et al's MATLAB implementation at\r\n * http://www.ece.rochester.edu/~gsharma/ciede2000/\r\n */\r\nexport class CIEDE2000 extends AbstractDistanceCalculator {\r\n    /**\r\n     * Weight in distance: 0.25\r\n     * Max DeltaE: 100\r\n     * Max DeltaA: 255\r\n     */\r\n    private static readonly _kA                   = 0.25 * 100 / 255;\r\n    private static readonly _pow25to7 : number    = Math.pow(25, 7);\r\n    private static readonly _deg360InRad : number = degrees2radians(360);\r\n    private static readonly _deg180InRad : number = degrees2radians(180);\r\n    private static readonly _deg30InRad : number  = degrees2radians(30);\r\n    private static readonly _deg6InRad : number   = degrees2radians(6);\r\n    private static readonly _deg63InRad : number  = degrees2radians(63);\r\n    private static readonly _deg275InRad : number = degrees2radians(275);\r\n    private static readonly _deg25InRad : number  = degrees2radians(25);\r\n\r\n    calculateRaw(r1 : number, g1 : number, b1 : number, a1 : number, r2 : number, g2 : number, b2 : number, a2 : number) : number {\r\n        const lab1 = rgb2lab(inRange0to255(r1 * this._whitePoint.r), inRange0to255(g1 * this._whitePoint.g), inRange0to255(b1 * this._whitePoint.b)),\r\n              lab2 = rgb2lab(inRange0to255(r2 * this._whitePoint.r), inRange0to255(g2 * this._whitePoint.g), inRange0to255(b2 * this._whitePoint.b)),\r\n              dA   = (a2 - a1) * this._whitePoint.a * CIEDE2000._kA,\r\n              dE2  = this.calculateRawInLab(lab1, lab2);\r\n\r\n        return Math.sqrt(dE2 + dA * dA);\r\n    }\r\n\r\n    calculateRawInLab(Lab1 : {L : number; a : number; b : number}, Lab2 : {L : number; a : number; b : number}) : number {\r\n        // Get L,a,b values for color 1\r\n        const L1 = Lab1.L,\r\n              a1 = Lab1.a,\r\n              b1 = Lab1.b;\r\n\r\n        // Get L,a,b values for color 2\r\n        const L2 = Lab2.L,\r\n              a2 = Lab2.a,\r\n              b2 = Lab2.b;\r\n\r\n        // Calculate Cprime1, Cprime2, Cabbar\r\n        const C1                  = Math.sqrt(a1 * a1 + b1 * b1),\r\n              C2                  = Math.sqrt(a2 * a2 + b2 * b2),\r\n              pow_a_C1_C2_to_7    = Math.pow((C1 + C2) / 2.0, 7.0),\r\n\r\n              G                   = 0.5 * (1.0 - Math.sqrt(pow_a_C1_C2_to_7 / (pow_a_C1_C2_to_7 + CIEDE2000._pow25to7))), //25^7\r\n              a1p                 = (1.0 + G) * a1,\r\n              a2p                 = (1.0 + G) * a2,\r\n\r\n              C1p                 = Math.sqrt(a1p * a1p + b1 * b1),\r\n              C2p                 = Math.sqrt(a2p * a2p + b2 * b2),\r\n              C1pC2p              = C1p * C2p,\r\n\r\n              // Angles in Degree.\r\n              h1p                 = CIEDE2000._calculatehp(b1, a1p),\r\n              h2p                 = CIEDE2000._calculatehp(b2, a2p),\r\n              h_bar               = Math.abs(h1p - h2p),\r\n              dLp                 = L2 - L1,\r\n              dCp                 = C2p - C1p,\r\n              dHp                 = CIEDE2000._calculate_dHp(C1pC2p, h_bar, h2p, h1p),\r\n              ahp                 = CIEDE2000._calculate_ahp(C1pC2p, h_bar, h1p, h2p),\r\n\r\n              T                   = CIEDE2000._calculateT(ahp),\r\n\r\n              aCp                 = (C1p + C2p) / 2.0,\r\n              aLp_minus_50_square = Math.pow((L1 + L2) / 2.0 - 50.0, 2.0),\r\n              S_L                 = 1.0 + (.015 * aLp_minus_50_square) / Math.sqrt(20.0 + aLp_minus_50_square),\r\n              S_C                 = 1.0 + .045 * aCp,\r\n              S_H                 = 1.0 + .015 * T * aCp,\r\n\r\n              R_T                 = CIEDE2000._calculateRT(ahp, aCp),\r\n\r\n              dLpSL               = dLp / S_L, // S_L * kL, where kL is 1.0\r\n              dCpSC               = dCp / S_C, // S_C * kC, where kC is 1.0\r\n              dHpSH               = dHp / S_H; // S_H * kH, where kH is 1.0\r\n\r\n        return Math.pow(dLpSL, 2) + Math.pow(dCpSC, 2) + Math.pow(dHpSH, 2) + R_T * dCpSC * dHpSH;\r\n    }\r\n\r\n    private static _calculatehp(b : number, ap : number) {\r\n        const hp = Math.atan2(b, ap);\r\n        if (hp >= 0) return hp;\r\n        return hp + CIEDE2000._deg360InRad;\r\n    }\r\n\r\n    private static _calculateRT(ahp : number, aCp : number) {\r\n        const aCp_to_7    = Math.pow(aCp, 7.0),\r\n              R_C         = 2.0 * Math.sqrt(aCp_to_7 / (aCp_to_7 + CIEDE2000._pow25to7)), // 25^7\r\n              delta_theta = CIEDE2000._deg30InRad * Math.exp(-Math.pow((ahp - CIEDE2000._deg275InRad) / CIEDE2000._deg25InRad, 2.0));\r\n        return -Math.sin(2.0 * delta_theta) * R_C;\r\n    }\r\n\r\n    private static _calculateT(ahp : number) {\r\n        return 1.0 - .17 * Math.cos(ahp - CIEDE2000._deg30InRad) + .24 * Math.cos(ahp * 2.0) + .32 * Math.cos(ahp * 3.0 + CIEDE2000._deg6InRad) - .2 * Math.cos(ahp * 4.0 - CIEDE2000._deg63InRad);\r\n    }\r\n\r\n    private static _calculate_ahp(C1pC2p : number, h_bar : number, h1p : number, h2p : number) {\r\n        const hpSum = h1p + h2p;\r\n        if (C1pC2p == 0) return hpSum;\r\n        if (h_bar <= CIEDE2000._deg180InRad) return hpSum / 2.0;\r\n        if (hpSum < CIEDE2000._deg360InRad) return (hpSum + CIEDE2000._deg360InRad) / 2.0;\r\n        return (hpSum - CIEDE2000._deg360InRad) / 2.0;\r\n    }\r\n\r\n    private static _calculate_dHp(C1pC2p : number, h_bar : number, h2p : number, h1p : number) {\r\n        let dhp : number;\r\n        if (C1pC2p == 0) {\r\n            dhp = 0;\r\n        } else if (h_bar <= CIEDE2000._deg180InRad) {\r\n            dhp = h2p - h1p;\r\n        } else if (h2p <= h1p) {\r\n            dhp = h2p - h1p + CIEDE2000._deg360InRad;\r\n        } else {\r\n            dhp = h2p - h1p - CIEDE2000._deg360InRad;\r\n        }\r\n        return 2.0 * Math.sqrt(C1pC2p) * Math.sin(dhp / 2.0);\r\n    }\r\n}\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/distance/ciede2000.ts\n **/", "/**\r\n * @preserve\r\n * Copyright 2015-2016 Igor Bezkrovnyi\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * cmetric.ts - part of Image Quantization Library\r\n */\r\nimport { AbstractDistanceCalculator } from \"./abstractDistanceCalculator\"\r\n\r\n/**\r\n * TODO: Name it: http://www.compuphase.com/cmetric.htm\r\n */\r\nexport class CMETRIC extends AbstractDistanceCalculator {\r\n    calculateRaw(r1 : number, g1 : number, b1 : number, a1 : number, r2 : number, g2 : number, b2 : number, a2 : number) : number {\r\n        const rmean = (r1 + r2) / 2 * this._whitePoint.r,\r\n              r     = (r1 - r2) * this._whitePoint.r,\r\n              g     = (g1 - g2) * this._whitePoint.g,\r\n              b     = (b1 - b2) * this._whitePoint.b,\r\n              dE    = ((((512 + rmean) * r * r) >> 8) + 4 * g * g + (((767 - rmean) * b * b) >> 8)),\r\n              dA    = (a2 - a1) * this._whitePoint.a;\r\n\r\n        return Math.sqrt(dE + dA * dA);\r\n    }\r\n}\r\n\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/distance/cmetric.ts\n **/", "/**\r\n * @preserve\r\n * Copyright 2015-2016 Igor Bezkrovnyi\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * euclidean.ts - part of Image Quantization Library\r\n */\r\nimport { AbstractDistanceCalculator } from \"./abstractDistanceCalculator\"\r\nimport { Y } from \"../constants/bt709\"\r\n\r\n/**\r\n * Euclidean color distance\r\n */\r\nexport class AbstractEuclidean extends AbstractDistanceCalculator {\r\n    protected _kR : number;\r\n    protected _kG : number;\r\n    protected _kB : number;\r\n    protected _kA : number;\r\n\r\n    calculateRaw(r1 : number, g1 : number, b1 : number, a1 : number, r2 : number, g2 : number, b2 : number, a2 : number) : number {\r\n        const dR = r2 - r1, dG = g2 - g1, dB = b2 - b1, dA = a2 - a1;\r\n        return Math.sqrt(this._kR * dR * dR + this._kG * dG * dG + this._kB * dB * dB + this._kA * dA * dA);\r\n    }\r\n}\r\n\r\nexport class Euclidean extends AbstractEuclidean {\r\n    protected _setDefaults() {\r\n        this._kR = 1;\r\n        this._kG = 1;\r\n        this._kB = 1;\r\n        this._kA = 1;\r\n    }\r\n}\r\n\r\n/**\r\n * Euclidean color distance (RgbQuant modification w Alpha)\r\n */\r\nexport class EuclideanRgbQuantWithAlpha extends AbstractEuclidean {\r\n    protected _setDefaults() {\r\n        this._kR = Y.RED;\r\n        this._kG = Y.GREEN;\r\n        this._kB = Y.BLUE;\r\n        // TODO: what is the best coefficient below?\r\n        this._kA = 1;\r\n    }\r\n}\r\n\r\n/**\r\n * Euclidean color distance (RgbQuant modification w/o Alpha)\r\n */\r\nexport class EuclideanRgbQuantWOAlpha extends AbstractEuclidean {\r\n    protected _setDefaults() {\r\n        this._kR = Y.RED;\r\n        this._kG = Y.GREEN;\r\n        this._kB = Y.BLUE;\r\n        this._kA = 0;\r\n    }\r\n}\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/distance/euclidean.ts\n **/", "/**\r\n * @preserve\r\n * Copyright 2015-2016 Igor Bezkrovnyi\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * manhattanNeuQuant.ts - part of Image Quantization Library\r\n */\r\nimport { AbstractDistanceCalculator } from \"./abstractDistanceCalculator\"\r\nimport { Y } from \"../constants/bt709\"\r\n\r\n/**\r\n * Manhattan distance (NeuQuant modification) - w/o sRGB coefficients\r\n */\r\nexport abstract class AbstractManhattan extends AbstractDistanceCalculator {\r\n    protected _kR : number;\r\n    protected _kG : number;\r\n    protected _kB : number;\r\n    protected _kA : number;\r\n\r\n    calculateRaw(r1 : number, g1 : number, b1 : number, a1 : number, r2 : number, g2 : number, b2 : number, a2 : number) : number {\r\n        let dR = r2 - r1, dG = g2 - g1, dB = b2 - b1, dA = a2 - a1;\r\n        if (dR < 0) dR = 0 - dR;\r\n        if (dG < 0) dG = 0 - dG;\r\n        if (dB < 0) dB = 0 - dB;\r\n        if (dA < 0) dA = 0 - dA;\r\n\r\n        return this._kR * dR + this._kG * dG + this._kB * dB + this._kA * dA;\r\n    }\r\n}\r\n\r\nexport class Manhattan extends AbstractManhattan {\r\n    protected _setDefaults() {\r\n        this._kR = 1;\r\n        this._kG = 1;\r\n        this._kB = 1;\r\n        this._kA = 1;\r\n    }\r\n}\r\n\r\n/**\r\n * Manhattan distance (Nommyde modification)\r\n * https://github.com/igor-bezkrovny/image-quantization/issues/4#issuecomment-235155320\r\n */\r\nexport class ManhattanNommyde extends AbstractManhattan {\r\n    protected _setDefaults() {\r\n        this._kR = 0.4984;\r\n        this._kG = 0.8625;\r\n        this._kB = 0.2979;\r\n        // TODO: what is the best coefficient below?\r\n        this._kA = 1;\r\n    }\r\n}\r\n\r\n/**\r\n * Manhattan distance (sRGB coefficients)\r\n */\r\nexport class ManhattanSRGB extends AbstractManhattan {\r\n    protected _setDefaults() {\r\n        this._kR = Y.RED;\r\n        this._kG = Y.GREEN;\r\n        this._kB = Y.BLUE;\r\n        // TODO: what is the best coefficient below?\r\n        this._kA = 1;\r\n    }\r\n}\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/distance/manhattan.ts\n **/", "/**\r\n * @preserve\r\n * Copyright 2015-2016 Igor Bezkrovnyi\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * pngQuant.ts - part of Image Quantization Library\r\n */\r\nimport { AbstractDistanceCalculator } from \"./abstractDistanceCalculator\"\r\n\r\n/**\r\n * TODO: check quality of this distance equation\r\n * TODO: ask author for usage rights\r\n * taken from:\r\n * {@link http://stackoverflow.com/questions/4754506/color-similarity-distance-in-rgba-color-space/8796867#8796867}\r\n * {@link https://github.com/pornel/pngquant/blob/cc39b47799a7ff2ef17b529f9415ff6e6b213b8f/lib/pam.h#L148}\r\n */\r\nexport class PNGQUANT extends AbstractDistanceCalculator {\r\n    /**\r\n     * Author's comments\r\n     * px_b.rgb = px.rgb + 0*(1-px.a) // blend px on black\r\n     * px_b.a   = px.a   + 1*(1-px.a)\r\n     * px_w.rgb = px.rgb + 1*(1-px.a) // blend px on white\r\n     * px_w.a   = px.a   + 1*(1-px.a)\r\n\r\n     * px_b.rgb = px.rgb              // difference same as in opaque RGB\r\n     * px_b.a   = 1\r\n     * px_w.rgb = px.rgb - px.a       // difference simplifies to formula below\r\n     * px_w.a   = 1\r\n\r\n     * (px.rgb - px.a) - (py.rgb - py.a)\r\n     * (px.rgb - py.rgb) + (py.a - px.a)\r\n     *\r\n     */\r\n    calculateRaw(r1 : number, g1 : number, b1 : number, a1 : number, r2 : number, g2 : number, b2 : number, a2 : number) : number {\r\n        const alphas = (a2 - a1) * this._whitePoint.a;\r\n        return this._colordifference_ch(r1 * this._whitePoint.r, r2 * this._whitePoint.r, alphas) +\r\n            this._colordifference_ch(g1 * this._whitePoint.g, g2 * this._whitePoint.g, alphas) +\r\n            this._colordifference_ch(b1 * this._whitePoint.b, b2 * this._whitePoint.b, alphas);\r\n    }\r\n\r\n    private _colordifference_ch(x : number, y : number, alphas : number) {\r\n        // maximum of channel blended on white, and blended on black\r\n        // premultiplied alpha and backgrounds 0/1 shorten the formula\r\n        const black = x - y,\r\n              white = black + alphas;\r\n\r\n        return black * black + white * white;\r\n    }\r\n}\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/distance/pngQuant.ts\n **/", "/**\r\n * @preserve\r\n * Copyright 2015-2016 Igor Bezkrovnyi\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * iq.ts - Image Quantization Library\r\n */\r\nimport { IPaletteQuantizer } from \"./common\"\r\nimport { NeuQuant } from \"./neuquant/neuquant\"\r\nimport { NeuQuantFloat } from \"./neuquant/neuquantFloat\"\r\nimport { RGBQuant } from \"./rgbquant/rgbquant\"\r\nimport { ColorHistogram } from \"./rgbquant/colorHistogram\"\r\nimport { WuQuant, WuColorCube } from \"./wu/wuQuant\"\r\n\r\nexport {\r\n    IPaletteQuantizer,\r\n\r\n    NeuQuant,\r\n    NeuQuantFloat,\r\n    RGBQuant,\r\n    WuQuant,\r\n\r\n    ColorHistogram,\r\n    WuColorCube\r\n}\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/palette/index.ts\n **/", "/*\r\n * NeuQuant Neural-Net Quantization Algorithm\r\n * ------------------------------------------\r\n *\r\n * Copyright (c) 1994 Anthony Dekker\r\n *\r\n * NEUQUANT Neural-Net quantization algorithm by Anthony Dekker, 1994. See\r\n * \"Kohonen neural networks for optimal colour quantization\" in \"Network:\r\n * Computation in Neural Systems\" Vol. 5 (1994) pp 351-367. for a discussion of\r\n * the algorithm.\r\n *\r\n * Any party obtaining a copy of these files from the author, directly or\r\n * indirectly, is granted, free of charge, a full and unrestricted irrevocable,\r\n * world-wide, paid up, royalty-free, nonexclusive right and license to deal in\r\n * this software and documentation files (the \"Software\"), including without\r\n * limitation the rights to use, copy, modify, merge, publish, distribute,\r\n * sublicense, and/or sell copies of the Software, and to permit persons who\r\n * receive copies from any such party to do so, with the only requirement being\r\n * that this copyright notice remain intact.\r\n */\r\n\r\n/**\r\n * @preserve TypeScript port:\r\n * Copyright 2015-2016 Igor Bezkrovnyi\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * neuquant.ts - part of Image Quantization Library\r\n */\r\n\r\nimport { Palette } from \"../../utils/palette\"\r\nimport { Point } from \"../../utils/point\"\r\nimport { PointContainer } from \"../../utils/pointContainer\"\r\nimport { AbstractDistanceCalculator } from \"../../distance/abstractDistanceCalculator\"\r\nimport { IPaletteQuantizer } from \"../common\"\r\n\r\n// bias for colour values\r\nconst networkBiasShift = 3;\r\n\r\nclass Neuron {\r\n    r : number;\r\n    g : number;\r\n    b : number;\r\n    a : number;\r\n\r\n    constructor(defaultValue : number) {\r\n        this.r = this.g = this.b = this.a = defaultValue;\r\n    }\r\n\r\n    /**\r\n     * There is a fix in original NEUQUANT by Anthony Dekker (http://members.ozemail.com.au/~dekker/NEUQUANT.HTML)\r\n     * @example\r\n     * r = Math.min(255, (neuron.r + (1 << (networkBiasShift - 1))) >> networkBiasShift);\r\n     */\r\n    toPoint() : Point {\r\n        return Point.createByRGBA(this.r >> networkBiasShift, this.g >> networkBiasShift, this.b >> networkBiasShift, this.a >> networkBiasShift);\r\n    }\r\n\r\n    subtract(r : number, g : number, b : number, a : number) : void {\r\n        this.r -= r | 0;\r\n        this.g -= g | 0;\r\n        this.b -= b | 0;\r\n        this.a -= a | 0;\r\n    }\r\n\r\n    /*\r\n     public subtract(r : number, g : number, b : number, a : number) : void {\r\n     this.r = (-r + this.r) | 0;\r\n     this.g = (-g + this.g) | 0;\r\n     this.b = (-b + this.b) | 0;\r\n     this.a = (-a + this.a) | 0;\r\n\r\n     this.r -= r;\r\n     this.g -= g;\r\n     this.b -= b;\r\n     this.a -= a;\r\n\r\n     this.r -= r | 0;\r\n     this.g -= g | 0;\r\n     this.b -= b | 0;\r\n     this.a -= a | 0;\r\n     }\r\n     */\r\n}\r\n\r\nexport class NeuQuant implements IPaletteQuantizer {\r\n    /*\r\n     four primes near 500 - assume no image has a length so large\r\n     that it is divisible by all four primes\r\n     */\r\n    private static readonly _prime1 : number          = 499;\r\n    private static readonly _prime2 : number          = 491;\r\n    private static readonly _prime3 : number          = 487;\r\n    private static readonly _prime4 : number          = 503;\r\n    private static readonly _minpicturebytes : number = NeuQuant._prime4;\r\n\r\n    // no. of learning cycles\r\n    private static readonly _nCycles : number = 100;\r\n\r\n    // defs for freq and bias\r\n    private static readonly _initialBiasShift : number = 16;\r\n\r\n    // bias for fractions\r\n    private static readonly _initialBias : number = (1 << NeuQuant._initialBiasShift);\r\n    private static readonly _gammaShift : number  = 10;\r\n\r\n    // gamma = 1024\r\n    // TODO: why gamma is never used?\r\n    //private static _gamma : number     = (1 << NeuQuant._gammaShift);\r\n    private static readonly _betaShift : number = 10;\r\n    private static readonly _beta : number      = (NeuQuant._initialBias >> NeuQuant._betaShift);\r\n\r\n    // beta = 1/1024\r\n    private static readonly _betaGamma : number = (NeuQuant._initialBias << (NeuQuant._gammaShift - NeuQuant._betaShift));\r\n\r\n    /*\r\n     * for 256 cols, radius starts\r\n     */\r\n    private static readonly _radiusBiasShift : number = 6;\r\n\r\n    // at 32.0 biased by 6 bits\r\n    private static readonly _radiusBias : number = 1 << NeuQuant._radiusBiasShift;\r\n\r\n    // and decreases by a factor of 1/30 each cycle\r\n    private static readonly _radiusDecrease : number = 30;\r\n\r\n    /* defs for decreasing alpha factor */\r\n\r\n    // alpha starts at 1.0\r\n    private static readonly _alphaBiasShift : number = 10;\r\n\r\n    // biased by 10 bits\r\n    private static readonly _initAlpha : number = (1 << NeuQuant._alphaBiasShift);\r\n\r\n    /* radBias and alphaRadBias used for radpower calculation */\r\n    private static readonly _radBiasShift : number      = 8;\r\n    private static readonly _radBias : number           = 1 << NeuQuant._radBiasShift;\r\n    private static readonly _alphaRadBiasShift : number = NeuQuant._alphaBiasShift + NeuQuant._radBiasShift;\r\n    private static readonly _alphaRadBias : number      = 1 << NeuQuant._alphaRadBiasShift;\r\n\r\n    private _pointArray : Point[];\r\n    private readonly _networkSize : number;\r\n    private _network : Neuron[];\r\n\r\n    /** sampling factor 1..30 */\r\n    private readonly _sampleFactor : number;\r\n    private _radPower : number[];\r\n\r\n    // bias and freq arrays for learning\r\n    private _freq : number[];\r\n\r\n    /* for network lookup - really 256 */\r\n    private _bias : number[];\r\n    private readonly _distance : AbstractDistanceCalculator;\r\n\r\n    constructor(colorDistanceCalculator : AbstractDistanceCalculator, colors : number = 256) {\r\n        this._distance     = colorDistanceCalculator;\r\n        this._pointArray   = [];\r\n        this._sampleFactor = 1;\r\n        this._networkSize  = colors;\r\n\r\n        this._distance.setWhitePoint(255 << networkBiasShift, 255 << networkBiasShift, 255 << networkBiasShift, 255 << networkBiasShift);\r\n    }\r\n\r\n    sample(pointBuffer : PointContainer) : void {\r\n        this._pointArray = this._pointArray.concat(pointBuffer.getPointArray());\r\n    }\r\n\r\n    quantize() : Palette {\r\n        this._init();\r\n        this._learn();\r\n\r\n        return this._buildPalette();\r\n    }\r\n\r\n    private _init() : void {\r\n        this._freq     = [];\r\n        this._bias     = [];\r\n        this._radPower = [];\r\n        this._network  = [];\r\n        for (let i = 0; i < this._networkSize; i++) {\r\n            this._network[ i ] = new Neuron((i << (networkBiasShift + 8)) / this._networkSize | 0);\r\n\r\n            // 1/this._networkSize\r\n            this._freq[ i ] = NeuQuant._initialBias / this._networkSize | 0;\r\n            this._bias[ i ] = 0;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Main Learning Loop\r\n     */\r\n    private _learn() : void {\r\n        let sampleFactor   = this._sampleFactor;\r\n        const pointsNumber = this._pointArray.length;\r\n        if (pointsNumber < NeuQuant._minpicturebytes) sampleFactor = 1;\r\n\r\n        const alphadec       = 30 + (sampleFactor - 1) / 3 | 0,\r\n              pointsToSample = pointsNumber / sampleFactor | 0;\r\n\r\n        let delta  = pointsToSample / NeuQuant._nCycles | 0,\r\n            alpha  = NeuQuant._initAlpha,\r\n            radius = (this._networkSize >> 3) * NeuQuant._radiusBias;\r\n\r\n        let rad = radius >> NeuQuant._radiusBiasShift;\r\n        if (rad <= 1) rad = 0;\r\n\r\n        for (let i = 0; i < rad; i++) {\r\n            this._radPower[ i ] = alpha * (((rad * rad - i * i) * NeuQuant._radBias) / (rad * rad)) >>> 0;\r\n        }\r\n\r\n        let step : number;\r\n        if (pointsNumber < NeuQuant._minpicturebytes) {\r\n            step = 1;\r\n        } else if (pointsNumber % NeuQuant._prime1 != 0) {\r\n            step = NeuQuant._prime1;\r\n        } else if ((pointsNumber % NeuQuant._prime2) != 0) {\r\n            step = NeuQuant._prime2;\r\n        } else if ((pointsNumber % NeuQuant._prime3) != 0) {\r\n            step = NeuQuant._prime3;\r\n        } else {\r\n            step = NeuQuant._prime4;\r\n        }\r\n\r\n        for (let i = 0, pointIndex = 0; i < pointsToSample;) {\r\n            const point       = this._pointArray[ pointIndex ],\r\n                  b           = point.b << networkBiasShift,\r\n                  g           = point.g << networkBiasShift,\r\n                  r           = point.r << networkBiasShift,\r\n                  a           = point.a << networkBiasShift,\r\n                  neuronIndex = this._contest(b, g, r, a);\r\n\r\n            this._alterSingle(alpha, neuronIndex, b, g, r, a);\r\n            if (rad !== 0) this._alterNeighbour(rad, neuronIndex, b, g, r, a);\r\n\r\n            /* alter neighbours */\r\n            pointIndex += step;\r\n            if (pointIndex >= pointsNumber) pointIndex -= pointsNumber;\r\n            i++;\r\n\r\n            if (delta === 0) delta = 1;\r\n\r\n            if (i % delta === 0) {\r\n                alpha -= (alpha / alphadec) | 0;\r\n                radius -= (radius / NeuQuant._radiusDecrease) | 0;\r\n                rad = radius >> NeuQuant._radiusBiasShift;\r\n\r\n                if (rad <= 1) rad = 0;\r\n                for (let j = 0; j < rad; j++) this._radPower[ j ] = alpha * (((rad * rad - j * j) * NeuQuant._radBias) / (rad * rad)) >>> 0;\r\n            }\r\n        }\r\n    }\r\n\r\n    private _buildPalette() : Palette {\r\n        const palette = new Palette();\r\n\r\n        this._network.forEach(neuron => {\r\n            palette.add(neuron.toPoint());\r\n        });\r\n\r\n        palette.sort();\r\n        return palette;\r\n    }\r\n\r\n    /**\r\n     * Move adjacent neurons by precomputed alpha*(1-((i-j)^2/[r]^2)) in radpower[|i-j|]\r\n     */\r\n    private _alterNeighbour(rad : number, i : number, b : number, g : number, r : number, al : number) : void {\r\n        let lo = i - rad;\r\n        if (lo < -1) lo = -1;\r\n\r\n        let hi = i + rad;\r\n        if (hi > this._networkSize) hi = this._networkSize;\r\n\r\n        let j = i + 1,\r\n            k = i - 1,\r\n            m = 1;\r\n\r\n        while (j < hi || k > lo) {\r\n            const a = this._radPower[ m++ ] / NeuQuant._alphaRadBias;\r\n            if (j < hi) {\r\n                const p = this._network[ j++ ];\r\n                p.subtract(\r\n                    a * (p.r - r),\r\n                    a * (p.g - g),\r\n                    a * (p.b - b),\r\n                    a * (p.a - al)\r\n                );\r\n            }\r\n\r\n            if (k > lo) {\r\n                const p = this._network[ k-- ];\r\n                p.subtract(\r\n                    a * (p.r - r),\r\n                    a * (p.g - g),\r\n                    a * (p.b - b),\r\n                    a * (p.a - al)\r\n                );\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Move neuron i towards biased (b,g,r) by factor alpha\r\n     */\r\n    private _alterSingle(alpha : number, i : number, b : number, g : number, r : number, a : number) : void {\r\n        alpha /= NeuQuant._initAlpha;\r\n\r\n        /* alter hit neuron */\r\n        const n = this._network[ i ];\r\n        n.subtract(\r\n            alpha * (n.r - r),\r\n            alpha * (n.g - g),\r\n            alpha * (n.b - b),\r\n            alpha * (n.a - a)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Search for biased BGR values\r\n     * description:\r\n     *    finds closest neuron (min dist) and updates freq\r\n     *    finds best neuron (min dist-bias) and returns position\r\n     *    for frequently chosen neurons, freq[i] is high and bias[i] is negative\r\n     *    bias[i] = _gamma*((1/this._networkSize)-freq[i])\r\n     *\r\n     * Original distance equation:\r\n     *        dist = abs(dR) + abs(dG) + abs(dB)\r\n     */\r\n    private _contest(b : number, g : number, r : number, a : number) : number {\r\n        const multiplier = (255 * 4) << networkBiasShift;\r\n\r\n        let bestd       = ~(1 << 31),\r\n            bestbiasd   = bestd,\r\n            bestpos     = -1,\r\n            bestbiaspos = bestpos;\r\n\r\n        for (let i = 0; i < this._networkSize; i++) {\r\n            const n    = this._network[ i ],\r\n                  dist = this._distance.calculateNormalized(<any>n, <any>{ r, g, b, a }) * multiplier | 0;\r\n\r\n            if (dist < bestd) {\r\n                bestd   = dist;\r\n                bestpos = i;\r\n            }\r\n\r\n            const biasdist = dist - ((this._bias[ i ]) >> (NeuQuant._initialBiasShift - networkBiasShift));\r\n            if (biasdist < bestbiasd) {\r\n                bestbiasd   = biasdist;\r\n                bestbiaspos = i;\r\n            }\r\n            const betafreq = (this._freq[ i ] >> NeuQuant._betaShift);\r\n            this._freq[ i ] -= betafreq;\r\n            this._bias[ i ] += (betafreq << NeuQuant._gammaShift);\r\n        }\r\n        this._freq[ bestpos ] += NeuQuant._beta;\r\n        this._bias[ bestpos ] -= NeuQuant._betaGamma;\r\n        return bestbiaspos;\r\n    }\r\n}\r\n\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/palette/neuquant/neuquant.ts\n **/", "/**\r\n * @preserve\r\n * Copyright 2015-2016 Igor Bezkrovnyi\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * palette.ts - part of Image Quantization Library\r\n */\r\n\r\nimport { Point } from \"./point\"\r\nimport { PointContainer } from \"./pointContainer\"\r\nimport { AbstractDistanceCalculator } from \"../distance/abstractDistanceCalculator\"\r\nimport { rgb2hsl } from \"../conversion/rgb2hsl\"\r\n\r\n// TODO: make paletteArray via pointBuffer, so, export will be available via pointBuffer.exportXXX\r\n\r\nconst hueGroups : number = 10;\r\n\r\nexport function hueGroup(hue : number, segmentsNumber : number) {\r\n    const maxHue = 360,\r\n          seg    = maxHue / segmentsNumber,\r\n          half   = seg / 2;\r\n\r\n    for (let i = 1, mid = seg - half; i < segmentsNumber; i++, mid += seg) {\r\n        if (hue >= mid && hue < mid + seg) return i;\r\n    }\r\n    return 0;\r\n}\r\n\r\nexport class Palette {\r\n    private readonly _pointContainer : PointContainer;\r\n    private readonly _pointArray : Point[]          = [];\r\n    private _i32idx : { [ key : string ] : number } = {};\r\n\r\n    constructor() {\r\n        this._pointContainer = new PointContainer();\r\n        this._pointContainer.setHeight(1);\r\n        this._pointArray = this._pointContainer.getPointArray();\r\n    }\r\n\r\n    add(color : Point) {\r\n        this._pointArray.push(color);\r\n        this._pointContainer.setWidth(this._pointArray.length);\r\n    }\r\n\r\n    has(color : Point) {\r\n        for (let i = this._pointArray.length - 1; i >= 0; i--) {\r\n            if (color.uint32 === this._pointArray[ i ].uint32) return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    // TOTRY: use HUSL - http://boronine.com/husl/ http://www.husl-colors.org/ https://github.com/husl-colors/husl\r\n    getNearestColor(colorDistanceCalculator : AbstractDistanceCalculator, color : Point) : Point {\r\n        return this._pointArray[ this.getNearestIndex(colorDistanceCalculator, color) | 0 ];\r\n    }\r\n\r\n    getPointContainer() : PointContainer {\r\n        return this._pointContainer;\r\n    }\r\n\r\n    // TOTRY: use HUSL - http://boronine.com/husl/\r\n    /*\r\n     public nearestIndexByUint32(i32) {\r\n     var idx : number = this._nearestPointFromCache(\"\" + i32);\r\n     if (idx >= 0) return idx;\r\n\r\n     var min = 1000,\r\n     rgb = [\r\n     (i32 & 0xff),\r\n     (i32 >>> 8) & 0xff,\r\n     (i32 >>> 16) & 0xff,\r\n     (i32 >>> 24) & 0xff\r\n     ],\r\n     len = this._pointArray.length;\r\n\r\n     idx = 0;\r\n     for (var i = 0; i < len; i++) {\r\n     var dist = Utils.distEuclidean(rgb, this._pointArray[i].rgba);\r\n\r\n     if (dist < min) {\r\n     min = dist;\r\n     idx = i;\r\n     }\r\n     }\r\n\r\n     this._i32idx[i32] = idx;\r\n     return idx;\r\n     }\r\n     */\r\n\r\n    private _nearestPointFromCache(key : string) {\r\n        return typeof this._i32idx[ key ] === \"number\" ? this._i32idx[ key ] : -1;\r\n    }\r\n\r\n    private getNearestIndex(colorDistanceCalculator : AbstractDistanceCalculator, point : Point) : number {\r\n        let idx : number = this._nearestPointFromCache(\"\" + point.uint32);\r\n        if (idx >= 0) return idx;\r\n\r\n        let minimalDistance : number = Number.MAX_VALUE;\r\n\r\n        idx = 0;\r\n        for (let i = 0, l = this._pointArray.length; i < l; i++) {\r\n            const p        = this._pointArray[ i ],\r\n                  distance = colorDistanceCalculator.calculateRaw(point.r, point.g, point.b, point.a, p.r, p.g, p.b, p.a);\r\n\r\n            if (distance < minimalDistance) {\r\n                minimalDistance = distance;\r\n                idx             = i;\r\n            }\r\n        }\r\n\r\n        this._i32idx[ point.uint32 ] = idx;\r\n        return idx;\r\n    }\r\n\r\n    /*\r\n     public reduce(histogram : ColorHistogram, colors : number) {\r\n     if (this._pointArray.length > colors) {\r\n     var idxi32 = histogram.getImportanceSortedColorsIDXI32();\r\n\r\n     // quantize histogram to existing palette\r\n     var keep = [], uniqueColors = 0, idx, pruned = false;\r\n\r\n     for (var i = 0, len = idxi32.length; i < len; i++) {\r\n     // palette length reached, unset all remaining colors (sparse palette)\r\n     if (uniqueColors >= colors) {\r\n     this.prunePal(keep);\r\n     pruned = true;\r\n     break;\r\n     } else {\r\n     idx = this.nearestIndexByUint32(idxi32[i]);\r\n     if (keep.indexOf(idx) < 0) {\r\n     keep.push(idx);\r\n     uniqueColors++;\r\n     }\r\n     }\r\n     }\r\n\r\n     if (!pruned) {\r\n     this.prunePal(keep);\r\n     }\r\n     }\r\n     }\r\n\r\n     // TODO: check usage, not tested!\r\n     public prunePal(keep : number[]) {\r\n     var colors = this._pointArray.length;\r\n     for (var colorIndex = colors - 1; colorIndex >= 0; colorIndex--) {\r\n     if (keep.indexOf(colorIndex) < 0) {\r\n\r\n     if(colorIndex + 1 < colors) {\r\n     this._pointArray[ colorIndex ] = this._pointArray [ colors - 1 ];\r\n     }\r\n     --colors;\r\n     //this._pointArray[colorIndex] = null;\r\n     }\r\n     }\r\n     console.log(\"colors pruned: \" + (this._pointArray.length - colors));\r\n     this._pointArray.length = colors;\r\n     this._i32idx = {};\r\n     }\r\n     */\r\n\r\n    // TODO: group very low lum and very high lum colors\r\n    // TODO: pass custom sort order\r\n    // TODO: sort criteria function should be placed to HueStats class\r\n    sort() {\r\n        this._i32idx = {};\r\n        this._pointArray.sort((a : Point, b : Point) => {\r\n            const hslA = rgb2hsl(a.r, a.g, a.b),\r\n                  hslB = rgb2hsl(b.r, b.g, b.b);\r\n\r\n            // sort all grays + whites together\r\n            const hueA = (a.r === a.g && a.g === a.b) ? 0 : 1 + hueGroup(hslA.h, hueGroups),\r\n                  hueB = (b.r === b.g && b.g === b.b) ? 0 : 1 + hueGroup(hslB.h, hueGroups);\r\n            /*\r\n             var hueA = (a.r === a.g && a.g === a.b) ? 0 : 1 + Utils.hueGroup(hslA.h, hueGroups);\r\n             var hueB = (b.r === b.g && b.g === b.b) ? 0 : 1 + Utils.hueGroup(hslB.h, hueGroups);\r\n             */\r\n\r\n            const hueDiff = hueB - hueA;\r\n            if (hueDiff) return -hueDiff;\r\n\r\n            /*\r\n             var lumDiff = Utils.lumGroup(+hslB.l.toFixed(2)) - Utils.lumGroup(+hslA.l.toFixed(2));\r\n             if (lumDiff) return -lumDiff;\r\n             */\r\n            const lA = a.getLuminosity(true),\r\n                  lB = b.getLuminosity(true);\r\n\r\n            if (lB - lA !== 0) return lB - lA;\r\n\r\n            const satDiff = ((hslB.s * 100) | 0) - ((hslA.s * 100) | 0);\r\n            if (satDiff) return -satDiff;\r\n\r\n            return 0;\r\n        });\r\n    }\r\n}\r\n\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/utils/palette.ts\n **/", "/**\r\n * @preserve\r\n * Copyright 2015-2016 Igor Bezkrovnyi\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * pointContainer.ts - part of Image Quantization Library\r\n */\r\nimport { Point } from \"./point\"\r\n\r\n/**\r\n * v8 optimizations done.\r\n * fromXXX methods are static to move out polymorphic code from class instance itself.\r\n */\r\nexport class PointContainer {\r\n    private readonly _pointArray : Point[];\r\n    private _width : number;\r\n    private _height : number;\r\n\r\n    constructor() {\r\n        this._width      = 0;\r\n        this._height     = 0;\r\n        this._pointArray = [];\r\n    }\r\n\r\n    getWidth() : number {\r\n        return this._width;\r\n    }\r\n\r\n    getHeight() : number {\r\n        return this._height;\r\n    }\r\n\r\n    setWidth(width : number) : void {\r\n        this._width = width;\r\n    }\r\n\r\n    setHeight(height : number) : void {\r\n        this._height = height;\r\n    }\r\n\r\n    getPointArray() : Point[] {\r\n        return this._pointArray;\r\n    }\r\n\r\n    clone() : PointContainer {\r\n        const clone   = new PointContainer();\r\n        clone._width  = this._width;\r\n        clone._height = this._height;\r\n\r\n        for (let i = 0, l = this._pointArray.length; i < l; i++) {\r\n            clone._pointArray[ i ] = Point.createByUint32(this._pointArray[ i ].uint32 | 0); // \"| 0\" is added for v8 optimization\r\n        }\r\n\r\n        return clone;\r\n    }\r\n\r\n    toUint32Array() : Uint32Array {\r\n        const l           = this._pointArray.length,\r\n              uint32Array = new Uint32Array(l);\r\n\r\n        for (let i = 0; i < l; i++) {\r\n            uint32Array[ i ] = this._pointArray[ i ].uint32;\r\n        }\r\n\r\n        return uint32Array;\r\n    }\r\n\r\n    toUint8Array() : Uint8Array {\r\n        return new Uint8Array(this.toUint32Array().buffer);\r\n    }\r\n\r\n    static fromHTMLImageElement(img : HTMLImageElement) : PointContainer {\r\n        const width  = img.naturalWidth,\r\n              height = img.naturalHeight;\r\n\r\n        const canvas  = document.createElement(\"canvas\");\r\n        canvas.width  = width;\r\n        canvas.height = height;\r\n\r\n        const ctx = <CanvasRenderingContext2D>canvas.getContext(\"2d\");\r\n        ctx.drawImage(img, 0, 0, width, height, 0, 0, width, height);\r\n\r\n        return PointContainer.fromHTMLCanvasElement(canvas);\r\n    }\r\n\r\n    static fromHTMLCanvasElement(canvas : HTMLCanvasElement) : PointContainer {\r\n        const width  = canvas.width,\r\n              height = canvas.height;\r\n\r\n        const ctx     = <CanvasRenderingContext2D>canvas.getContext(\"2d\"),\r\n              imgData = ctx.getImageData(0, 0, width, height);\r\n\r\n        return PointContainer.fromImageData(imgData);\r\n    }\r\n\r\n    static fromNodeCanvas(canvas : any) : PointContainer {\r\n        return PointContainer.fromHTMLCanvasElement(canvas);\r\n    }\r\n\r\n    static fromImageData(imageData : ImageData) : PointContainer {\r\n        const width  = imageData.width,\r\n              height = imageData.height;\r\n\r\n        return PointContainer.fromCanvasPixelArray(imageData.data, width, height);\r\n        /*\r\n         var buf8;\r\n         if (Utils.typeOf(imageData.data) == \"CanvasPixelArray\")\r\n         buf8 = new Uint8Array(imageData.data);\r\n         else\r\n         buf8 = imageData.data;\r\n\r\n         this.fromUint32Array(new Uint32Array(buf8.buffer), width, height);\r\n         */\r\n    }\r\n\r\n    static fromArray(byteArray : number[], width : number, height : number) : PointContainer {\r\n        const uint8array = new Uint8Array(byteArray);\r\n        return PointContainer.fromUint8Array(uint8array, width, height);\r\n    }\r\n\r\n    static fromCanvasPixelArray(data : any, width : number, height : number) : PointContainer {\r\n        return PointContainer.fromArray(data, width, height);\r\n    }\r\n\r\n    static fromUint8Array(uint8array : Uint8Array, width : number, height : number) : PointContainer {\r\n        return PointContainer.fromUint32Array(new Uint32Array(uint8array.buffer), width, height);\r\n    }\r\n\r\n    static fromUint32Array(uint32array : Uint32Array, width : number, height : number) : PointContainer {\r\n        const container = new PointContainer();\r\n\r\n        container._width  = width;\r\n        container._height = height;\r\n\r\n        for (let i = 0, l = uint32array.length; i < l; i++) {\r\n            container._pointArray[ i ] = Point.createByUint32(uint32array[ i ] | 0); // \"| 0\" is added for v8 optimization\r\n        }\r\n\r\n        return container;\r\n    }\r\n}\r\n\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/utils/pointContainer.ts\n **/", "/**\r\n * @preserve\r\n * Copyright 2015-2016 Igor Bezkrovnyi\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * point.ts - part of Image Quantization Library\r\n */\r\nimport { Y } from \"../constants/bt709\"\r\n\r\n/**\r\n * v8 optimized class\r\n * 1) \"constructor\" should have initialization with worst types\r\n * 2) \"set\" should have |0 / >>> 0\r\n */\r\nexport class Point {\r\n    r : number;\r\n    g : number;\r\n    b : number;\r\n    a : number;\r\n    uint32 : number;\r\n    rgba : number[]; // TODO: better name is quadruplet or quad may be?\r\n    Lab : { L : number; a : number; b : number };\r\n\r\n    static createByQuadruplet(quadruplet : number[]) : Point {\r\n        const point : Point = new Point();\r\n\r\n        point.r = quadruplet[ 0 ] | 0;\r\n        point.g = quadruplet[ 1 ] | 0;\r\n        point.b = quadruplet[ 2 ] | 0;\r\n        point.a = quadruplet[ 3 ] | 0;\r\n        point._loadUINT32();\r\n        point._loadQuadruplet();\r\n        //point._loadLab();\r\n        return point;\r\n    }\r\n\r\n    static createByRGBA(red : number, green : number, blue : number, alpha : number) : Point {\r\n        const point : Point = new Point();\r\n\r\n        point.r = red | 0;\r\n        point.g = green | 0;\r\n        point.b = blue | 0;\r\n        point.a = alpha | 0;\r\n        point._loadUINT32();\r\n        point._loadQuadruplet();\r\n        //point._loadLab();\r\n        return point;\r\n    }\r\n\r\n    static createByUint32(uint32 : number) : Point {\r\n        const point : Point = new Point();\r\n\r\n        point.uint32 = uint32 >>> 0;\r\n        point._loadRGBA();\r\n        point._loadQuadruplet();\r\n        //point._loadLab();\r\n        return point;\r\n    }\r\n\r\n    constructor() {\r\n        this.uint32 = -1 >>> 0;\r\n        this.r      = this.g = this.b = this.a = 0;\r\n        this.rgba = new Array(4);\r\n        /*[ this.r , this.g , this.b , this.a ]*/\r\n        this.rgba[ 0 ] = 0;\r\n        this.rgba[ 1 ] = 0;\r\n        this.rgba[ 2 ] = 0;\r\n        this.rgba[ 3 ] = 0;\r\n        /*\r\n         this.Lab = {\r\n         L : 0.0,\r\n         a : 0.0,\r\n         b : 0.0\r\n         };\r\n         */\r\n    }\r\n\r\n    from(point : Point) {\r\n        this.r         = point.r;\r\n        this.g         = point.g;\r\n        this.b         = point.b;\r\n        this.a         = point.a;\r\n        this.uint32    = point.uint32;\r\n        this.rgba[ 0 ] = point.r;\r\n        this.rgba[ 1 ] = point.g;\r\n        this.rgba[ 2 ] = point.b;\r\n        this.rgba[ 3 ] = point.a;\r\n\r\n        /*\r\n         this.Lab.L = point.Lab.L;\r\n         this.Lab.a = point.Lab.a;\r\n         this.Lab.b = point.Lab.b;\r\n         */\r\n    }\r\n\r\n    /*\r\n     * TODO:\r\n     Luminance from RGB:\r\n\r\n     Luminance (standard for certain colour spaces): (0.2126*R + 0.7152*G + 0.0722*B) [1]\r\n     Luminance (perceived option 1): (0.299*R + 0.587*G + 0.114*B) [2]\r\n     Luminance (perceived option 2, slower to calculate):  sqrt( 0.241*R^2 + 0.691*G^2 + 0.068*B^2 ) ? sqrt( 0.299*R^2 + 0.587*G^2 + 0.114*B^2 ) (thanks to @MatthewHerbst) [http://alienryderflex.com/hsp.html]\r\n     */\r\n    getLuminosity(useAlphaChannel : boolean) : number {\r\n        let r = this.r,\r\n            g = this.g,\r\n            b = this.b;\r\n\r\n        if (useAlphaChannel) {\r\n            r = Math.min(255, 255 - this.a + this.a * r / 255);\r\n            g = Math.min(255, 255 - this.a + this.a * g / 255);\r\n            b = Math.min(255, 255 - this.a + this.a * b / 255);\r\n        }\r\n\r\n        //var luma = this.r * Point._RED_COEFFICIENT + this.g * Point._GREEN_COEFFICIENT + this.b * Point._BLUE_COEFFICIENT;\r\n\r\n        /*\r\n         if(useAlphaChannel) {\r\n         luma = (luma * (255 - this.a)) / 255;\r\n         }\r\n         */\r\n\r\n        return r * Y.RED + g * Y.GREEN + b * Y.BLUE;\r\n    }\r\n\r\n    private _loadUINT32() {\r\n        this.uint32 = (this.a << 24 | this.b << 16 | this.g << 8 | this.r) >>> 0;\r\n    }\r\n\r\n    private _loadRGBA() {\r\n        this.r = this.uint32 & 0xff;\r\n        this.g = (this.uint32 >>> 8) & 0xff;\r\n        this.b = (this.uint32 >>> 16) & 0xff;\r\n        this.a = (this.uint32 >>> 24) & 0xff;\r\n    }\r\n\r\n    private _loadQuadruplet() {\r\n        this.rgba[ 0 ] = this.r;\r\n        this.rgba[ 1 ] = this.g;\r\n        this.rgba[ 2 ] = this.b;\r\n        this.rgba[ 3 ] = this.a;\r\n\r\n        /*\r\n         var xyz = rgb2xyz(this.r, this.g, this.b);\r\n         var lab = xyz2lab(xyz.x, xyz.y, xyz.z);\r\n         this.lab.l = lab.l;\r\n         this.lab.a = lab.a;\r\n         this.lab.b = lab.b;\r\n         */\r\n    }\r\n\r\n    /*\r\n     private _loadLab() : void {\r\n     var Lab = Color.Conversion.rgb2lab(this.r, this.g, this.b);\r\n     this.Lab.L = Lab.L;\r\n     this.Lab.a = Lab.a;\r\n     this.Lab.b = Lab.b;\r\n     }\r\n     */\r\n}\r\n\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/utils/point.ts\n **/", "/*\r\n * NeuQuantFloat Neural-Net Quantization Algorithm\r\n * ------------------------------------------\r\n *\r\n * Copyright (c) 1994 Anthony Dekker\r\n *\r\n * NEUQUANT Neural-Net quantization algorithm by Anthony Dekker, 1994. See\r\n * \"Kohonen neural networks for optimal colour quantization\" in \"Network:\r\n * Computation in Neural Systems\" Vol. 5 (1994) pp 351-367. for a discussion of\r\n * the algorithm.\r\n *\r\n * Any party obtaining a copy of these files from the author, directly or\r\n * indirectly, is granted, free of charge, a full and unrestricted irrevocable,\r\n * world-wide, paid up, royalty-free, nonexclusive right and license to deal in\r\n * this software and documentation files (the \"Software\"), including without\r\n * limitation the rights to use, copy, modify, merge, publish, distribute,\r\n * sublicense, and/or sell copies of the Software, and to permit persons who\r\n * receive copies from any such party to do so, with the only requirement being\r\n * that this copyright notice remain intact.\r\n */\r\n/**\r\n * @preserve TypeScript port:\r\n * Copyright 2015-2016 Igor Bezkrovnyi\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * neuquant.ts - part of Image Quantization Library\r\n */\r\nimport { Palette } from \"../../utils/palette\"\r\nimport { Point } from \"../../utils/point\"\r\nimport { PointContainer } from \"../../utils/pointContainer\"\r\nimport { AbstractDistanceCalculator } from \"../../distance/abstractDistanceCalculator\"\r\nimport { IPaletteQuantizer } from \"../common\"\r\n\r\n// bias for colour values\r\nconst networkBiasShift = 3;\r\n\r\nclass NeuronFloat {\r\n    r : number;\r\n    g : number;\r\n    b : number;\r\n    a : number;\r\n\r\n    constructor(defaultValue : number) {\r\n        this.r = this.g = this.b = this.a = defaultValue;\r\n    }\r\n\r\n    /**\r\n     * There is a fix in original NEUQUANT by Anthony Dekker (http://members.ozemail.com.au/~dekker/NEUQUANT.HTML)\r\n     * @example\r\n     * r = Math.min(255, (neuron.r + (1 << (networkBiasShift - 1))) >> networkBiasShift);\r\n     */\r\n    toPoint() : Point {\r\n        return Point.createByRGBA(this.r >> networkBiasShift, this.g >> networkBiasShift, this.b >> networkBiasShift, this.a >> networkBiasShift);\r\n    }\r\n\r\n    subtract(r : number, g : number, b : number, a : number) : void {\r\n        this.r -= r;\r\n        this.g -= g;\r\n        this.b -= b;\r\n        this.a -= a;\r\n    }\r\n}\r\n\r\nexport class NeuQuantFloat implements IPaletteQuantizer {\r\n    /*\r\n     four primes near 500 - assume no image has a length so large\r\n     that it is divisible by all four primes\r\n     */\r\n    private static readonly _prime1 : number          = 499;\r\n    private static readonly _prime2 : number          = 491;\r\n    private static readonly _prime3 : number          = 487;\r\n    private static readonly _prime4 : number          = 503;\r\n    private static readonly _minpicturebytes : number = NeuQuantFloat._prime4;\r\n\r\n    // no. of learning cycles\r\n    private static readonly _nCycles : number = 100;\r\n\r\n    // defs for freq and bias\r\n    private static readonly _initialBiasShift : number = 16;\r\n\r\n    // bias for fractions\r\n    private static readonly _initialBias : number = (1 << NeuQuantFloat._initialBiasShift);\r\n    private static readonly _gammaShift : number  = 10;\r\n\r\n    // gamma = 1024\r\n    // TODO: why gamma is never used?\r\n    //private static _gamma : number     = (1 << NeuQuantFloat._gammaShift);\r\n    private static readonly _betaShift : number = 10;\r\n    private static readonly _beta : number      = (NeuQuantFloat._initialBias >> NeuQuantFloat._betaShift);\r\n\r\n    // beta = 1/1024\r\n    private static readonly _betaGamma : number = (NeuQuantFloat._initialBias << (NeuQuantFloat._gammaShift - NeuQuantFloat._betaShift));\r\n\r\n    /*\r\n     * for 256 cols, radius starts\r\n     */\r\n    private static readonly _radiusBiasShift : number = 6;\r\n\r\n    // at 32.0 biased by 6 bits\r\n    private static readonly _radiusBias : number = 1 << NeuQuantFloat._radiusBiasShift;\r\n\r\n    // and decreases by a factor of 1/30 each cycle\r\n    private static readonly _radiusDecrease : number = 30;\r\n\r\n    /* defs for decreasing alpha factor */\r\n\r\n    // alpha starts at 1.0\r\n    private static readonly _alphaBiasShift : number = 10;\r\n\r\n    // biased by 10 bits\r\n    private static readonly _initAlpha : number = (1 << NeuQuantFloat._alphaBiasShift);\r\n\r\n    /* radBias and alphaRadBias used for radpower calculation */\r\n    private static readonly _radBiasShift : number      = 8;\r\n    private static readonly _radBias : number           = 1 << NeuQuantFloat._radBiasShift;\r\n    private static readonly _alphaRadBiasShift : number = NeuQuantFloat._alphaBiasShift + NeuQuantFloat._radBiasShift;\r\n    private static readonly _alphaRadBias : number      = 1 << NeuQuantFloat._alphaRadBiasShift;\r\n\r\n    private _pointArray : Point[];\r\n    private readonly _networkSize : number;\r\n    private _network : NeuronFloat[];\r\n\r\n    /** sampling factor 1..30 */\r\n    private readonly _sampleFactor : number;\r\n    private _radPower : number[];\r\n\r\n    // bias and freq arrays for learning\r\n    private _freq : number[];\r\n\r\n    /* for network lookup - really 256 */\r\n    private _bias : number[];\r\n    private readonly _distance : AbstractDistanceCalculator;\r\n\r\n    constructor(colorDistanceCalculator : AbstractDistanceCalculator, colors : number = 256) {\r\n        this._distance     = colorDistanceCalculator;\r\n        this._pointArray   = [];\r\n        this._sampleFactor = 1;\r\n        this._networkSize  = colors;\r\n\r\n        this._distance.setWhitePoint(255 << networkBiasShift, 255 << networkBiasShift, 255 << networkBiasShift, 255 << networkBiasShift);\r\n    }\r\n\r\n    sample(pointBuffer : PointContainer) : void {\r\n        this._pointArray = this._pointArray.concat(pointBuffer.getPointArray());\r\n    }\r\n\r\n    quantize() : Palette {\r\n        this._init();\r\n        this._learn();\r\n\r\n        return this._buildPalette();\r\n    }\r\n\r\n    private _init() : void {\r\n        this._freq     = [];\r\n        this._bias     = [];\r\n        this._radPower = [];\r\n        this._network  = [];\r\n        for (let i = 0; i < this._networkSize; i++) {\r\n            this._network[ i ] = new NeuronFloat((i << (networkBiasShift + 8)) / this._networkSize);\r\n\r\n            // 1/this._networkSize\r\n            this._freq[ i ] = NeuQuantFloat._initialBias / this._networkSize;\r\n            this._bias[ i ] = 0;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Main Learning Loop\r\n     */\r\n    private _learn() : void {\r\n        let sampleFactor = this._sampleFactor;\r\n\r\n        let pointsNumber = this._pointArray.length;\r\n        if (pointsNumber < NeuQuantFloat._minpicturebytes) sampleFactor = 1;\r\n\r\n        const alphadec       = 30 + (sampleFactor - 1) / 3,\r\n              pointsToSample = pointsNumber / sampleFactor;\r\n\r\n        let delta  = pointsToSample / NeuQuantFloat._nCycles | 0,\r\n            alpha  = NeuQuantFloat._initAlpha,\r\n            radius = (this._networkSize >> 3) * NeuQuantFloat._radiusBias;\r\n\r\n        let rad = radius >> NeuQuantFloat._radiusBiasShift;\r\n        if (rad <= 1) rad = 0;\r\n\r\n        for (let i = 0; i < rad; i++) {\r\n            this._radPower[ i ] = alpha * (((rad * rad - i * i) * NeuQuantFloat._radBias) / (rad * rad));\r\n        }\r\n\r\n        let step : number;\r\n        if (pointsNumber < NeuQuantFloat._minpicturebytes) {\r\n            step = 1;\r\n        } else if (pointsNumber % NeuQuantFloat._prime1 != 0) {\r\n            step = NeuQuantFloat._prime1;\r\n        } else if ((pointsNumber % NeuQuantFloat._prime2) != 0) {\r\n            step = NeuQuantFloat._prime2;\r\n        } else if ((pointsNumber % NeuQuantFloat._prime3) != 0) {\r\n            step = NeuQuantFloat._prime3;\r\n        } else {\r\n            step = NeuQuantFloat._prime4;\r\n        }\r\n\r\n        for (let i = 0, pointIndex = 0; i < pointsToSample;) {\r\n            const point       = this._pointArray[ pointIndex ],\r\n                  b           = point.b << networkBiasShift,\r\n                  g           = point.g << networkBiasShift,\r\n                  r           = point.r << networkBiasShift,\r\n                  a           = point.a << networkBiasShift,\r\n                  neuronIndex = this._contest(b, g, r, a);\r\n\r\n            this._alterSingle(alpha, neuronIndex, b, g, r, a);\r\n            if (rad != 0) this._alterNeighbour(rad, neuronIndex, b, g, r, a);\r\n\r\n            /* alter neighbours */\r\n            pointIndex += step;\r\n            if (pointIndex >= pointsNumber) pointIndex -= pointsNumber;\r\n            i++;\r\n\r\n            if (delta == 0) delta = 1;\r\n\r\n            if (i % delta == 0) {\r\n                alpha -= (alpha / alphadec);\r\n                radius -= (radius / NeuQuantFloat._radiusDecrease);\r\n                rad = radius >> NeuQuantFloat._radiusBiasShift;\r\n\r\n                if (rad <= 1) rad = 0;\r\n                for (let j = 0; j < rad; j++) this._radPower[ j ] = alpha * (((rad * rad - j * j) * NeuQuantFloat._radBias) / (rad * rad));\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    private _buildPalette() : Palette {\r\n        const palette = new Palette();\r\n\r\n        this._network.forEach(neuron => {\r\n            palette.add(neuron.toPoint());\r\n        });\r\n\r\n        palette.sort();\r\n        return palette;\r\n    }\r\n\r\n    /**\r\n     * Move adjacent neurons by precomputed alpha*(1-((i-j)^2/[r]^2)) in radpower[|i-j|]\r\n     */\r\n    private _alterNeighbour(rad : number, i : number, b : number, g : number, r : number, al : number) : void {\r\n        let lo = i - rad;\r\n        if (lo < -1) lo = -1;\r\n\r\n        let hi = i + rad;\r\n        if (hi > this._networkSize) hi = this._networkSize;\r\n\r\n        let j = i + 1,\r\n            k = i - 1,\r\n            m = 1;\r\n\r\n        while (j < hi || k > lo) {\r\n            const a = this._radPower[ m++ ] / NeuQuantFloat._alphaRadBias;\r\n            if (j < hi) {\r\n                const p = this._network[ j++ ];\r\n                p.subtract(\r\n                    a * (p.r - r),\r\n                    a * (p.g - g),\r\n                    a * (p.b - b),\r\n                    a * (p.a - al)\r\n                );\r\n            }\r\n\r\n            if (k > lo) {\r\n                const p = this._network[ k-- ];\r\n                p.subtract(\r\n                    a * (p.r - r),\r\n                    a * (p.g - g),\r\n                    a * (p.b - b),\r\n                    a * (p.a - al)\r\n                );\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Move neuron i towards biased (b,g,r) by factor alpha\r\n     */\r\n    private _alterSingle(alpha : number, i : number, b : number, g : number, r : number, a : number) : void {\r\n        alpha /= NeuQuantFloat._initAlpha;\r\n\r\n        /* alter hit neuron */\r\n        const n = this._network[ i ];\r\n        n.subtract(\r\n            alpha * (n.r - r),\r\n            alpha * (n.g - g),\r\n            alpha * (n.b - b),\r\n            alpha * (n.a - a)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Search for biased BGR values\r\n     * description:\r\n     *    finds closest neuron (min dist) and updates freq\r\n     *    finds best neuron (min dist-bias) and returns position\r\n     *    for frequently chosen neurons, freq[i] is high and bias[i] is negative\r\n     *    bias[i] = _gamma*((1/this._networkSize)-freq[i])\r\n     *\r\n     * Original distance equation:\r\n     *        dist = abs(dR) + abs(dG) + abs(dB)\r\n     */\r\n    private _contest(b : number, g : number, r : number, al : number) : number {\r\n        const multiplier = (255 * 4) << networkBiasShift;\r\n\r\n        let bestd       = ~(1 << 31),\r\n            bestbiasd   = bestd,\r\n            bestpos     = -1,\r\n            bestbiaspos = bestpos;\r\n\r\n        for (let i = 0; i < this._networkSize; i++) {\r\n            const n    = this._network[ i ],\r\n                  dist = this._distance.calculateNormalized(<any>n, <any>{ r : r, g : g, b : b, a : al }) * multiplier;\r\n\r\n            if (dist < bestd) {\r\n                bestd   = dist;\r\n                bestpos = i;\r\n            }\r\n\r\n            const biasdist = dist - ((this._bias[ i ]) >> (NeuQuantFloat._initialBiasShift - networkBiasShift));\r\n            if (biasdist < bestbiasd) {\r\n                bestbiasd   = biasdist;\r\n                bestbiaspos = i;\r\n            }\r\n            const betafreq = (this._freq[ i ] >> NeuQuantFloat._betaShift);\r\n            this._freq[ i ] -= betafreq;\r\n            this._bias[ i ] += (betafreq << NeuQuantFloat._gammaShift);\r\n        }\r\n        this._freq[ bestpos ] += NeuQuantFloat._beta;\r\n        this._bias[ bestpos ] -= NeuQuantFloat._betaGamma;\r\n        return bestbiaspos;\r\n    }\r\n}\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/palette/neuquant/neuquantFloat.ts\n **/", "/*\r\n * Copyright (c) 2015, Leon Sorokin\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * RgbQuant.js - an image quantization lib\r\n */\r\n\r\n/**\r\n * @preserve TypeScript port:\r\n * Copyright 2015-2016 Igor Bezkrovnyi\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * rgbquant.ts - part of Image Quantization Library\r\n */\r\n\r\nimport { Palette } from \"../../utils/palette\"\r\nimport { Point } from \"../../utils/point\"\r\nimport { PointContainer } from \"../../utils/pointContainer\"\r\nimport { AbstractDistanceCalculator } from \"../../distance/abstractDistanceCalculator\"\r\nimport { ColorHistogram } from \"./colorHistogram\"\r\nimport { IPaletteQuantizer } from \"../common\"\r\nimport { stableSort } from \"../../utils/arithmetic\"\r\n\r\nclass RemovedColor {\r\n    readonly index : number;\r\n    readonly color : Point;\r\n    readonly distance : number;\r\n\r\n    constructor(index : number, color : Point, distance : number) {\r\n        this.index    = index;\r\n        this.color    = color;\r\n        this.distance = distance;\r\n    }\r\n}\r\n\r\n// TODO: make input/output image and input/output palettes with instances of class Point only!\r\nexport class RGBQuant implements IPaletteQuantizer {\r\n    // desired final palette size\r\n    private readonly _colors : number;\r\n\r\n    // color-distance threshold for initial reduction pass\r\n    private readonly _initialDistance : number;\r\n\r\n    // subsequent passes threshold\r\n    private readonly _distanceIncrement : number;\r\n\r\n    // accumulated histogram\r\n    private readonly _histogram : ColorHistogram;\r\n    private readonly _distance : AbstractDistanceCalculator;\r\n\r\n    constructor(colorDistanceCalculator : AbstractDistanceCalculator, colors : number = 256, method : number = 2) {\r\n        this._distance = colorDistanceCalculator;\r\n        // desired final palette size\r\n        this._colors   = colors;\r\n\r\n        // histogram to accumulate\r\n        this._histogram = new ColorHistogram(method, colors);\r\n\r\n        this._initialDistance   = 0.01;\r\n        this._distanceIncrement = 0.005;\r\n    }\r\n\r\n    // gathers histogram info\r\n    sample(image : PointContainer) : void {\r\n        /*\r\n         var pointArray = image.getPointArray(), max = [0, 0, 0, 0], min = [255, 255, 255, 255];\r\n\r\n         for (var i = 0, l = pointArray.length; i < l; i++) {\r\n         var color = pointArray[i];\r\n         for (var componentIndex = 0; componentIndex < 4; componentIndex++) {\r\n         if (max[componentIndex] < color.rgba[componentIndex]) max[componentIndex] = color.rgba[componentIndex];\r\n         if (min[componentIndex] > color.rgba[componentIndex]) min[componentIndex] = color.rgba[componentIndex];\r\n         }\r\n         }\r\n         var rd = max[0] - min[0], gd = max[1] - min[1], bd = max[2] - min[2], ad = max[3] - min[3];\r\n         this._distance.setWhitePoint(rd, gd, bd, ad);\r\n\r\n         this._initialDistance = (Math.sqrt(rd * rd + gd * gd + bd * bd + ad * ad) / Math.sqrt(255 * 255 + 255 * 255 + 255 * 255)) * 0.01;\r\n         */\r\n\r\n        this._histogram.sample(image);\r\n    }\r\n\r\n    // reduces histogram to palette, remaps & memoizes reduced colors\r\n    quantize() : Palette {\r\n        const idxi32 = this._histogram.getImportanceSortedColorsIDXI32()\r\n        if (idxi32.length === 0) {\r\n            throw new Error(\"No colors in image\")\r\n        }\r\n\r\n        const palette = this._buildPalette(idxi32);\r\n\r\n        palette.sort();\r\n        return palette;\r\n    }\r\n\r\n    // reduces similar colors from an importance-sorted Uint32 rgba array\r\n    private _buildPalette(idxi32 : number[]) : Palette {\r\n        // reduce histogram to create initial palette\r\n        // build full rgb palette\r\n        const palette    = new Palette(),\r\n              colorArray = palette.getPointContainer().getPointArray(),\r\n              usageArray = new Array(idxi32.length);\r\n\r\n        for (let i = 0; i < idxi32.length; i++) {\r\n            colorArray.push(Point.createByUint32(idxi32[ i ]));\r\n            usageArray[ i ] = 1;\r\n        }\r\n\r\n        const len                      = colorArray.length,\r\n              memDist : RemovedColor[] = [];\r\n\r\n        let palLen = len,\r\n            thold  = this._initialDistance;\r\n\r\n        // palette already at or below desired length\r\n        while (palLen > this._colors) {\r\n            memDist.length = 0;\r\n\r\n            // iterate palette\r\n            for (let i = 0; i < len; i++) {\r\n                if (usageArray[ i ] === 0) continue;\r\n                const pxi = colorArray[ i ];\r\n                //if (!pxi) continue;\r\n\r\n                for (let j = i + 1; j < len; j++) {\r\n                    if (usageArray[ j ] === 0) continue;\r\n                    const pxj = colorArray[ j ];\r\n                    //if (!pxj) continue;\r\n\r\n                    const dist = this._distance.calculateNormalized(pxi, pxj);\r\n                    if (dist < thold) {\r\n                        // store index,rgb,dist\r\n                        memDist.push(new RemovedColor(j, pxj, dist));\r\n                        usageArray[ j ] = 0;\r\n                        palLen--;\r\n                    }\r\n                }\r\n            }\r\n            // palette reduction pass\r\n            // console.log(\"palette length: \" + palLen);\r\n\r\n            // if palette is still much larger than target, increment by larger initDist\r\n            thold += (palLen > this._colors * 3) ? this._initialDistance : this._distanceIncrement;\r\n        }\r\n\r\n        // if palette is over-reduced, re-add removed colors with largest distances from last round\r\n        if (palLen < this._colors) {\r\n            // sort descending\r\n            stableSort(memDist, function (a : RemovedColor, b : RemovedColor) {\r\n                return b.distance - a.distance;\r\n            });\r\n\r\n            let k = 0;\r\n            while (palLen < this._colors && k < memDist.length) {\r\n                const removedColor               = memDist[ k ];\r\n                // re-inject rgb into final palette\r\n                usageArray[ removedColor.index ] = 1;\r\n                palLen++;\r\n                k++;\r\n            }\r\n        }\r\n\r\n        let colors = colorArray.length;\r\n        for (let colorIndex = colors - 1; colorIndex >= 0; colorIndex--) {\r\n            if (usageArray[ colorIndex ] === 0) {\r\n                if (colorIndex !== colors - 1) {\r\n                    colorArray[ colorIndex ] = colorArray[ colors - 1 ];\r\n                }\r\n                --colors;\r\n            }\r\n        }\r\n        colorArray.length = colors;\r\n\r\n        return palette;\r\n    }\r\n\r\n}\r\n\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/palette/rgbquant/rgbquant.ts\n **/", "/*\r\n * Copyright (c) 2015, Leon Sorokin\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * ColorHistogram.js - an image quantization lib\r\n */\r\n\r\n/**\r\n * @preserve TypeScript port:\r\n * Copyright 2015-2016 Igor Bezkrovnyi\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * colorHistogram.ts - part of Image Quantization Library\r\n */\r\nimport { HueStatistics } from \"../../utils/hueStatistics\"\r\nimport { PointContainer } from \"../../utils/pointContainer\"\r\nimport { stableSort } from \"../../utils/arithmetic\"\r\n\r\ninterface Box {\r\n    x : number,\r\n    y : number,\r\n    h : number,\r\n    w : number\r\n}\r\n\r\nexport class ColorHistogram {\r\n    private static _boxSize   = [ 64, 64 ];\r\n    private static _boxPixels = 2;\r\n    private static _hueGroups = 10;\r\n\r\n    // 1 = by global population, 2 = subregion population threshold\r\n    private _method : number;\r\n\r\n    // HueStatistics instance\r\n    private _hueStats : HueStatistics;\r\n\r\n    private _histogram : {[color : string] : number};\r\n\r\n    // # of highest-frequency colors to start with for palette reduction\r\n    private _initColors : number;\r\n\r\n    // if > 0, enables hues stats and min-color retention per group\r\n    private _minHueCols : number;\r\n\r\n    constructor(method : number, colors : number) {\r\n        // 1 = by global population, 2 = subregion population threshold\r\n        this._method = method;\r\n\r\n        // if > 0, enables hues stats and min-color retention per group\r\n        this._minHueCols = colors << 2;//opts.minHueCols || 0;\r\n\r\n        // # of highest-frequency colors to start with for palette reduction\r\n        this._initColors = colors << 2;\r\n\r\n        // HueStatistics instance\r\n        this._hueStats = new HueStatistics(ColorHistogram._hueGroups, this._minHueCols);\r\n\r\n        this._histogram = Object.create(null);\r\n    }\r\n\r\n    sample(pointBuffer : PointContainer) : void {\r\n        switch (this._method) {\r\n            case 1:\r\n                this._colorStats1D(pointBuffer);\r\n                break;\r\n            case 2:\r\n                this._colorStats2D(pointBuffer);\r\n                break;\r\n        }\r\n    }\r\n\r\n    getImportanceSortedColorsIDXI32() {\r\n        // TODO: fix typing issue in stableSort func\r\n        const sorted = stableSort(Object.keys(this._histogram), (a, b) => this._histogram[ b ] - this._histogram[ a ]);\r\n        if (sorted.length === 0) {\r\n            return [];\r\n        }\r\n\r\n        let idxi32 : string[];\r\n        switch (this._method) {\r\n            case 1:\r\n                const initialColorsLimit = Math.min(sorted.length, this._initColors),\r\n                      last               = sorted[ initialColorsLimit - 1 ],\r\n                      freq               = this._histogram[ last ];\r\n\r\n                idxi32 = sorted.slice(0, initialColorsLimit);\r\n\r\n                // add any cut off colors with same freq as last\r\n                let pos = initialColorsLimit, len = sorted.length;\r\n                while (pos < len && this._histogram[ sorted[ pos ] ] == freq)\r\n                    idxi32.push(sorted[ pos++ ]);\r\n\r\n                // inject min huegroup colors\r\n                this._hueStats.injectIntoArray(idxi32);\r\n                break;\r\n\r\n            case 2:\r\n                idxi32 = sorted;\r\n                break;\r\n\r\n            default:\r\n                // TODO: rethink errors\r\n                throw new Error(\"Incorrect method\")\r\n        }\r\n\r\n        // int32-ify values\r\n        return (<string[]><any>idxi32).map(function (v : string) {\r\n            return +v;\r\n        });\r\n    }\r\n\r\n    // global top-population\r\n    private _colorStats1D(pointBuffer : PointContainer) {\r\n        const histG      = this._histogram,\r\n              pointArray = pointBuffer.getPointArray(),\r\n              len        = pointArray.length;\r\n\r\n        for (let i = 0; i < len; i++) {\r\n            const col = pointArray[ i ].uint32;\r\n\r\n            // collect hue stats\r\n            this._hueStats.check(col);\r\n\r\n            if (col in histG)\r\n                histG[ col ]++;\r\n            else\r\n                histG[ col ] = 1;\r\n        }\r\n    }\r\n\r\n    // population threshold within subregions\r\n    // FIXME: this can over-reduce (few/no colors same?), need a way to keep\r\n    // important colors that dont ever reach local thresholds (gradients?)\r\n    private _colorStats2D(pointBuffer : PointContainer) {\r\n        const width      = pointBuffer.getWidth(),\r\n              height     = pointBuffer.getHeight(),\r\n              pointArray = pointBuffer.getPointArray();\r\n\r\n        const boxW  = ColorHistogram._boxSize[ 0 ],\r\n              boxH  = ColorHistogram._boxSize[ 1 ],\r\n              area  = boxW * boxH,\r\n              boxes = this._makeBoxes(width, height, boxW, boxH),\r\n              histG = this._histogram;\r\n\r\n        boxes.forEach(box => {\r\n            let effc = Math.round((box.w * box.h) / area) * ColorHistogram._boxPixels;\r\n            if (effc < 2) effc = 2;\r\n\r\n            const histL : { [key : string ] : number} = {};\r\n            this._iterateBox(box, width, (i : number) => {\r\n                const col = pointArray[ i ].uint32;\r\n\r\n                // collect hue stats\r\n                this._hueStats.check(col);\r\n\r\n                if (col in histG)\r\n                    histG[ col ]++;\r\n                else if (col in histL) {\r\n                    if (++histL[ col ] >= effc)\r\n                        histG[ col ] = histL[ col ];\r\n                }\r\n                else\r\n                    histL[ col ] = 1;\r\n            });\r\n        });\r\n\r\n        // inject min huegroup colors\r\n        this._hueStats.injectIntoDictionary(histG);\r\n\r\n    }\r\n\r\n    // iterates @bbox within a parent rect of width @wid; calls @fn, passing index within parent\r\n    private _iterateBox(bbox : Box, wid : number, fn : Function) {\r\n        const b    = bbox,\r\n              i0   = b.y * wid + b.x,\r\n              i1   = (b.y + b.h - 1) * wid + (b.x + b.w - 1),\r\n              incr = wid - b.w + 1;\r\n\r\n        let cnt = 0,\r\n            i   = i0;\r\n\r\n        do {\r\n            fn.call(this, i);\r\n            i += (++cnt % b.w == 0) ? incr : 1;\r\n        } while (i <= i1);\r\n    }\r\n\r\n    /**\r\n     *    partitions a rectangle of width x height into\r\n     *    array of boxes stepX x stepY (or less)\r\n     */\r\n    private _makeBoxes(width : number, height : number, stepX : number, stepY : number) {\r\n        const wrem               = width % stepX,\r\n              hrem               = height % stepY,\r\n              xend               = width - wrem,\r\n              yend               = height - hrem,\r\n              boxesArray : Box[] = [];\r\n\r\n        for (let y = 0; y < height; y += stepY)\r\n            for (let x = 0; x < width; x += stepX)\r\n                boxesArray.push({ x, y, w : (x == xend ? wrem : stepX), h : (y == yend ? hrem : stepY) });\r\n\r\n        return boxesArray;\r\n    }\r\n\r\n}\r\n\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/palette/rgbquant/colorHistogram.ts\n **/", "/**\r\n * @preserve\r\n * Copyright 2015-2016 Igor Bezkrovnyi\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * hueStatistics.ts - part of Image Quantization Library\r\n */\r\nimport { rgb2hsl } from \"../conversion/rgb2hsl\"\r\nimport { hueGroup } from \"./palette\"\r\n\r\nclass HueGroup {\r\n    num : number    = 0;\r\n    cols : number[] = [];\r\n}\r\n\r\nexport class HueStatistics {\r\n    private _numGroups : number;\r\n    private _minCols : number;\r\n    private _stats : HueGroup[];\r\n    private _groupsFull : number;\r\n\r\n    constructor(numGroups : number, minCols : number) {\r\n        this._numGroups = numGroups;\r\n        this._minCols   = minCols;\r\n        this._stats     = [];\r\n\r\n        for (let i = 0; i <= numGroups; i++) {\r\n            this._stats[ i ] = new HueGroup();\r\n        }\r\n\r\n        this._groupsFull = 0;\r\n    }\r\n\r\n    check(i32 : number) {\r\n        if (this._groupsFull == this._numGroups + 1) {\r\n            this.check = function () {\r\n            };\r\n        }\r\n\r\n        const r   = (i32 & 0xff),\r\n              g   = (i32 >>> 8) & 0xff,\r\n              b   = (i32 >>> 16) & 0xff,\r\n              hg  = (r == g && g == b) ? 0 : 1 + hueGroup(rgb2hsl(r, g, b).h, this._numGroups),\r\n              gr  = this._stats[ hg ],\r\n              min = this._minCols;\r\n\r\n        gr.num++;\r\n\r\n        if (gr.num > min)\r\n            return;\r\n        if (gr.num == min)\r\n            this._groupsFull++;\r\n\r\n        if (gr.num <= min)\r\n            this._stats[ hg ].cols.push(i32);\r\n    }\r\n\r\n    injectIntoDictionary(histG : { [key : string ] : number}) {\r\n        for (let i = 0; i <= this._numGroups; i++) {\r\n            if (this._stats[ i ].num <= this._minCols) {\r\n                this._stats[ i ].cols.forEach((col : number) => {\r\n                    if (!histG[ col ])\r\n                        histG[ col ] = 1;\r\n                    else\r\n                        histG[ col ]++;\r\n                });\r\n            }\r\n        }\r\n    }\r\n\r\n    injectIntoArray(histG : string[]) {\r\n        for (let i = 0; i <= this._numGroups; i++) {\r\n            if (this._stats[ i ].num <= this._minCols) {\r\n                this._stats[ i ].cols.forEach((col : any) => {\r\n                    if (histG.indexOf(col) == -1)\r\n                        histG.push(col);\r\n                });\r\n            }\r\n        }\r\n    }\r\n}\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/utils/hueStatistics.ts\n **/", "/**\r\n * @preserve\r\n * Copyright 2015-2016 Igor Bezkrovnyi\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * wuQuant.ts - part of Image Quantization Library\r\n */\r\nimport { Palette } from \"../../utils/palette\"\r\nimport { Point } from \"../../utils/point\"\r\nimport { PointContainer } from \"../../utils/pointContainer\"\r\nimport { AbstractDistanceCalculator } from \"../../distance/abstractDistanceCalculator\"\r\n\r\nfunction createArray1D(dimension1 : number) {\r\n    const a : number[] = [];\r\n    for (let k = 0; k < dimension1; k++) {\r\n        a[ k ] = 0;\r\n    }\r\n    return a;\r\n}\r\n\r\nfunction createArray4D(dimension1 : number, dimension2 : number, dimension3 : number, dimension4 : number) : number[][][][] {\r\n    const a = new Array(dimension1);\r\n    for (let i = 0; i < dimension1; i++) {\r\n        a[ i ] = new Array(dimension2);\r\n        for (let j = 0; j < dimension2; j++) {\r\n            a[ i ][ j ] = new Array(dimension3);\r\n            for (let k = 0; k < dimension3; k++) {\r\n                a[ i ][ j ][ k ] = new Array(dimension4);\r\n                for (let l = 0; l < dimension4; l++) {\r\n                    a[ i ][ j ][ k ][ l ] = 0;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return a;\r\n}\r\n\r\nfunction createArray3D(dimension1 : number, dimension2 : number, dimension3 : number) : number[][][] {\r\n    const a = new Array(dimension1);\r\n    for (let i = 0; i < dimension1; i++) {\r\n        a[ i ] = new Array(dimension2);\r\n        for (let j = 0; j < dimension2; j++) {\r\n            a[ i ][ j ] = new Array(dimension3);\r\n            for (let k = 0; k < dimension3; k++) {\r\n                a[ i ][ j ][ k ] = 0;\r\n            }\r\n        }\r\n    }\r\n    return a;\r\n}\r\n\r\nfunction fillArray3D<T>(a : T[][][], dimension1 : number, dimension2 : number, dimension3 : number, value : T) : void {\r\n    for (let i = 0; i < dimension1; i++) {\r\n        a[ i ] = [];\r\n        for (let j = 0; j < dimension2; j++) {\r\n            a[ i ][ j ] = [];\r\n            for (let k = 0; k < dimension3; k++) {\r\n                a[ i ][ j ][ k ] = value;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfunction fillArray1D<T>(a : T[], dimension1 : number, value : T) : void {\r\n    for (let i = 0; i < dimension1; i++) {\r\n        a[ i ] = value;\r\n    }\r\n}\r\n\r\nexport class WuColorCube {\r\n    redMinimum : number;\r\n    redMaximum : number;\r\n    greenMinimum : number;\r\n    greenMaximum : number;\r\n    blueMinimum : number;\r\n    blueMaximum : number;\r\n    volume : number;\r\n    alphaMinimum : number;\r\n    alphaMaximum : number;\r\n}\r\n\r\nexport class WuQuant {\r\n\r\n    private static readonly alpha = 3;\r\n    private static readonly red   = 2;\r\n    private static readonly green = 1;\r\n    private static readonly blue  = 0;\r\n\r\n    private _reds : number[];\r\n    private _greens : number[];\r\n    private _blues : number[];\r\n    private _alphas : number[];\r\n    private _sums : number[];\r\n\r\n    private _weights : number[][][][];\r\n    private _momentsRed : number[][][][];\r\n    private _momentsGreen : number[][][][];\r\n    private _momentsBlue : number[][][][];\r\n    private _momentsAlpha : number[][][][];\r\n    private _moments : number[][][][];\r\n\r\n    private _table : number[];\r\n    private _pixels : Point[];\r\n\r\n    private _cubes : WuColorCube[];\r\n    private _colors : number;\r\n\r\n    private _significantBitsPerChannel : number;\r\n    private _maxSideIndex : number;\r\n    private _alphaMaxSideIndex : number;\r\n    private _sideSize : number;\r\n    private _alphaSideSize : number;\r\n\r\n    private readonly _distance : AbstractDistanceCalculator;\r\n\r\n    constructor(colorDistanceCalculator : AbstractDistanceCalculator, colors : number = 256, significantBitsPerChannel : number = 5) {\r\n        this._distance = colorDistanceCalculator;\r\n        this._setQuality(significantBitsPerChannel);\r\n        this._initialize(colors);\r\n    }\r\n\r\n    sample(image : PointContainer) : void {\r\n        const pointArray = image.getPointArray();\r\n\r\n        for (let i = 0, l = pointArray.length; i < l; i++) {\r\n            this._addColor(pointArray[ i ]);\r\n        }\r\n\r\n        this._pixels = this._pixels.concat(pointArray);\r\n    }\r\n\r\n    quantize() : Palette {\r\n        this._preparePalette();\r\n\r\n        const palette : Palette = new Palette();\r\n\r\n        // generates palette\r\n        for (let paletteIndex = 0; paletteIndex < this._colors; paletteIndex++) {\r\n            if (this._sums[ paletteIndex ] > 0) {\r\n                const sum = this._sums[ paletteIndex ],\r\n                      r   = this._reds[ paletteIndex ] / sum,\r\n                      g   = this._greens[ paletteIndex ] / sum,\r\n                      b   = this._blues[ paletteIndex ] / sum,\r\n                      a   = this._alphas[ paletteIndex ] / sum;\r\n\r\n                const color = Point.createByRGBA(r | 0, g | 0, b | 0, a | 0);\r\n                palette.add(color);\r\n            }\r\n        }\r\n\r\n        palette.sort();\r\n        return palette;\r\n    }\r\n\r\n    private _preparePalette() : void {\r\n        // preprocess the colors\r\n        this._calculateMoments();\r\n\r\n        let next           = 0,\r\n            volumeVariance = createArray1D(this._colors);\r\n\r\n        // processes the cubes\r\n        for (let cubeIndex = 1; cubeIndex < this._colors; ++cubeIndex) {\r\n            // if cut is possible; make it\r\n            if (this._cut(this._cubes[ next ], this._cubes[ cubeIndex ])) {\r\n                volumeVariance[ next ]      = this._cubes[ next ].volume > 1 ? this._calculateVariance(this._cubes[ next ]) : 0.0;\r\n                volumeVariance[ cubeIndex ] = this._cubes[ cubeIndex ].volume > 1 ? this._calculateVariance(this._cubes[ cubeIndex ]) : 0.0;\r\n            } else {\r\n                // the cut was not possible, revert the index\r\n                volumeVariance[ next ] = 0.0;\r\n                cubeIndex--;\r\n            }\r\n\r\n            next     = 0;\r\n            let temp = volumeVariance[ 0 ];\r\n\r\n            for (let index = 1; index <= cubeIndex; ++index) {\r\n                if (volumeVariance[ index ] > temp) {\r\n                    temp = volumeVariance[ index ];\r\n                    next = index;\r\n                }\r\n            }\r\n\r\n            if (temp <= 0.0) {\r\n                this._colors = cubeIndex + 1;\r\n                break;\r\n            }\r\n        }\r\n\r\n        const lookupRed : number[]   = [],\r\n              lookupGreen : number[] = [],\r\n              lookupBlue : number[]  = [],\r\n              lookupAlpha : number[] = [];\r\n\r\n        // precalculates lookup tables\r\n        for (let k = 0; k < this._colors; ++k) {\r\n\r\n            const weight = WuQuant._volume(this._cubes[ k ], this._weights);\r\n\r\n            if (weight > 0) {\r\n                lookupRed[ k ]   = (WuQuant._volume(this._cubes[ k ], this._momentsRed) / weight) | 0;\r\n                lookupGreen[ k ] = (WuQuant._volume(this._cubes[ k ], this._momentsGreen) / weight) | 0;\r\n                lookupBlue[ k ]  = (WuQuant._volume(this._cubes[ k ], this._momentsBlue) / weight) | 0;\r\n                lookupAlpha[ k ] = (WuQuant._volume(this._cubes[ k ], this._momentsAlpha) / weight) | 0;\r\n            } else {\r\n                lookupRed[ k ]   = 0;\r\n                lookupGreen[ k ] = 0;\r\n                lookupBlue[ k ]  = 0;\r\n                lookupAlpha[ k ] = 0;\r\n            }\r\n        }\r\n\r\n        this._reds   = createArray1D(this._colors + 1);\r\n        this._greens = createArray1D(this._colors + 1);\r\n        this._blues  = createArray1D(this._colors + 1);\r\n        this._alphas = createArray1D(this._colors + 1);\r\n        this._sums   = createArray1D(this._colors + 1);\r\n\r\n        // scans and adds colors\r\n        for (let index = 0, l = this._pixels.length; index < l; index++) {\r\n            const color : Point = this._pixels[ index ];\r\n\r\n            const match = -1;\r\n\r\n            let bestMatch    = match,\r\n                bestDistance = Number.MAX_VALUE;\r\n\r\n            for (let lookup = 0; lookup < this._colors; lookup++) {\r\n                const foundRed   = lookupRed[ lookup ],\r\n                      foundGreen = lookupGreen[ lookup ],\r\n                      foundBlue  = lookupBlue[ lookup ],\r\n                      foundAlpha = lookupAlpha[ lookup ];\r\n\r\n                const distance = this._distance.calculateRaw(foundRed, foundGreen, foundBlue, foundAlpha, color.r, color.g, color.b, color.a);\r\n                //var distance = this._distance.calculateRaw(Utils.Point.createByRGBA(foundRed, foundGreen, foundBlue, foundAlpha), color);\r\n                //deltaRed   = color.r - foundRed,\r\n                //deltaGreen = color.g - foundGreen,\r\n                //deltaBlue  = color.b - foundBlue,\r\n                //deltaAlpha = color.a - foundAlpha,\r\n\r\n                //distance   = deltaRed * deltaRed + deltaGreen * deltaGreen + deltaBlue * deltaBlue + deltaAlpha * deltaAlpha;\r\n\r\n                if (distance < bestDistance) {\r\n                    bestDistance = distance;\r\n                    bestMatch    = lookup;\r\n                }\r\n            }\r\n\r\n            this._reds[ bestMatch ] += color.r;\r\n            this._greens[ bestMatch ] += color.g;\r\n            this._blues[ bestMatch ] += color.b;\r\n            this._alphas[ bestMatch ] += color.a;\r\n            this._sums[ bestMatch ]++;\r\n        }\r\n    }\r\n\r\n    private _addColor(color : Point) : void {\r\n        const bitsToRemove = 8 - this._significantBitsPerChannel,\r\n              indexRed     = (color.r >> bitsToRemove) + 1,\r\n              indexGreen   = (color.g >> bitsToRemove) + 1,\r\n              indexBlue    = (color.b >> bitsToRemove) + 1,\r\n              indexAlpha   = (color.a >> bitsToRemove) + 1;\r\n\r\n        //if(color.a > 10) {\r\n        this._weights[ indexAlpha ][ indexRed ][ indexGreen ][ indexBlue ]++;\r\n        this._momentsRed[ indexAlpha ][ indexRed ][ indexGreen ][ indexBlue ] += color.r;\r\n        this._momentsGreen[ indexAlpha ][ indexRed ][ indexGreen ][ indexBlue ] += color.g;\r\n        this._momentsBlue[ indexAlpha ][ indexRed ][ indexGreen ][ indexBlue ] += color.b;\r\n        this._momentsAlpha[ indexAlpha ][ indexRed ][ indexGreen ][ indexBlue ] += color.a;\r\n        this._moments[ indexAlpha ][ indexRed ][ indexGreen ][ indexBlue ] += this._table[ color.r ] + this._table[ color.g ] + this._table[ color.b ] + this._table[ color.a ];\r\n//\t\t\t}\r\n    }\r\n\r\n    /**\r\n     * Converts the histogram to a series of _moments.\r\n     */\r\n    private _calculateMoments() : void {\r\n        const area : number[]      = [],\r\n              areaRed : number[]   = [],\r\n              areaGreen : number[] = [],\r\n              areaBlue : number[]  = [],\r\n              areaAlpha : number[] = [],\r\n              area2 : number[]     = [];\r\n\r\n        const xarea : number[][][]      = createArray3D(this._sideSize, this._sideSize, this._sideSize),\r\n              xareaRed : number[][][]   = createArray3D(this._sideSize, this._sideSize, this._sideSize),\r\n              xareaGreen : number[][][] = createArray3D(this._sideSize, this._sideSize, this._sideSize),\r\n              xareaBlue : number[][][]  = createArray3D(this._sideSize, this._sideSize, this._sideSize),\r\n              xareaAlpha : number[][][] = createArray3D(this._sideSize, this._sideSize, this._sideSize),\r\n              xarea2 : number[][][]     = createArray3D(this._sideSize, this._sideSize, this._sideSize);\r\n\r\n        for (let alphaIndex = 1; alphaIndex <= this._alphaMaxSideIndex; ++alphaIndex) {\r\n            fillArray3D<number>(xarea, this._sideSize, this._sideSize, this._sideSize, 0);\r\n            fillArray3D<number>(xareaRed, this._sideSize, this._sideSize, this._sideSize, 0);\r\n            fillArray3D<number>(xareaGreen, this._sideSize, this._sideSize, this._sideSize, 0);\r\n            fillArray3D<number>(xareaBlue, this._sideSize, this._sideSize, this._sideSize, 0);\r\n            fillArray3D<number>(xareaAlpha, this._sideSize, this._sideSize, this._sideSize, 0);\r\n            fillArray3D<number>(xarea2, this._sideSize, this._sideSize, this._sideSize, 0);\r\n\r\n            for (let redIndex = 1; redIndex <= this._maxSideIndex; ++redIndex) {\r\n                fillArray1D<number>(area, this._sideSize, 0);\r\n                fillArray1D<number>(areaRed, this._sideSize, 0);\r\n                fillArray1D<number>(areaGreen, this._sideSize, 0);\r\n                fillArray1D<number>(areaBlue, this._sideSize, 0);\r\n                fillArray1D<number>(areaAlpha, this._sideSize, 0);\r\n                fillArray1D<number>(area2, this._sideSize, 0);\r\n\r\n                for (let greenIndex = 1; greenIndex <= this._maxSideIndex; ++greenIndex) {\r\n                    let line      = 0,\r\n                        lineRed   = 0,\r\n                        lineGreen = 0,\r\n                        lineBlue  = 0,\r\n                        lineAlpha = 0,\r\n                        line2     = 0.0;\r\n\r\n                    for (let blueIndex = 1; blueIndex <= this._maxSideIndex; ++blueIndex) {\r\n                        line += this._weights[ alphaIndex ][ redIndex ][ greenIndex ][ blueIndex ];\r\n                        lineRed += this._momentsRed[ alphaIndex ][ redIndex ][ greenIndex ][ blueIndex ];\r\n                        lineGreen += this._momentsGreen[ alphaIndex ][ redIndex ][ greenIndex ][ blueIndex ];\r\n                        lineBlue += this._momentsBlue[ alphaIndex ][ redIndex ][ greenIndex ][ blueIndex ];\r\n                        lineAlpha += this._momentsAlpha[ alphaIndex ][ redIndex ][ greenIndex ][ blueIndex ];\r\n                        line2 += this._moments[ alphaIndex ][ redIndex ][ greenIndex ][ blueIndex ];\r\n\r\n                        area[ blueIndex ] += line;\r\n                        areaRed[ blueIndex ] += lineRed;\r\n                        areaGreen[ blueIndex ] += lineGreen;\r\n                        areaBlue[ blueIndex ] += lineBlue;\r\n                        areaAlpha[ blueIndex ] += lineAlpha;\r\n                        area2[ blueIndex ] += line2;\r\n\r\n                        xarea[ redIndex ][ greenIndex ][ blueIndex ]      = xarea[ redIndex - 1 ][ greenIndex ][ blueIndex ] + area[ blueIndex ];\r\n                        xareaRed[ redIndex ][ greenIndex ][ blueIndex ]   = xareaRed[ redIndex - 1 ][ greenIndex ][ blueIndex ] + areaRed[ blueIndex ];\r\n                        xareaGreen[ redIndex ][ greenIndex ][ blueIndex ] = xareaGreen[ redIndex - 1 ][ greenIndex ][ blueIndex ] + areaGreen[ blueIndex ];\r\n                        xareaBlue[ redIndex ][ greenIndex ][ blueIndex ]  = xareaBlue[ redIndex - 1 ][ greenIndex ][ blueIndex ] + areaBlue[ blueIndex ];\r\n                        xareaAlpha[ redIndex ][ greenIndex ][ blueIndex ] = xareaAlpha[ redIndex - 1 ][ greenIndex ][ blueIndex ] + areaAlpha[ blueIndex ];\r\n                        xarea2[ redIndex ][ greenIndex ][ blueIndex ]     = xarea2[ redIndex - 1 ][ greenIndex ][ blueIndex ] + area2[ blueIndex ];\r\n\r\n                        this._weights[ alphaIndex ][ redIndex ][ greenIndex ][ blueIndex ]      = this._weights[ alphaIndex - 1 ][ redIndex ][ greenIndex ][ blueIndex ] + xarea[ redIndex ][ greenIndex ][ blueIndex ];\r\n                        this._momentsRed[ alphaIndex ][ redIndex ][ greenIndex ][ blueIndex ]   = this._momentsRed[ alphaIndex - 1 ][ redIndex ][ greenIndex ][ blueIndex ] + xareaRed[ redIndex ][ greenIndex ][ blueIndex ];\r\n                        this._momentsGreen[ alphaIndex ][ redIndex ][ greenIndex ][ blueIndex ] = this._momentsGreen[ alphaIndex - 1 ][ redIndex ][ greenIndex ][ blueIndex ] + xareaGreen[ redIndex ][ greenIndex ][ blueIndex ];\r\n                        this._momentsBlue[ alphaIndex ][ redIndex ][ greenIndex ][ blueIndex ]  = this._momentsBlue[ alphaIndex - 1 ][ redIndex ][ greenIndex ][ blueIndex ] + xareaBlue[ redIndex ][ greenIndex ][ blueIndex ];\r\n                        this._momentsAlpha[ alphaIndex ][ redIndex ][ greenIndex ][ blueIndex ] = this._momentsAlpha[ alphaIndex - 1 ][ redIndex ][ greenIndex ][ blueIndex ] + xareaAlpha[ redIndex ][ greenIndex ][ blueIndex ];\r\n                        this._moments[ alphaIndex ][ redIndex ][ greenIndex ][ blueIndex ]      = this._moments[ alphaIndex - 1 ][ redIndex ][ greenIndex ][ blueIndex ] + xarea2[ redIndex ][ greenIndex ][ blueIndex ];\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Computes the volume of the cube in a specific moment.\r\n     */\r\n    private static _volumeFloat(cube : WuColorCube, moment : number[][][][]) : number {\r\n        return (moment[ cube.alphaMaximum ][ cube.redMaximum ][ cube.greenMaximum ][ cube.blueMaximum ] -\r\n            moment[ cube.alphaMaximum ][ cube.redMaximum ][ cube.greenMinimum ][ cube.blueMaximum ] -\r\n            moment[ cube.alphaMaximum ][ cube.redMinimum ][ cube.greenMaximum ][ cube.blueMaximum ] +\r\n            moment[ cube.alphaMaximum ][ cube.redMinimum ][ cube.greenMinimum ][ cube.blueMaximum ] -\r\n            moment[ cube.alphaMinimum ][ cube.redMaximum ][ cube.greenMaximum ][ cube.blueMaximum ] +\r\n            moment[ cube.alphaMinimum ][ cube.redMaximum ][ cube.greenMinimum ][ cube.blueMaximum ] +\r\n            moment[ cube.alphaMinimum ][ cube.redMinimum ][ cube.greenMaximum ][ cube.blueMaximum ] -\r\n            moment[ cube.alphaMinimum ][ cube.redMinimum ][ cube.greenMinimum ][ cube.blueMaximum ]) -\r\n\r\n            (moment[ cube.alphaMaximum ][ cube.redMaximum ][ cube.greenMaximum ][ cube.blueMinimum ] -\r\n            moment[ cube.alphaMinimum ][ cube.redMaximum ][ cube.greenMaximum ][ cube.blueMinimum ] -\r\n            moment[ cube.alphaMaximum ][ cube.redMaximum ][ cube.greenMinimum ][ cube.blueMinimum ] +\r\n            moment[ cube.alphaMinimum ][ cube.redMaximum ][ cube.greenMinimum ][ cube.blueMinimum ] -\r\n            moment[ cube.alphaMaximum ][ cube.redMinimum ][ cube.greenMaximum ][ cube.blueMinimum ] +\r\n            moment[ cube.alphaMinimum ][ cube.redMinimum ][ cube.greenMaximum ][ cube.blueMinimum ] +\r\n            moment[ cube.alphaMaximum ][ cube.redMinimum ][ cube.greenMinimum ][ cube.blueMinimum ] -\r\n            moment[ cube.alphaMinimum ][ cube.redMinimum ][ cube.greenMinimum ][ cube.blueMinimum ]);\r\n    }\r\n\r\n    /**\r\n     * Computes the volume of the cube in a specific moment.\r\n     */\r\n    private static _volume(cube : WuColorCube, moment : number[][][][]) : number {\r\n        return WuQuant._volumeFloat(cube, moment) | 0;\r\n    }\r\n\r\n    /**\r\n     * Splits the cube in given position][and color direction.\r\n     */\r\n    private static _top(cube : WuColorCube, direction : number, position : number, moment : number[][][][]) : number {\r\n        let result : number;\r\n        switch (direction) {\r\n            case WuQuant.alpha:\r\n                result = (moment[ position ][ cube.redMaximum ][ cube.greenMaximum ][ cube.blueMaximum ] -\r\n                    moment[ position ][ cube.redMaximum ][ cube.greenMinimum ][ cube.blueMaximum ] -\r\n                    moment[ position ][ cube.redMinimum ][ cube.greenMaximum ][ cube.blueMaximum ] +\r\n                    moment[ position ][ cube.redMinimum ][ cube.greenMinimum ][ cube.blueMaximum ]) -\r\n                    (moment[ position ][ cube.redMaximum ][ cube.greenMaximum ][ cube.blueMinimum ] -\r\n                    moment[ position ][ cube.redMaximum ][ cube.greenMinimum ][ cube.blueMinimum ] -\r\n                    moment[ position ][ cube.redMinimum ][ cube.greenMaximum ][ cube.blueMinimum ] +\r\n                    moment[ position ][ cube.redMinimum ][ cube.greenMinimum ][ cube.blueMinimum ]);\r\n                break;\r\n\r\n            case WuQuant.red:\r\n                result = (moment[ cube.alphaMaximum ][ position ][ cube.greenMaximum ][ cube.blueMaximum ] -\r\n                    moment[ cube.alphaMaximum ][ position ][ cube.greenMinimum ][ cube.blueMaximum ] -\r\n                    moment[ cube.alphaMinimum ][ position ][ cube.greenMaximum ][ cube.blueMaximum ] +\r\n                    moment[ cube.alphaMinimum ][ position ][ cube.greenMinimum ][ cube.blueMaximum ]) -\r\n                    (moment[ cube.alphaMaximum ][ position ][ cube.greenMaximum ][ cube.blueMinimum ] -\r\n                    moment[ cube.alphaMaximum ][ position ][ cube.greenMinimum ][ cube.blueMinimum ] -\r\n                    moment[ cube.alphaMinimum ][ position ][ cube.greenMaximum ][ cube.blueMinimum ] +\r\n                    moment[ cube.alphaMinimum ][ position ][ cube.greenMinimum ][ cube.blueMinimum ]);\r\n                break;\r\n\r\n            case WuQuant.green:\r\n                result = (moment[ cube.alphaMaximum ][ cube.redMaximum ][ position ][ cube.blueMaximum ] -\r\n                    moment[ cube.alphaMaximum ][ cube.redMinimum ][ position ][ cube.blueMaximum ] -\r\n                    moment[ cube.alphaMinimum ][ cube.redMaximum ][ position ][ cube.blueMaximum ] +\r\n                    moment[ cube.alphaMinimum ][ cube.redMinimum ][ position ][ cube.blueMaximum ]) -\r\n                    (moment[ cube.alphaMaximum ][ cube.redMaximum ][ position ][ cube.blueMinimum ] -\r\n                    moment[ cube.alphaMaximum ][ cube.redMinimum ][ position ][ cube.blueMinimum ] -\r\n                    moment[ cube.alphaMinimum ][ cube.redMaximum ][ position ][ cube.blueMinimum ] +\r\n                    moment[ cube.alphaMinimum ][ cube.redMinimum ][ position ][ cube.blueMinimum ]);\r\n                break;\r\n\r\n            case WuQuant.blue:\r\n                result = (moment[ cube.alphaMaximum ][ cube.redMaximum ][ cube.greenMaximum ][ position ] -\r\n                    moment[ cube.alphaMaximum ][ cube.redMaximum ][ cube.greenMinimum ][ position ] -\r\n                    moment[ cube.alphaMaximum ][ cube.redMinimum ][ cube.greenMaximum ][ position ] +\r\n                    moment[ cube.alphaMaximum ][ cube.redMinimum ][ cube.greenMinimum ][ position ]) -\r\n                    (moment[ cube.alphaMinimum ][ cube.redMaximum ][ cube.greenMaximum ][ position ] -\r\n                    moment[ cube.alphaMinimum ][ cube.redMaximum ][ cube.greenMinimum ][ position ] -\r\n                    moment[ cube.alphaMinimum ][ cube.redMinimum ][ cube.greenMaximum ][ position ] +\r\n                    moment[ cube.alphaMinimum ][ cube.redMinimum ][ cube.greenMinimum ][ position ]);\r\n                break;\r\n            default:\r\n                throw new Error(\"impossible\")\r\n        }\r\n\r\n        return result | 0;\r\n    }\r\n\r\n    /**\r\n     * Splits the cube in a given color direction at its minimum.\r\n     */\r\n    private static _bottom(cube : WuColorCube, direction : number, moment : number[][][][]) : number {\r\n        switch (direction) {\r\n            case WuQuant.alpha:\r\n                return (-moment[ cube.alphaMinimum ][ cube.redMaximum ][ cube.greenMaximum ][ cube.blueMaximum ] +\r\n                    moment[ cube.alphaMinimum ][ cube.redMaximum ][ cube.greenMinimum ][ cube.blueMaximum ] +\r\n                    moment[ cube.alphaMinimum ][ cube.redMinimum ][ cube.greenMaximum ][ cube.blueMaximum ] -\r\n                    moment[ cube.alphaMinimum ][ cube.redMinimum ][ cube.greenMinimum ][ cube.blueMaximum ]) -\r\n                    (-moment[ cube.alphaMinimum ][ cube.redMaximum ][ cube.greenMaximum ][ cube.blueMinimum ] +\r\n                    moment[ cube.alphaMinimum ][ cube.redMaximum ][ cube.greenMinimum ][ cube.blueMinimum ] +\r\n                    moment[ cube.alphaMinimum ][ cube.redMinimum ][ cube.greenMaximum ][ cube.blueMinimum ] -\r\n                    moment[ cube.alphaMinimum ][ cube.redMinimum ][ cube.greenMinimum ][ cube.blueMinimum ]);\r\n\r\n            case WuQuant.red:\r\n                return (-moment[ cube.alphaMaximum ][ cube.redMinimum ][ cube.greenMaximum ][ cube.blueMaximum ] +\r\n                    moment[ cube.alphaMaximum ][ cube.redMinimum ][ cube.greenMinimum ][ cube.blueMaximum ] +\r\n                    moment[ cube.alphaMinimum ][ cube.redMinimum ][ cube.greenMaximum ][ cube.blueMaximum ] -\r\n                    moment[ cube.alphaMinimum ][ cube.redMinimum ][ cube.greenMinimum ][ cube.blueMaximum ]) -\r\n                    (-moment[ cube.alphaMaximum ][ cube.redMinimum ][ cube.greenMaximum ][ cube.blueMinimum ] +\r\n                    moment[ cube.alphaMaximum ][ cube.redMinimum ][ cube.greenMinimum ][ cube.blueMinimum ] +\r\n                    moment[ cube.alphaMinimum ][ cube.redMinimum ][ cube.greenMaximum ][ cube.blueMinimum ] -\r\n                    moment[ cube.alphaMinimum ][ cube.redMinimum ][ cube.greenMinimum ][ cube.blueMinimum ]);\r\n\r\n            case WuQuant.green:\r\n                return (-moment[ cube.alphaMaximum ][ cube.redMaximum ][ cube.greenMinimum ][ cube.blueMaximum ] +\r\n                    moment[ cube.alphaMaximum ][ cube.redMinimum ][ cube.greenMinimum ][ cube.blueMaximum ] +\r\n                    moment[ cube.alphaMinimum ][ cube.redMaximum ][ cube.greenMinimum ][ cube.blueMaximum ] -\r\n                    moment[ cube.alphaMinimum ][ cube.redMinimum ][ cube.greenMinimum ][ cube.blueMaximum ]) -\r\n                    (-moment[ cube.alphaMaximum ][ cube.redMaximum ][ cube.greenMinimum ][ cube.blueMinimum ] +\r\n                    moment[ cube.alphaMaximum ][ cube.redMinimum ][ cube.greenMinimum ][ cube.blueMinimum ] +\r\n                    moment[ cube.alphaMinimum ][ cube.redMaximum ][ cube.greenMinimum ][ cube.blueMinimum ] -\r\n                    moment[ cube.alphaMinimum ][ cube.redMinimum ][ cube.greenMinimum ][ cube.blueMinimum ]);\r\n\r\n            case WuQuant.blue:\r\n                return (-moment[ cube.alphaMaximum ][ cube.redMaximum ][ cube.greenMaximum ][ cube.blueMinimum ] +\r\n                    moment[ cube.alphaMaximum ][ cube.redMaximum ][ cube.greenMinimum ][ cube.blueMinimum ] +\r\n                    moment[ cube.alphaMaximum ][ cube.redMinimum ][ cube.greenMaximum ][ cube.blueMinimum ] -\r\n                    moment[ cube.alphaMaximum ][ cube.redMinimum ][ cube.greenMinimum ][ cube.blueMinimum ]) -\r\n                    (-moment[ cube.alphaMinimum ][ cube.redMaximum ][ cube.greenMaximum ][ cube.blueMinimum ] +\r\n                    moment[ cube.alphaMinimum ][ cube.redMaximum ][ cube.greenMinimum ][ cube.blueMinimum ] +\r\n                    moment[ cube.alphaMinimum ][ cube.redMinimum ][ cube.greenMaximum ][ cube.blueMinimum ] -\r\n                    moment[ cube.alphaMinimum ][ cube.redMinimum ][ cube.greenMinimum ][ cube.blueMinimum ]);\r\n\r\n            default:\r\n                // TODO: why here is return 0, and in this._top there is no default at all (now it is throw error)?\r\n                return 0;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculates statistical variance for a given cube.\r\n     */\r\n    private  _calculateVariance(cube : WuColorCube) : number {\r\n        const volumeRed    = WuQuant._volume(cube, this._momentsRed),\r\n              volumeGreen  = WuQuant._volume(cube, this._momentsGreen),\r\n              volumeBlue   = WuQuant._volume(cube, this._momentsBlue),\r\n              volumeAlpha  = WuQuant._volume(cube, this._momentsAlpha),\r\n              volumeMoment = WuQuant._volumeFloat(cube, this._moments),\r\n              volumeWeight = WuQuant._volume(cube, this._weights),\r\n              distance     = volumeRed * volumeRed + volumeGreen * volumeGreen + volumeBlue * volumeBlue + volumeAlpha * volumeAlpha;\r\n\r\n        return volumeMoment - (distance / volumeWeight);\r\n    }\r\n\r\n    /**\r\n     * Finds the optimal (maximal) position for the cut.\r\n     */\r\n    private _maximize(cube : WuColorCube, direction : number, first : number, last : number, wholeRed : number, wholeGreen : number, wholeBlue : number, wholeAlpha : number, wholeWeight : number) : {max : number; position : number} {\r\n        const bottomRed    = WuQuant._bottom(cube, direction, this._momentsRed) | 0,\r\n              bottomGreen  = WuQuant._bottom(cube, direction, this._momentsGreen) | 0,\r\n              bottomBlue   = WuQuant._bottom(cube, direction, this._momentsBlue) | 0,\r\n              bottomAlpha  = WuQuant._bottom(cube, direction, this._momentsAlpha) | 0,\r\n              bottomWeight = WuQuant._bottom(cube, direction, this._weights) | 0;\r\n\r\n        let result      = 0.0,\r\n            cutPosition = -1;\r\n\r\n        for (let position = first; position < last; ++position) {\r\n            // determines the cube cut at a certain position\r\n            let halfRed    = bottomRed + WuQuant._top(cube, direction, position, this._momentsRed),\r\n                halfGreen  = bottomGreen + WuQuant._top(cube, direction, position, this._momentsGreen),\r\n                halfBlue   = bottomBlue + WuQuant._top(cube, direction, position, this._momentsBlue),\r\n                halfAlpha  = bottomAlpha + WuQuant._top(cube, direction, position, this._momentsAlpha),\r\n                halfWeight = bottomWeight + WuQuant._top(cube, direction, position, this._weights);\r\n\r\n            // the cube cannot be cut at bottom (this would lead to empty cube)\r\n            if (halfWeight != 0) {\r\n                let halfDistance = halfRed * halfRed + halfGreen * halfGreen + halfBlue * halfBlue + halfAlpha * halfAlpha,\r\n                    temp         = halfDistance / halfWeight;\r\n\r\n                halfRed    = wholeRed - halfRed;\r\n                halfGreen  = wholeGreen - halfGreen;\r\n                halfBlue   = wholeBlue - halfBlue;\r\n                halfAlpha  = wholeAlpha - halfAlpha;\r\n                halfWeight = wholeWeight - halfWeight;\r\n\r\n                if (halfWeight != 0) {\r\n                    halfDistance = halfRed * halfRed + halfGreen * halfGreen + halfBlue * halfBlue + halfAlpha * halfAlpha;\r\n                    temp += halfDistance / halfWeight;\r\n\r\n                    if (temp > result) {\r\n                        result      = temp;\r\n                        cutPosition = position;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return { max : result, position : cutPosition };\r\n    }\r\n\r\n    // Cuts a cube with another one.\r\n    private _cut(first : WuColorCube, second : WuColorCube) : boolean {\r\n        let direction : number;\r\n\r\n        const wholeRed    = WuQuant._volume(first, this._momentsRed),\r\n              wholeGreen  = WuQuant._volume(first, this._momentsGreen),\r\n              wholeBlue   = WuQuant._volume(first, this._momentsBlue),\r\n              wholeAlpha  = WuQuant._volume(first, this._momentsAlpha),\r\n              wholeWeight = WuQuant._volume(first, this._weights),\r\n\r\n              red         = this._maximize(first, WuQuant.red, first.redMinimum + 1, first.redMaximum, wholeRed, wholeGreen, wholeBlue, wholeAlpha, wholeWeight),\r\n              green       = this._maximize(first, WuQuant.green, first.greenMinimum + 1, first.greenMaximum, wholeRed, wholeGreen, wholeBlue, wholeAlpha, wholeWeight),\r\n              blue        = this._maximize(first, WuQuant.blue, first.blueMinimum + 1, first.blueMaximum, wholeRed, wholeGreen, wholeBlue, wholeAlpha, wholeWeight),\r\n              alpha       = this._maximize(first, WuQuant.alpha, first.alphaMinimum + 1, first.alphaMaximum, wholeRed, wholeGreen, wholeBlue, wholeAlpha, wholeWeight);\r\n\r\n        if (alpha.max >= red.max && alpha.max >= green.max && alpha.max >= blue.max) {\r\n            direction = WuQuant.alpha;\r\n\r\n            // cannot split empty cube\r\n            if (alpha.position < 0) return false;\r\n        } else {\r\n            if (red.max >= alpha.max && red.max >= green.max && red.max >= blue.max) {\r\n                direction = WuQuant.red;\r\n            } else if (green.max >= alpha.max && green.max >= red.max && green.max >= blue.max) {\r\n                direction = WuQuant.green;\r\n            } else {\r\n                direction = WuQuant.blue;\r\n            }\r\n        }\r\n\r\n        second.redMaximum   = first.redMaximum;\r\n        second.greenMaximum = first.greenMaximum;\r\n        second.blueMaximum  = first.blueMaximum;\r\n        second.alphaMaximum = first.alphaMaximum;\r\n\r\n        // cuts in a certain direction\r\n        switch (direction) {\r\n            case WuQuant.red:\r\n                second.redMinimum = first.redMaximum = red.position;\r\n                second.greenMinimum = first.greenMinimum;\r\n                second.blueMinimum  = first.blueMinimum;\r\n                second.alphaMinimum = first.alphaMinimum;\r\n                break;\r\n\r\n            case WuQuant.green:\r\n                second.greenMinimum = first.greenMaximum = green.position;\r\n                second.redMinimum   = first.redMinimum;\r\n                second.blueMinimum  = first.blueMinimum;\r\n                second.alphaMinimum = first.alphaMinimum;\r\n                break;\r\n\r\n            case WuQuant.blue:\r\n                second.blueMinimum = first.blueMaximum = blue.position;\r\n                second.redMinimum   = first.redMinimum;\r\n                second.greenMinimum = first.greenMinimum;\r\n                second.alphaMinimum = first.alphaMinimum;\r\n                break;\r\n\r\n            case WuQuant.alpha:\r\n                second.alphaMinimum = first.alphaMaximum = alpha.position;\r\n                second.blueMinimum  = first.blueMinimum;\r\n                second.redMinimum   = first.redMinimum;\r\n                second.greenMinimum = first.greenMinimum;\r\n                break;\r\n        }\r\n\r\n        // determines the volumes after cut\r\n        first.volume  = (first.redMaximum - first.redMinimum) * (first.greenMaximum - first.greenMinimum) * (first.blueMaximum - first.blueMinimum) * (first.alphaMaximum - first.alphaMinimum);\r\n        second.volume = (second.redMaximum - second.redMinimum) * (second.greenMaximum - second.greenMinimum) * (second.blueMaximum - second.blueMinimum) * (second.alphaMaximum - second.alphaMinimum);\r\n\r\n        // the cut was successful\r\n        return true;\r\n    }\r\n\r\n    private _initialize(colors : number) : void {\r\n        this._colors = colors;\r\n\r\n        // creates all the _cubes\r\n        this._cubes = [];\r\n\r\n        // initializes all the _cubes\r\n        for (let cubeIndex = 0; cubeIndex < colors; cubeIndex++) {\r\n            this._cubes[ cubeIndex ] = new WuColorCube();\r\n        }\r\n\r\n        // resets the reference minimums\r\n        this._cubes[ 0 ].redMinimum   = 0;\r\n        this._cubes[ 0 ].greenMinimum = 0;\r\n        this._cubes[ 0 ].blueMinimum  = 0;\r\n        this._cubes[ 0 ].alphaMinimum = 0;\r\n\r\n        // resets the reference maximums\r\n        this._cubes[ 0 ].redMaximum   = this._maxSideIndex;\r\n        this._cubes[ 0 ].greenMaximum = this._maxSideIndex;\r\n        this._cubes[ 0 ].blueMaximum  = this._maxSideIndex;\r\n        this._cubes[ 0 ].alphaMaximum = this._alphaMaxSideIndex;\r\n\r\n        this._weights      = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize);\r\n        this._momentsRed   = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize);\r\n        this._momentsGreen = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize);\r\n        this._momentsBlue  = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize);\r\n        this._momentsAlpha = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize);\r\n        this._moments      = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize);\r\n\r\n        this._table = [];\r\n        for (let tableIndex = 0; tableIndex < 256; ++tableIndex) {\r\n            this._table[ tableIndex ] = tableIndex * tableIndex;\r\n        }\r\n\r\n        this._pixels = [];\r\n    }\r\n\r\n    private _setQuality(significantBitsPerChannel : number = 5) : void {\r\n        this._significantBitsPerChannel = significantBitsPerChannel;\r\n        this._maxSideIndex              = 1 << this._significantBitsPerChannel;\r\n        this._alphaMaxSideIndex         = this._maxSideIndex;\r\n\r\n        this._sideSize      = this._maxSideIndex + 1;\r\n        this._alphaSideSize = this._alphaMaxSideIndex + 1;\r\n    }\r\n\r\n}\r\n\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/palette/wu/wuQuant.ts\n **/", "/**\r\n * @preserve\r\n * Copyright 2015-2016 Igor Bezkrovnyi\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * iq.ts - Image Quantization Library\r\n */\r\nimport { IImageDitherer } from \"./common\"\r\nimport { NearestColor } from \"./nearestColor\"\r\nimport { ErrorDiffusionArray, ErrorDiffusionArrayKernel } from \"./array\"\r\nimport { ErrorDiffusionRiemersma } from \"./riemersma\"\r\n\r\nexport {\r\n    IImageDitherer,\r\n    NearestColor,\r\n    ErrorDiffusionArray,\r\n    ErrorDiffusionArrayKernel,\r\n    ErrorDiffusionRiemersma\r\n}\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/image/index.ts\n **/", "/**\r\n * @preserve\r\n * Copyright 2015-2016 Igor Bezkrovnyi\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * nearestColor.ts - part of Image Quantization Library\r\n */\r\nimport { IImageDitherer } from \"./common\"\r\nimport { AbstractDistanceCalculator } from \"../distance/abstractDistanceCalculator\"\r\nimport { PointContainer } from \"../utils/pointContainer\"\r\nimport { Palette } from \"../utils/palette\"\r\n\r\nexport class NearestColor implements IImageDitherer {\r\n    private _distance : AbstractDistanceCalculator;\r\n\r\n    constructor(colorDistanceCalculator : AbstractDistanceCalculator) {\r\n        this._distance = colorDistanceCalculator;\r\n    }\r\n\r\n    quantize(pointBuffer : PointContainer, palette : Palette) : PointContainer {\r\n        const pointArray = pointBuffer.getPointArray(),\r\n              width      = pointBuffer.getWidth(),\r\n              height     = pointBuffer.getHeight();\r\n\r\n        for (let y = 0; y < height; y++) {\r\n            for (let x = 0, idx = y * width; x < width; x++, idx++) {\r\n                // Image pixel\r\n                const point = pointArray[ idx ];\r\n                // Reduced pixel\r\n                point.from(palette.getNearestColor(this._distance, point));\r\n            }\r\n        }\r\n        return pointBuffer;\r\n    }\r\n}\r\n\r\n\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/image/nearestColor.ts\n **/", "/**\r\n * @preserve\r\n * Copyright 2015-2016 Igor Bezkrovnyi\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * ditherErrorDiffusionArray.ts - part of Image Quantization Library\r\n */\r\nimport { IImageDitherer } from \"./common\"\r\nimport { AbstractDistanceCalculator } from \"../distance/abstractDistanceCalculator\"\r\nimport { PointContainer } from \"../utils/pointContainer\"\r\nimport { Palette } from \"../utils/palette\"\r\nimport { Point } from \"../utils/point\"\r\nimport { inRange0to255Rounded } from \"../utils/arithmetic\"\r\n\r\n// TODO: is it the best name for this enum \"kernel\"?\r\nexport enum ErrorDiffusionArrayKernel {\r\n    FloydSteinberg = 0,\r\n    FalseFloydSteinberg,\r\n    Stucki,\r\n    Atkinson,\r\n    Jarvis,\r\n    Burkes,\r\n    Sierra,\r\n    TwoSierra,\r\n    SierraLite\r\n}\r\n\r\n// http://www.tannerhelland.com/4660/dithering-eleven-algorithms-source-code/\r\nexport class ErrorDiffusionArray implements IImageDitherer {\r\n    private _minColorDistance : number;\r\n    private _serpentine : boolean;\r\n    private _kernel : number[][];\r\n    /** true = GIMP, false = XNVIEW */\r\n            private _calculateErrorLikeGIMP : boolean;\r\n\r\n    private _distance : AbstractDistanceCalculator;\r\n\r\n    constructor(colorDistanceCalculator : AbstractDistanceCalculator, kernel : ErrorDiffusionArrayKernel, serpentine : boolean = true, minimumColorDistanceToDither : number = 0, calculateErrorLikeGIMP : boolean = false) {\r\n        this._setKernel(kernel);\r\n\r\n        this._distance               = colorDistanceCalculator;\r\n        this._minColorDistance       = minimumColorDistanceToDither;\r\n        this._serpentine             = serpentine;\r\n        this._calculateErrorLikeGIMP = calculateErrorLikeGIMP;\r\n    }\r\n\r\n    // adapted from http://jsbin.com/iXofIji/2/edit by PAEz\r\n    // fixed version. it doesn't use image pixels as error storage, also it doesn't have 0.3 + 0.3 + 0.3 + 0.3 = 0 error\r\n    quantize(pointBuffer : PointContainer, palette : Palette) : PointContainer {\r\n        const pointArray                = pointBuffer.getPointArray(),\r\n              originalPoint             = new Point(),\r\n              width                     = pointBuffer.getWidth(),\r\n              height                    = pointBuffer.getHeight(),\r\n              errorLines : number[][][] = [];\r\n\r\n        let dir           = 1,\r\n            maxErrorLines = 1;\r\n\r\n        // initial error lines (number is taken from dithering kernel)\r\n        for (let i = 0; i < this._kernel.length; i++) {\r\n            const kernelErrorLines = this._kernel[ i ][ 2 ] + 1;\r\n            if (maxErrorLines < kernelErrorLines) maxErrorLines = kernelErrorLines;\r\n        }\r\n        for (let i = 0; i < maxErrorLines; i++) {\r\n            this._fillErrorLine(errorLines[ i ] = [], width);\r\n        }\r\n\r\n        for (let y = 0; y < height; y++) {\r\n            // always serpentine\r\n            if (this._serpentine) dir = dir * -1;\r\n\r\n            const lni    = y * width,\r\n                  xStart = dir == 1 ? 0 : width - 1,\r\n                  xEnd   = dir == 1 ? width : -1;\r\n\r\n            // cyclic shift with erasing\r\n            this._fillErrorLine(errorLines[ 0 ], width);\r\n            // TODO: why it is needed to cast types here?\r\n            errorLines.push(<number[][]>errorLines.shift());\r\n\r\n            const errorLine = errorLines[ 0 ];\r\n            for (let x = xStart, idx = lni + xStart; x !== xEnd; x += dir, idx += dir) {\r\n                // Image pixel\r\n                const point = pointArray[ idx ],\r\n                      //originalPoint = new Utils.Point(),\r\n                      error = errorLine[ x ];\r\n\r\n                originalPoint.from(point);\r\n\r\n                const correctedPoint = Point.createByRGBA(\r\n                    inRange0to255Rounded(point.r + error[ 0 ]),\r\n                    inRange0to255Rounded(point.g + error[ 1 ]),\r\n                    inRange0to255Rounded(point.b + error[ 2 ]),\r\n                    inRange0to255Rounded(point.a + error[ 3 ])\r\n                );\r\n\r\n                // Reduced pixel\r\n                const palettePoint = palette.getNearestColor(this._distance, correctedPoint);\r\n                point.from(palettePoint);\r\n\r\n                // dithering strength\r\n                if (this._minColorDistance) {\r\n                    const dist = this._distance.calculateNormalized(point, palettePoint);\r\n                    if (dist < this._minColorDistance) continue;\r\n                }\r\n\r\n                // Component distance\r\n                let er : number, eg : number, eb : number, ea : number;\r\n                if (this._calculateErrorLikeGIMP) {\r\n                    er = correctedPoint.r - palettePoint.r;\r\n                    eg = correctedPoint.g - palettePoint.g;\r\n                    eb = correctedPoint.b - palettePoint.b;\r\n                    ea = correctedPoint.a - palettePoint.a;\r\n                } else {\r\n                    er = originalPoint.r - palettePoint.r;\r\n                    eg = originalPoint.g - palettePoint.g;\r\n                    eb = originalPoint.b - palettePoint.b;\r\n                    ea = originalPoint.a - palettePoint.a;\r\n                }\r\n\r\n                const dStart = dir == 1 ? 0 : this._kernel.length - 1,\r\n                      dEnd   = dir == 1 ? this._kernel.length : -1;\r\n\r\n                for (let i = dStart; i !== dEnd; i += dir) {\r\n                    const x1 = this._kernel[ i ][ 1 ] * dir,\r\n                          y1 = this._kernel[ i ][ 2 ];\r\n\r\n                    if (x1 + x >= 0 && x1 + x < width && y1 + y >= 0 && y1 + y < height) {\r\n                        const d = this._kernel[ i ][ 0 ],\r\n                              e = errorLines[ y1 ][ x1 + x ];\r\n\r\n                        e[ 0 ] = e[ 0 ] + er * d;\r\n                        e[ 1 ] = e[ 1 ] + eg * d;\r\n                        e[ 2 ] = e[ 2 ] + eb * d;\r\n                        e[ 3 ] = e[ 3 ] + ea * d;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return pointBuffer;\r\n    }\r\n\r\n    private _fillErrorLine(errorLine : number[][], width : number) : void {\r\n        // shrink\r\n        if (errorLine.length > width) {\r\n            errorLine.length = width;\r\n        }\r\n\r\n        // reuse existing arrays\r\n        const l = errorLine.length;\r\n        for (let i = 0; i < l; i++) {\r\n            const error = errorLine[ i ];\r\n            error[ 0 ]  = error[ 1 ] = error[ 2 ] = error[ 3 ] = 0;\r\n        }\r\n\r\n        // create missing arrays\r\n        for (let i = l; i < width; i++) {\r\n            errorLine[ i ] = [ 0.0, 0.0, 0.0, 0.0 ];\r\n        }\r\n    }\r\n\r\n    private _setKernel(kernel : ErrorDiffusionArrayKernel) {\r\n        switch (kernel) {\r\n            case ErrorDiffusionArrayKernel.FloydSteinberg:\r\n                this._kernel = [\r\n                    [ 7 / 16, 1, 0 ],\r\n                    [ 3 / 16, -1, 1 ],\r\n                    [ 5 / 16, 0, 1 ],\r\n                    [ 1 / 16, 1, 1 ]\r\n                ];\r\n                break;\r\n\r\n            case ErrorDiffusionArrayKernel.FalseFloydSteinberg:\r\n                this._kernel = [\r\n                    [ 3 / 8, 1, 0 ],\r\n                    [ 3 / 8, 0, 1 ],\r\n                    [ 2 / 8, 1, 1 ]\r\n                ];\r\n                break;\r\n\r\n            case ErrorDiffusionArrayKernel.Stucki:\r\n                this._kernel = [\r\n                    [ 8 / 42, 1, 0 ],\r\n                    [ 4 / 42, 2, 0 ],\r\n                    [ 2 / 42, -2, 1 ],\r\n                    [ 4 / 42, -1, 1 ],\r\n                    [ 8 / 42, 0, 1 ],\r\n                    [ 4 / 42, 1, 1 ],\r\n                    [ 2 / 42, 2, 1 ],\r\n                    [ 1 / 42, -2, 2 ],\r\n                    [ 2 / 42, -1, 2 ],\r\n                    [ 4 / 42, 0, 2 ],\r\n                    [ 2 / 42, 1, 2 ],\r\n                    [ 1 / 42, 2, 2 ]\r\n                ];\r\n                break;\r\n\r\n            case ErrorDiffusionArrayKernel.Atkinson:\r\n                this._kernel = [\r\n                    [ 1 / 8, 1, 0 ],\r\n                    [ 1 / 8, 2, 0 ],\r\n                    [ 1 / 8, -1, 1 ],\r\n                    [ 1 / 8, 0, 1 ],\r\n                    [ 1 / 8, 1, 1 ],\r\n                    [ 1 / 8, 0, 2 ]\r\n                ];\r\n                break;\r\n\r\n            case ErrorDiffusionArrayKernel.Jarvis:\r\n                this._kernel = [\t\t\t// Jarvis, Judice, and Ninke / JJN?\r\n                    [ 7 / 48, 1, 0 ],\r\n                    [ 5 / 48, 2, 0 ],\r\n                    [ 3 / 48, -2, 1 ],\r\n                    [ 5 / 48, -1, 1 ],\r\n                    [ 7 / 48, 0, 1 ],\r\n                    [ 5 / 48, 1, 1 ],\r\n                    [ 3 / 48, 2, 1 ],\r\n                    [ 1 / 48, -2, 2 ],\r\n                    [ 3 / 48, -1, 2 ],\r\n                    [ 5 / 48, 0, 2 ],\r\n                    [ 3 / 48, 1, 2 ],\r\n                    [ 1 / 48, 2, 2 ]\r\n                ];\r\n                break;\r\n\r\n            case ErrorDiffusionArrayKernel.Burkes:\r\n                this._kernel = [\r\n                    [ 8 / 32, 1, 0 ],\r\n                    [ 4 / 32, 2, 0 ],\r\n                    [ 2 / 32, -2, 1 ],\r\n                    [ 4 / 32, -1, 1 ],\r\n                    [ 8 / 32, 0, 1 ],\r\n                    [ 4 / 32, 1, 1 ],\r\n                    [ 2 / 32, 2, 1 ],\r\n                ];\r\n                break;\r\n\r\n            case ErrorDiffusionArrayKernel.Sierra:\r\n                this._kernel = [\r\n                    [ 5 / 32, 1, 0 ],\r\n                    [ 3 / 32, 2, 0 ],\r\n                    [ 2 / 32, -2, 1 ],\r\n                    [ 4 / 32, -1, 1 ],\r\n                    [ 5 / 32, 0, 1 ],\r\n                    [ 4 / 32, 1, 1 ],\r\n                    [ 2 / 32, 2, 1 ],\r\n                    [ 2 / 32, -1, 2 ],\r\n                    [ 3 / 32, 0, 2 ],\r\n                    [ 2 / 32, 1, 2 ]\r\n                ];\r\n                break;\r\n\r\n            case ErrorDiffusionArrayKernel.TwoSierra:\r\n                this._kernel = [\r\n                    [ 4 / 16, 1, 0 ],\r\n                    [ 3 / 16, 2, 0 ],\r\n                    [ 1 / 16, -2, 1 ],\r\n                    [ 2 / 16, -1, 1 ],\r\n                    [ 3 / 16, 0, 1 ],\r\n                    [ 2 / 16, 1, 1 ],\r\n                    [ 1 / 16, 2, 1 ]\r\n                ];\r\n                break;\r\n\r\n            case ErrorDiffusionArrayKernel.SierraLite:\r\n                this._kernel = [\r\n                    [ 2 / 4, 1, 0 ],\r\n                    [ 1 / 4, -1, 1 ],\r\n                    [ 1 / 4, 0, 1 ]\r\n                ];\r\n                break;\r\n\r\n            default:\r\n                throw new Error(\"ErrorDiffusionArray: unknown kernel = \" + kernel);\r\n        }\r\n    }\r\n}\r\n\r\n\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/image/array.ts\n **/", "/**\r\n * @preserve\r\n * MIT License\r\n *\r\n * Copyright 2015-2016 Igor Bezkrovnyi\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n * of this software and associated documentation files (the \"Software\"), to\r\n * deal in the Software without restriction, including without limitation the\r\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\r\n * sell copies of the Software, and to permit persons to whom the Software is\r\n * furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\r\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\r\n * IN THE SOFTWARE.\r\n *\r\n * nearestColor.ts - part of Image Quantization Library\r\n */\r\nimport { IImageDitherer } from \"./common\"\r\nimport { HilbertCurveBase } from \"./spaceFillingCurves/hilbertCurve\"\r\nimport { AbstractDistanceCalculator } from \"../distance/abstractDistanceCalculator\"\r\nimport { PointContainer } from \"../utils/pointContainer\"\r\nimport { Palette } from \"../utils/palette\"\r\nimport { Point } from \"../utils/point\"\r\nimport { inRange0to255Rounded } from \"../utils/arithmetic\"\r\n\r\nexport class ErrorDiffusionRiemersma implements IImageDitherer {\r\n    private _distance : AbstractDistanceCalculator;\r\n    private _weights : number[];\r\n    private _errorQueueSize : number;\r\n    private _errorPropagation : number;\r\n    private _max : number;\r\n\r\n    constructor(colorDistanceCalculator : AbstractDistanceCalculator, errorQueueSize : number = 16, errorPropagation : number = 1) {\r\n        this._distance         = colorDistanceCalculator;\r\n        this._errorPropagation = errorPropagation;\r\n        this._errorQueueSize   = errorQueueSize;\r\n        this._max              = this._errorQueueSize;\r\n        this._createWeights();\r\n    }\r\n\r\n    quantize(pointBuffer : PointContainer, palette : Palette) : PointContainer {\r\n        const curve                                                           = new HilbertCurveBase(),\r\n              pointArray                                                      = pointBuffer.getPointArray(),\r\n              width                                                           = pointBuffer.getWidth(),\r\n              height                                                          = pointBuffer.getHeight(),\r\n              errorQueue : {r : number; g : number; b : number; a : number}[] = [];\r\n\r\n        let head = 0;\r\n\r\n        for (let i = 0; i < this._errorQueueSize; i++) {\r\n            errorQueue[ i ] = { r : 0, g : 0, b : 0, a : 0 };\r\n        }\r\n\r\n        curve.walk(width, height, (x, y) => {\r\n            const p = pointArray[ x + y * width ];\r\n            let r   = p.r, g = p.g, b = p.b, a = p.a;\r\n            for (let i = 0; i < this._errorQueueSize; i++) {\r\n                const weight = this._weights[ i ],\r\n                      e      = errorQueue[ (i + head) % this._errorQueueSize ];\r\n\r\n                r += e.r * weight;\r\n                g += e.g * weight;\r\n                b += e.b * weight;\r\n                a += e.a * weight;\r\n            }\r\n\r\n            const correctedPoint = Point.createByRGBA(\r\n                inRange0to255Rounded(r),\r\n                inRange0to255Rounded(g),\r\n                inRange0to255Rounded(b),\r\n                inRange0to255Rounded(a)\r\n            );\r\n\r\n            const quantizedPoint = palette.getNearestColor(this._distance, correctedPoint);\r\n\r\n            // update head and calculate tail\r\n            head       = (head + 1) % this._errorQueueSize;\r\n            const tail = (head + this._errorQueueSize - 1) % this._errorQueueSize;\r\n\r\n            // update error with new value\r\n            errorQueue[ tail ].r = p.r - quantizedPoint.r;\r\n            errorQueue[ tail ].g = p.g - quantizedPoint.g;\r\n            errorQueue[ tail ].b = p.b - quantizedPoint.b;\r\n            errorQueue[ tail ].a = p.a - quantizedPoint.a;\r\n\r\n            // update point\r\n            p.from(quantizedPoint);\r\n        });\r\n\r\n        return pointBuffer;\r\n    }\r\n\r\n    private _createWeights() : void {\r\n        this._weights = [];\r\n\r\n        const multiplier = Math.exp(Math.log(this._max) / (this._errorQueueSize - 1));\r\n        for (let i = 0, next = 1; i < this._errorQueueSize; i++) {\r\n            this._weights[ i ] = (((next + 0.5) | 0) / this._max) * this._errorPropagation;\r\n            next *= multiplier;\r\n        }\r\n    }\r\n}\r\n\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/image/riemersma.ts\n **/", "enum Direction {\r\n    NONE = 0,\r\n    UP,\r\n    LEFT,\r\n    RIGHT,\r\n    DOWN,\r\n}\r\n\r\n// Check code against double-entrance into walk (walk=> callback => walk)\r\nexport class HilbertCurveBase {\r\n    private _x : number;\r\n    private _y : number;\r\n    private _d : number;\r\n    private _width : number;\r\n    private _height : number;\r\n    private _callback : (x : number, y : number, d : number) => void;\r\n    private _level : number;\r\n\r\n    walk(width : number, height : number, visitorCallback : (x : number, y : number, d : number) => void) : void {\r\n        this._x        = 0;\r\n        this._y        = 0;\r\n        this._d        = 0;\r\n        this._width    = width;\r\n        this._height   = height;\r\n        this._callback = visitorCallback;\r\n\r\n        const maxBound = Math.max(width, height);\r\n\r\n        this._level = (Math.log(maxBound) / Math.log(2) + 1) | 0;\r\n        this._walkHilbert(Direction.UP);\r\n        this._visit(Direction.NONE);\r\n    }\r\n\r\n    private _walkHilbert(direction : Direction) {\r\n        if (this._level < 1) return;\r\n\r\n        this._level--;\r\n        switch (direction) {\r\n            case Direction.LEFT:\r\n                this._walkHilbert(Direction.UP);\r\n                this._visit(Direction.RIGHT);\r\n                this._walkHilbert(Direction.LEFT);\r\n                this._visit(Direction.DOWN);\r\n                this._walkHilbert(Direction.LEFT);\r\n                this._visit(Direction.LEFT);\r\n                this._walkHilbert(Direction.DOWN);\r\n                break;\r\n\r\n            case Direction.RIGHT:\r\n                this._walkHilbert(Direction.DOWN);\r\n                this._visit(Direction.LEFT);\r\n                this._walkHilbert(Direction.RIGHT);\r\n                this._visit(Direction.UP);\r\n                this._walkHilbert(Direction.RIGHT);\r\n                this._visit(Direction.RIGHT);\r\n                this._walkHilbert(Direction.UP);\r\n                break;\r\n\r\n            case Direction.UP:\r\n                this._walkHilbert(Direction.LEFT);\r\n                this._visit(Direction.DOWN);\r\n                this._walkHilbert(Direction.UP);\r\n                this._visit(Direction.RIGHT);\r\n                this._walkHilbert(Direction.UP);\r\n                this._visit(Direction.UP);\r\n                this._walkHilbert(Direction.RIGHT);\r\n                break;\r\n\r\n            case Direction.DOWN:\r\n                this._walkHilbert(Direction.RIGHT);\r\n                this._visit(Direction.UP);\r\n                this._walkHilbert(Direction.DOWN);\r\n                this._visit(Direction.LEFT);\r\n                this._walkHilbert(Direction.DOWN);\r\n                this._visit(Direction.DOWN);\r\n                this._walkHilbert(Direction.LEFT);\r\n                break;\r\n\r\n            default:\r\n                break;\r\n        }\r\n        this._level++;\r\n    }\r\n\r\n    private _visit(direction : Direction) : void {\r\n        if (this._x >= 0 && this._x < this._width && this._y >= 0 && this._y < this._height) {\r\n            this._callback(this._x, this._y, this._d);\r\n            this._d++;\r\n        }\r\n        switch (direction) {\r\n            case Direction.LEFT:\r\n                this._x--;\r\n                break;\r\n            case Direction.RIGHT:\r\n                this._x++;\r\n                break;\r\n            case Direction.UP:\r\n                this._y--;\r\n                break;\r\n            case Direction.DOWN:\r\n                this._y++;\r\n                break;\r\n        }\r\n    }\r\n}\r\n\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/image/spaceFillingCurves/hilbertCurve.ts\n **/", "/**\r\n * @preserve\r\n * Copyright 2015-2016 Igor Bezkrovnyi\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * iq.ts - Image Quantization Library\r\n */\r\nimport { SSIM } from \"./ssim\"\r\n\r\nexport {\r\n    SSIM\r\n}\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/quality/index.ts\n **/", "/**\r\n * @preserve\r\n * Copyright 2015-2016 Igor Bezkrovnyi\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * ssim.ts - part of Image Quantization Library\r\n */\r\nimport { PointContainer } from \"../utils/pointContainer\"\r\nimport { Y } from \"../constants/bt709\"\r\n\r\n// based on https://github.com/rhys-e/structural-similarity\r\n// http://en.wikipedia.org/wiki/Structural_similarity\r\nconst K1 = 0.01,\r\n      K2 = 0.03;\r\n\r\nexport class SSIM {\r\n    compare(image1 : PointContainer, image2 : PointContainer) {\r\n        if (image1.getHeight() !== image2.getHeight() || image1.getWidth() !== image2.getWidth()) {\r\n            throw new Error(\"Images have different sizes!\");\r\n        }\r\n\r\n        const bitsPerComponent = 8,\r\n              L                = (1 << bitsPerComponent) - 1,\r\n              c1               = Math.pow((K1 * L), 2),\r\n              c2               = Math.pow((K2 * L), 2);\r\n\r\n        let numWindows = 0,\r\n            mssim      = 0.0;\r\n\r\n        //calculate ssim for each window\r\n        this._iterate(image1, image2, (lumaValues1 : number[], lumaValues2 : number[], averageLumaValue1 : number, averageLumaValue2 : number) => {\r\n            //calculate variance and covariance\r\n            let sigxy  = 0.0,\r\n                sigsqx = 0.0,\r\n                sigsqy = 0.0;\r\n\r\n            for (let i = 0; i < lumaValues1.length; i++) {\r\n                sigsqx += Math.pow((lumaValues1[ i ] - averageLumaValue1), 2);\r\n                sigsqy += Math.pow((lumaValues2[ i ] - averageLumaValue2), 2);\r\n\r\n                sigxy += (lumaValues1[ i ] - averageLumaValue1) * (lumaValues2[ i ] - averageLumaValue2);\r\n            }\r\n\r\n            const numPixelsInWin = lumaValues1.length - 1;\r\n            sigsqx /= numPixelsInWin;\r\n            sigsqy /= numPixelsInWin;\r\n            sigxy /= numPixelsInWin;\r\n\r\n            //perform ssim calculation on window\r\n            const numerator   = (2 * averageLumaValue1 * averageLumaValue2 + c1) * (2 * sigxy + c2),\r\n                  denominator = (Math.pow(averageLumaValue1, 2) + Math.pow(averageLumaValue2, 2) + c1) * (sigsqx + sigsqy + c2),\r\n                  ssim        = numerator / denominator;\r\n\r\n            mssim += ssim;\r\n            numWindows++;\r\n\r\n        });\r\n        return mssim / numWindows;\r\n    }\r\n\r\n    private _iterate(image1 : PointContainer, image2 : PointContainer, callback : (lumaValues1 : number[], lumaValues2 : number[], averageLumaValue1 : number, averageLumaValue2 : number) => void) {\r\n        const windowSize = 8,\r\n              width      = image1.getWidth(),\r\n              height     = image1.getHeight();\r\n\r\n        for (let y = 0; y < height; y += windowSize) {\r\n            for (let x = 0; x < width; x += windowSize) {\r\n                // avoid out-of-width/height\r\n                const windowWidth  = Math.min(windowSize, width - x),\r\n                      windowHeight = Math.min(windowSize, height - y);\r\n\r\n                const lumaValues1  = this._calculateLumaValuesForWindow(image1, x, y, windowWidth, windowHeight),\r\n                      lumaValues2  = this._calculateLumaValuesForWindow(image2, x, y, windowWidth, windowHeight),\r\n                      averageLuma1 = this._calculateAverageLuma(lumaValues1),\r\n                      averageLuma2 = this._calculateAverageLuma(lumaValues2);\r\n\r\n                callback(lumaValues1, lumaValues2, averageLuma1, averageLuma2);\r\n            }\r\n        }\r\n    }\r\n\r\n    private _calculateLumaValuesForWindow(image : PointContainer, x : number, y : number, width : number, height : number) : number[] {\r\n        const pointArray            = image.getPointArray(),\r\n              lumaValues : number[] = [];\r\n\r\n        let counter = 0;\r\n\r\n        for (let j = y; j < y + height; j++) {\r\n            const offset = j * image.getWidth();\r\n            for (let i = x; i < x + width; i++) {\r\n                const point           = pointArray[ offset + i ];\r\n                lumaValues[ counter ] = point.r * Y.RED + point.g * Y.GREEN + point.b * Y.BLUE;\r\n                counter++;\r\n            }\r\n        }\r\n\r\n        return lumaValues;\r\n    }\r\n\r\n    private _calculateAverageLuma(lumaValues : number[]) : number {\r\n        let sumLuma = 0.0;\r\n        for (let i = 0; i < lumaValues.length; i++) {\r\n            sumLuma += lumaValues[ i ];\r\n        }\r\n\r\n        return sumLuma / lumaValues.length;\r\n    }\r\n\r\n}\r\n\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/quality/ssim.ts\n **/", "/**\r\n * @preserve\r\n * Copyright 2015-2016 Igor Bezkrovnyi\r\n * All rights reserved. (MIT Licensed)\r\n *\r\n * iq.ts - Image Quantization Library\r\n */\r\nimport * as arithmetic from \"./arithmetic\"\r\nimport { HueStatistics } from \"./hueStatistics\"\r\nimport { Palette } from \"./palette\"\r\nimport { Point } from \"./point\"\r\nimport { PointContainer } from \"./pointContainer\"\r\n\r\nexport {\r\n    Point,\r\n    PointContainer,\r\n    Palette,\r\n    HueStatistics,\r\n    arithmetic\r\n}\r\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/utils/index.ts\n **/", "'use strict';\n\nconst BitmapImage = require('./bitmapimage');\nconst { GifError } = require('./gif');\n\n/** @class GifFrame */\n\nclass GifFrame extends BitmapImage {\n\n    // xOffset - x offset of bitmap on GIF (defaults to 0)\n    // yOffset - y offset of bitmap on GIF (defaults to 0)\n    // disposalMethod - pixel disposal method when handling partial images\n    // delayCentisecs - duration of frame in hundredths of a second\n    // interlaced - whether the image is interlaced (defaults to false)\n\n    /**\n     * GifFrame is a class representing an image frame of a GIF. GIFs contain one or more instances of GifFrame.\n     * \n     * Property | Description\n     * --- | ---\n     * xOffset | x-coord of position within GIF at which to render the image (defaults to 0)\n     * yOffset | y-coord of position within GIF at which to render the image (defaults to 0)\n     * disposalMethod | GIF disposal method; only relevant when the frames aren't all the same size (defaults to 2, disposing to background color)\n     * delayCentisecs | duration of the frame in hundreths of a second\n     * interlaced | boolean indicating whether the frame renders interlaced\n     * \n     * Its constructor supports the following signatures:\n     * \n     * * new GifFrame(bitmap: {width: number, height: number, data: Buffer}, options?)\n     * * new GifFrame(bitmapImage: BitmapImage, options?)\n     * * new GifFrame(width: number, height: number, buffer: Buffer, options?)\n     * * new GifFrame(width: number, height: number, backgroundRGBA?: number, options?)\n     * * new GifFrame(frame: GifFrame)\n     * \n     * See the base class BitmapImage for a discussion of all parameters but `options` and `frame`. `options` is an optional argument providing initial values for the above-listed GifFrame properties. Each property within option is itself optional.\n     * \n     * Provide a `frame` to the constructor to create a clone of the provided frame. The new frame includes a copy of the provided frame's pixel data so that each can subsequently be modified without affecting each other.\n     */\n\n    constructor(...args) {\n        super(...args);\n        if (args[0] instanceof GifFrame) {\n            // copy a provided GifFrame\n            const source = args[0];\n            this.xOffset = source.xOffset;\n            this.yOffset = source.yOffset;\n            this.disposalMethod = source.disposalMethod;\n            this.delayCentisecs = source.delayCentisecs;\n            this.interlaced = source.interlaced;\n        }\n        else {\n            const lastArg = args[args.length - 1];\n            let options = {};\n            if (typeof lastArg === 'object' && !(lastArg instanceof BitmapImage)) {\n                options = lastArg;\n            }\n            this.xOffset = options.xOffset || 0;\n            this.yOffset = options.yOffset || 0;\n            this.disposalMethod = (options.disposalMethod !== undefined ?\n                    options.disposalMethod : GifFrame.DisposeToBackgroundColor);\n            this.delayCentisecs = options.delayCentisecs || 8;\n            this.interlaced = options.interlaced || false;\n        }\n    }\n\n    /**\n     * Get a summary of the colors found within the frame. The return value is an object of the following form:\n     * \n     * Property | Description\n     * --- | ---\n     * colors | An array of all the opaque colors found within the frame. Each color is given as an RGB number of the form 0xRRGGBB. The array is sorted by increasing number. Will be an empty array when the image is completely transparent.\n     * usesTransparency | boolean indicating whether there are any transparent pixels within the frame. A pixel is considered transparent if its alpha value is 0x00.\n     * indexCount | The number of color indexes required to represent this palette of colors. It is equal to the number of opaque colors plus one if the image includes transparency.\n     * \n     * @return {object} An object representing a color palette as described above.\n     */\n\n    getPalette() {\n        // returns with colors sorted low to high\n        const colorSet = new Set();\n        const buf = this.bitmap.data;\n        let i = 0;\n        let usesTransparency = false;\n        while (i < buf.length) {\n            if (buf[i + 3] === 0) {\n                usesTransparency = true;\n            }\n            else {\n                // can eliminate the bitshift by starting one byte prior\n                const color = (buf.readUInt32BE(i, true) >> 8) & 0xFFFFFF;\n                colorSet.add(color);\n            }\n            i += 4; // skip alpha\n        }\n        const colors = new Array(colorSet.size);\n        const iter = colorSet.values();\n        for (i = 0; i < colors.length; ++i) {\n            colors[i] = iter.next().value;\n        }\n        colors.sort((a, b) => (a - b));\n        let indexCount = colors.length;\n        if (usesTransparency) {\n            ++indexCount;\n        }\n        return { colors, usesTransparency, indexCount };\n    }\n}\n\nGifFrame.DisposeToAnything = 0;\nGifFrame.DisposeNothing = 1;\nGifFrame.DisposeToBackgroundColor = 2;\nGifFrame.DisposeToPrevious = 3;\n\nexports.GifFrame = GifFrame;\n", "'use strict';\n\n/** @namespace GifUtil */\n\nconst fs = require('fs');\nconst ImageQ = require('image-q');\n\nconst BitmapImage = require('./bitmapimage');\nconst { GifFrame } = require('./gifframe');\nconst { GifError } = require('./gif');\nconst { GifCodec } = require('./gifcodec');\n\nconst INVALID_SUFFIXES = ['.jpg', '.jpeg', '.png', '.bmp'];\n\nconst defaultCodec = new GifCodec();\n\n/**\n * cloneFrames() clones provided frames. It's a utility method for cloning an entire array of frames at once.\n * \n * @function cloneFrames\n * @memberof GifUtil\n * @param {GifFrame[]} frames An array of GifFrame instances to clone\n * @return {GifFrame[]} An array of GifFrame clones of the provided frames.\n */\n\nexports.cloneFrames = function (frames) {\n    let clones = [];\n    frames.forEach(frame => {\n\n        clones.push(new GifFrame(frame));\n    });\n    return clones;\n}\n\n/**\n * getColorInfo() gets information about the colors used in the provided frames. The method is able to return an array of all colors found across all frames.\n * \n * `maxGlobalIndex` controls whether the computation short-circuits to avoid doing work that the caller doesn't need. The method only returns `colors` and `indexCount` for the colors across all frames when the number of indexes required to store the colors and transparency in a GIF (which is the value of `indexCount`) is less than or equal to `maxGlobalIndex`. Such short-circuiting is useful when the caller just needs to determine whether any frame includes transparency.\n * \n * @function getColorInfo\n * @memberof GifUtil\n * @param {GifFrame[]} frames Frames to examine for color and transparency.\n * @param {number} maxGlobalIndex Maximum number of color indexes (including one for transparency) allowed among the returned compilation of colors. `colors` and `indexCount` are not returned if the number of color indexes required to accommodate  all frames exceeds this number. Returns `colors` and `indexCount` by default.\n * @returns {object} Object containing at least `palettes` and `usesTransparency`. `palettes` is an array of all the palettes returned by GifFrame#getPalette(). `usesTransparency` indicates whether at least one frame uses transparency. If `maxGlobalIndex` is not exceeded, the object also contains `colors`, an array of all colors (RGB) found across all palettes, sorted by increasing value, and `indexCount` indicating the number of indexes required to store the colors and the transparency in a GIF.\n * @throws {GifError} When any frame requires more than 256 color indexes.\n */\n\nexports.getColorInfo = function (frames, maxGlobalIndex) {\n    let usesTransparency = false;\n    const palettes = [];\n    for (let i = 0; i < frames.length; ++i) {\n        let palette = frames[i].getPalette();\n        if (palette.usesTransparency) {\n            usesTransparency = true;\n        }\n        if (palette.indexCount > 256) {\n            throw new GifError(`Frame ${i} uses more than 256 color indexes`);\n        }\n        palettes.push(palette);\n    }\n    if (maxGlobalIndex === 0) {\n        return { usesTransparency, palettes };\n    }\n\n    const globalColorSet = new Set();\n    palettes.forEach(palette => {\n\n        palette.colors.forEach(color => {\n\n            globalColorSet.add(color);\n        });\n    });\n    let indexCount = globalColorSet.size;\n    if (usesTransparency) {\n        // odd that GIF requires a color table entry at transparent index\n        ++indexCount;\n    }\n    if (maxGlobalIndex && indexCount > maxGlobalIndex) {\n        return { usesTransparency, palettes };\n    }\n    \n    const colors = new Array(globalColorSet.size);\n    const iter = globalColorSet.values();\n    for (let i = 0; i < colors.length; ++i) {\n        colors[i] = iter.next().value;\n    }\n    colors.sort((a, b) => (a - b));\n    return { colors, indexCount, usesTransparency, palettes };\n};\n\n/**\n * copyAsJimp() returns a Jimp that contains a copy of the provided bitmap image (which may be either a BitmapImage or a GifFrame). Modifying the Jimp does not affect the provided bitmap image. This method serves as a macro for simplifying working with Jimp.\n *\n * @function copyAsJimp\n * @memberof GifUtil\n * @param {object} Reference to the Jimp package, keeping this library from being dependent on Jimp.\n * @param {bitmapImageToCopy} Instance of BitmapImage (may be a GifUtil) with which to source the Jimp.\n * @return {object} An new instance of Jimp containing a copy of the image in bitmapImageToCopy.\n */\n \nexports.copyAsJimp = function (jimp, bitmapImageToCopy) {\n    return exports.shareAsJimp(jimp, new BitmapImage(bitmapImageToCopy));\n};\n\n/**\n * getMaxDimensions() returns the pixel width and height required to accommodate all of the provided frames, according to the offsets and dimensions of each frame.\n * \n * @function getMaxDimensions\n * @memberof GifUtil\n * @param {GifFrame[]} frames Frames to measure for their aggregate maximum dimensions.\n * @return {object} An object of the form {maxWidth, maxHeight} indicating the maximum width and height required to accommodate all frames.\n */\n\nexports.getMaxDimensions = function (frames) {\n    let maxWidth = 0, maxHeight = 0;\n    frames.forEach(frame => {\n        const width = frame.xOffset + frame.bitmap.width;\n        if (width > maxWidth) {\n            maxWidth = width;\n        }\n        const height = frame.yOffset + frame.bitmap.height;\n        if (height > maxHeight) {\n            maxHeight = height;\n        }\n    });\n    return { maxWidth, maxHeight };\n};\n\n/**\n * Quantizes colors so that there are at most a given number of color indexes (including transparency) across all provided images. Uses an algorithm by Anthony Dekker.\n * \n * The method treats different RGBA combinations as different colors, so if the frame has multiple alpha values or multiple RGB values for an alpha value, the caller may first want to normalize them by converting all transparent pixels to the same RGBA values.\n * \n * The method may increase the number of colors if there are fewer than the provided maximum.\n * \n * @function quantizeDekker\n * @memberof GifUtil\n * @param {BitmapImage|BitmapImage[]} imageOrImages Image or array of images (such as GifFrame instances) to be color-quantized. Quantizing across multiple images ensures color consistency from frame to frame.\n * @param {number} maxColorIndexes The maximum number of color indexes that will exist in the palette after completing quantization. Defaults to 256.\n * @param {object} dither (optional) An object configuring the dithering to apply. The properties are as followings, imported from the [`image-q` package](https://github.com/ibezkrovnyi/image-quantization) without explanation: { `ditherAlgorithm`: One of 'FloydSteinberg', 'FalseFloydSteinberg', 'Stucki', 'Atkinson', 'Jarvis', 'Burkes', 'Sierra', 'TwoSierra', 'SierraLite'; `minimumColorDistanceToDither`: (optional) A number defaulting to 0; `serpentine`: (optional) A boolean defaulting to true; `calculateErrorLikeGIMP`: (optional) A boolean defaulting to false. }\n */\n\nexports.quantizeDekker = function (imageOrImages, maxColorIndexes, dither) {\n    maxColorIndexes = maxColorIndexes || 256;\n    _quantize(imageOrImages, 'NeuQuantFloat', maxColorIndexes, 0, dither);\n}\n\n/**\n * Quantizes colors so that there are at most a given number of color indexes (including transparency) across all provided images. Uses an algorithm by Leon Sorokin. This quantization method differs from the other two by likely never increasing the number of colors, should there be fewer than the provided maximum.\n * \n * The method treats different RGBA combinations as different colors, so if the frame has multiple alpha values or multiple RGB values for an alpha value, the caller may first want to normalize them by converting all transparent pixels to the same RGBA values.\n * \n * @function quantizeSorokin\n * @memberof GifUtil\n * @param {BitmapImage|BitmapImage[]} imageOrImages Image or array of images (such as GifFrame instances) to be color-quantized. Quantizing across multiple images ensures color consistency from frame to frame.\n * @param {number} maxColorIndexes The maximum number of color indexes that will exist in the palette after completing quantization. Defaults to 256.\n * @param {string} histogram (optional) Histogram method: 'top-pop' for global top-population, 'min-pop' for minimum-population threshhold within subregions. Defaults to 'min-pop'.\n * @param {object} dither (optional) An object configuring the dithering to apply, as explained for `quantizeDekker()`.\n */\n\nexports.quantizeSorokin = function (imageOrImages, maxColorIndexes, histogram, dither) {\n    maxColorIndexes = maxColorIndexes || 256;\n    histogram = histogram || 'min-pop';\n    let histogramID;\n    switch (histogram) {\n        case 'min-pop':\n        histogramID = 2;\n        break;\n\n        case 'top-pop':\n        histogramID = 1;\n        break\n\n        default:\n        throw new Error(`Invalid quantizeSorokin histogram '${histogram}'`);\n    }\n    _quantize(imageOrImages, 'RGBQuant', maxColorIndexes, histogramID, dither);\n}\n\n/**\n * Quantizes colors so that there are at most a given number of color indexes (including transparency) across all provided images. Uses an algorithm by Xiaolin Wu.\n * \n * The method treats different RGBA combinations as different colors, so if the frame has multiple alpha values or multiple RGB values for an alpha value, the caller may first want to normalize them by converting all transparent pixels to the same RGBA values.\n * \n * The method may increase the number of colors if there are fewer than the provided maximum.\n * \n * @function quantizeWu\n * @memberof GifUtil\n * @param {BitmapImage|BitmapImage[]} imageOrImages Image or array of images (such as GifFrame instances) to be color-quantized. Quantizing across multiple images ensures color consistency from frame to frame.\n * @param {number} maxColorIndexes The maximum number of color indexes that will exist in the palette after completing quantization. Defaults to 256.\n * @param {number} significantBits (optional) This is the number of significant high bits in each RGB color channel. Takes integer values from 1 through 8. Higher values correspond to higher quality. Defaults to 5.\n * @param {object} dither (optional) An object configuring the dithering to apply, as explained for `quantizeDekker()`.\n */\n\nexports.quantizeWu = function (imageOrImages, maxColorIndexes, significantBits, dither) {\n    maxColorIndexes = maxColorIndexes || 256;\n    significantBits = significantBits || 5;\n    if (significantBits < 1 || significantBits > 8) {\n        throw new Error(\"Invalid quantization quality\");\n    }\n    _quantize(imageOrImages, 'WuQuant', maxColorIndexes, significantBits, dither);\n}\n\n/**\n * read() decodes an encoded GIF, whether provided as a filename or as a byte buffer.\n * \n * @function read\n * @memberof GifUtil\n * @param {string|Buffer} source Source to decode. When a string, it's the GIF filename to load and parse. When a Buffer, it's an encoded GIF to parse.\n * @param {object} decoder An optional GIF decoder object implementing the `decode` method of class GifCodec. When provided, the method decodes the GIF using this decoder. When not provided, the method uses GifCodec.\n * @return {Promise} A Promise that resolves to an instance of the Gif class, representing the decoded GIF.\n */\n\nexports.read = function (source, decoder) {\n    decoder = decoder || defaultCodec;\n    if (Buffer.isBuffer(source)) {\n        return decoder.decodeGif(source);\n    }\n    return _readBinary(source)\n    .then(buffer => {\n\n        return decoder.decodeGif(buffer);\n    });\n};\n\n/**\n * shareAsJimp() returns a Jimp that shares a bitmap with the provided bitmap image (which may be either a BitmapImage or a GifFrame). Modifying the image in either the Jimp or the BitmapImage affects the other objects. This method serves as a macro for simplifying working with Jimp.\n *\n * @function shareAsJimp\n * @memberof GifUtil\n * @param {object} Reference to the Jimp package, keeping this library from being dependent on Jimp.\n * @param {bitmapImageToShare} Instance of BitmapImage (may be a GifUtil) with which to source the Jimp.\n * @return {object} An new instance of Jimp that shares the image in bitmapImageToShare.\n */\n \nexports.shareAsJimp = function (jimp, bitmapImageToShare) {\n    const jimpImage = new jimp(bitmapImageToShare.bitmap.width,\n            bitmapImageToShare.bitmap.height, 0);\n    jimpImage.bitmap.data = bitmapImageToShare.bitmap.data;\n    return jimpImage;\n};\n\n/**\n * write() encodes a GIF and saves it as a file.\n * \n * @function write\n * @memberof GifUtil\n * @param {string} path Filename to write GIF out as. Will overwrite an existing file.\n * @param {GifFrame[]} frames Array of frames to be written into GIF.\n * @param {object} spec An optional object that may provide values for `loops` and `colorScope`, as defined for the Gif class. However, `colorSpace` may also take the value Gif.GlobalColorsPreferred (== 0) to indicate that the encoder should attempt to create only a global color table. `loop` defaults to 0, looping indefinitely, and `colorScope` defaults to Gif.GlobalColorsPreferred.\n * @param {object} encoder An optional GIF encoder object implementing the `encode` method of class GifCodec. When provided, the method encodes the GIF using this encoder. When not provided, the method uses GifCodec.\n * @return {Promise} A Promise that resolves to an instance of the Gif class, representing the encoded GIF.\n */\n\nexports.write = function (path, frames, spec, encoder) {\n    encoder = encoder || defaultCodec;\n    const matches = path.match(/\\.[a-zA-Z]+$/); // prevent accidents\n    if (matches !== null &&\n            INVALID_SUFFIXES.includes(matches[0].toLowerCase()))\n    {\n        throw new Error(`GIF '${path}' has an unexpected suffix`);\n    }\n\n    return encoder.encodeGif(frames, spec)\n    .then(gif => {\n\n        return _writeBinary(path, gif.buffer)\n        .then(() => {\n\n            return gif;\n        });\n    });\n};\n\nfunction _quantize(imageOrImages, method, maxColorIndexes, modifier, dither) {\n    const images = Array.isArray(imageOrImages) ? imageOrImages : [imageOrImages];\n    const ditherAlgs = [\n        'FloydSteinberg',\n        'FalseFloydSteinberg',\n        'Stucki',\n        'Atkinson',\n        'Jarvis',\n        'Burkes',\n        'Sierra',\n        'TwoSierra',\n        'SierraLite'\n    ];\n\n    if (dither) {\n        if (ditherAlgs.indexOf(dither.ditherAlgorithm) < 0) {\n            throw new Error(`Invalid ditherAlgorithm '${dither.ditherAlgorithm}'`);\n        }\n        if (dither.serpentine === undefined) {\n            dither.serpentine = true;\n        }\n        if (dither.minimumColorDistanceToDither === undefined) {\n            dither.minimumColorDistanceToDither = 0;\n        }\n        if (dither.calculateErrorLikeGIMP === undefined) {\n            dither.calculateErrorLikeGIMP = false;\n        }\n    }\n\n    const distCalculator = new ImageQ.distance.Euclidean();\n    const quantizer = new ImageQ.palette[method](distCalculator, maxColorIndexes, modifier);\n    let imageMaker;\n    if (dither) {\n        imageMaker = new ImageQ.image.ErrorDiffusionArray(\n            distCalculator,\n            ImageQ.image.ErrorDiffusionArrayKernel[dither.ditherAlgorithm],\n            dither.serpentine,\n            dither.minimumColorDistanceToDither,\n            dither.calculateErrorLikeGIMP\n        );\n    }\n    else {\n        imageMaker = new ImageQ.image.NearestColor(distCalculator);\n    }\n\n    const inputContainers = [];\n    images.forEach(image => {\n\n        const imageBuf = image.bitmap.data;\n        const inputBuf = new ArrayBuffer(imageBuf.length);\n        const inputArray = new Uint32Array(inputBuf);\n        for (let bi = 0, ai = 0; bi < imageBuf.length; bi += 4, ++ai) {\n            inputArray[ai] = imageBuf.readUInt32LE(bi, true);\n        }\n        const inputContainer = ImageQ.utils.PointContainer.fromUint32Array(\n                inputArray, image.bitmap.width, image.bitmap.height);\n        quantizer.sample(inputContainer);\n        inputContainers.push(inputContainer);\n    });\n    \n    const limitedPalette = quantizer.quantize();\n\n    for (let i = 0; i < images.length; ++i) {\n        const imageBuf = images[i].bitmap.data;\n        const outputContainer = imageMaker.quantize(inputContainers[i], limitedPalette);\n        const outputArray = outputContainer.toUint32Array();\n        for (let bi = 0, ai = 0; bi < imageBuf.length; bi += 4, ++ai) {\n            imageBuf.writeUInt32LE(outputArray[ai], bi);\n        }\n    }\n}\n\nfunction _readBinary(path) {\n    // TBD: add support for URLs\n    return new Promise((resolve, reject) => {\n\n        fs.readFile(path, (err, buffer) => {\n\n            if (err) {\n                return reject(err);\n            }\n            return resolve(buffer);\n        });\n    });\n}\n\nfunction _writeBinary(path, buffer) {\n    // TBD: add support for URLs\n    return new Promise((resolve, reject) => {\n\n        fs.writeFile(path, buffer, err => {\n            \n            if (err) {\n                return reject(err);\n            }\n            return resolve();\n        });\n    });\n}\n", "'use strict';\n\nconst Omggif = require('omggif');\nconst { Gif, GifError } = require('./gif');\nlet GifUtil; // allow circular dependency with GifUtil\nprocess.nextTick(() => {\n    GifUtil = require('./gifutil');\n});\n\nconst { GifFrame } = require('./gifframe');\n\nconst PER_GIF_OVERHEAD = 200; // these are guesses at upper limits\nconst PER_FRAME_OVERHEAD = 100;\n\n// Note: I experimented with accepting a global color table when encoding and returning the global color table when decoding. Doing this properly greatly increased the complexity of the code and the amount of clock cycles required. The main issue is that each frame can specify any color of the global color table to be transparent within the frame, while this GIF library strives to hide GIF formatting details from its clients. E.g. it's possible to have 256 colors in the global color table and different transparencies in each frame, requiring clients to either provide per-frame transparency indexes, or for arcane reasons that won't be apparent to client developers, encode some GIFs with local color tables that previously decoded with global tables.\n\n/** @class GifCodec */\n\nclass GifCodec\n{\n    // _transparentRGBA - RGB given to transparent pixels (alpha=0) on decode; defaults to null indicating 0x000000, which is fastest\n\n    /**\n     * GifCodec is a class that both encodes and decodes GIFs. It implements both the `encode()` method expected of an encoder and the `decode()` method expected of a decoder, and it wraps the `omggif` GIF encoder/decoder package. GifCodec serves as this library's default encoder and decoder, but it's possible to wrap other GIF encoders and decoders for use by `gifwrap` as well. GifCodec will not encode GIFs with interlacing.\n     * \n     * Instances of this class are stateless and can be shared across multiple encodings and decodings.\n     * \n     * Its constructor takes one option argument:\n     * \n     * @param {object} options Optionally takes an objection whose only possible property is `transparentRGB`. Images are internally represented in RGBA format, where A is the alpha value of a pixel. When `transparentRGB` is provided, this RGB value (excluding alpha) is assigned to transparent pixels, which are also given alpha value 0x00. (All opaque pixels are given alpha value 0xFF). The RGB color of transparent pixels shouldn't matter for most applications. Defaults to 0x000000.\n     */\n\n    constructor(options = {}) {\n        this._transparentRGB = null; // 0x000000\n        if (typeof options.transparentRGB === 'number' &&\n                options.transparentRGB !== 0)\n        {\n            this._transparentRGBA = options.transparentRGB * 256;\n        }\n        this._testInitialBufferSize = 0; // assume no buffer scaling test\n    }\n\n    /**\n     * Decodes a GIF from a Buffer to yield an instance of Gif. Transparent pixels of the GIF are given alpha values of 0x00, and opaque pixels are given alpha values of 0xFF. The RGB values of transparent pixels default to 0x000000 but can be overridden by the constructor's `transparentRGB` option.\n     * \n     * @param {Buffer} buffer Bytes of an encoded GIF to decode.\n     * @return {Promise} A Promise that resolves to an instance of the Gif class, representing the encoded GIF.\n     * @throws {GifError} Error upon encountered an encoding-related problem with a GIF, so that the caller can distinguish between software errors and problems with GIFs.\n     */\n\n    decodeGif(buffer) {\n        try {\n            let reader;\n            try {\n                reader = new Omggif.GifReader(buffer);\n            }\n            catch (err) {\n                throw new GifError(err);\n            }\n            const frameCount = reader.numFrames();\n            const frames = [];\n            const spec = {\n                width: reader.width,\n                height: reader.height,\n                loops: reader.loopCount()\n            };\n\n            spec.usesTransparency = false;\n            for (let i = 0; i < frameCount; ++i) {\n                const frameInfo =\n                        this._decodeFrame(reader, i, spec.usesTransparency);\n                frames.push(frameInfo.frame);\n                if (frameInfo.usesTransparency) {\n                    spec.usesTransparency = true;\n                }\n            }\n            return Promise.resolve(new Gif(buffer, frames, spec));\n        }\n        catch (err) {\n            return Promise.reject(err);\n        }\n    }\n\n    /**\n     * Encodes a GIF from provided frames. Each pixel having an alpha value of 0x00 renders as transparent within the encoding, while all pixels of non-zero alpha value render as opaque.\n     * \n     * @param {GifFrame[]} frames Array of frames to encode\n     * @param {object} spec An optional object that may provide values for `loops` and `colorScope`, as defined for the Gif class. However, `colorSpace` may also take the value Gif.GlobalColorsPreferred (== 0) to indicate that the encoder should attempt to create only a global color table. `loop` defaults to 0, looping indefinitely, and `colorScope` defaults to Gif.GlobalColorsPreferred.\n     * @return {Promise} A Promise that resolves to an instance of the Gif class, representing the encoded GIF.\n     * @throws {GifError} Error upon encountered an encoding-related problem with a GIF, so that the caller can distinguish between software errors and problems with GIFs.\n     */\n\n    encodeGif(frames, spec = {}) {\n        try {\n            if (frames === null || frames.length === 0) {\n                throw new GifError(\"there are no frames\");\n            }\n            const dims = GifUtil.getMaxDimensions(frames);\n\n            spec = Object.assign({}, spec); // don't munge caller's spec\n            spec.width = dims.maxWidth;\n            spec.height = dims.maxHeight;\n            spec.loops = spec.loops || 0;\n            spec.colorScope = spec.colorScope || Gif.GlobalColorsPreferred;\n\n            return Promise.resolve(this._encodeGif(frames, spec));\n        }\n        catch (err) {\n            return Promise.reject(err);\n        }\n    }\n\n    _decodeFrame(reader, frameIndex, alreadyUsedTransparency) {\n        let info, buffer;\n        try {\n            info = reader.frameInfo(frameIndex);\n            buffer = new Buffer(reader.width * reader.height * 4);\n            reader.decodeAndBlitFrameRGBA(frameIndex, buffer);\n            if (info.width !== reader.width || info.height !== reader.height) {\n                if (info.y) {\n                    // skip unused rows\n                    buffer = buffer.slice(info.y * reader.width * 4);\n                }\n                if (reader.width > info.width) {\n                    // skip scanstride\n                    for (let ii = 0; ii < info.height; ++ii) {\n                        buffer.copy(buffer, ii * info.width * 4,\n                            (info.x + ii * reader.width) * 4,\n                            (info.x + ii * reader.width) * 4 + info.width * 4);\n                    }\n                }\n                // trim buffer to size\n                buffer = buffer.slice(0, info.width * info.height * 4);\n            }\n        }\n        catch (err) {\n            throw new GifError(err);\n        }\n\n        let usesTransparency = false;\n        if (this._transparentRGBA === null) {\n            if (!alreadyUsedTransparency) {\n                for (let i = 3; i < buffer.length; i += 4) {\n                    if (buffer[i] === 0) {\n                        usesTransparency = true;\n                        i = buffer.length;\n                    }\n                }\n            }\n        }\n        else {\n            for (let i = 3; i < buffer.length; i += 4) {\n                if (buffer[i] === 0) {\n                    buffer.writeUInt32BE(this._transparentRGBA, i - 3);\n                    usesTransparency = true; // GIF might encode unused index\n                }\n            }\n        }\n\n        const frame = new GifFrame(info.width, info.height, buffer, {\n            xOffset: info.x,\n            yOffset: info.y,\n            disposalMethod: info.disposal,\n            interlaced: info.interlaced,\n            delayCentisecs: info.delay\n        });\n        return { frame, usesTransparency };\n    }\n\n    _encodeGif(frames, spec) {\n        let colorInfo;\n        if (spec.colorScope === Gif.LocalColorsOnly) {\n            colorInfo = GifUtil.getColorInfo(frames, 0);\n        }\n        else {\n            colorInfo = GifUtil.getColorInfo(frames, 256);\n            if (!colorInfo.colors) { // if global palette impossible\n                if (spec.colorScope === Gif.GlobalColorsOnly) {\n                    throw new GifError(\n                            \"Too many color indexes for global color table\");\n                }\n                spec.colorScope = Gif.LocalColorsOnly\n            }\n        }\n        spec.usesTransparency = colorInfo.usesTransparency;\n\n        const localPalettes = colorInfo.palettes;\n        if (spec.colorScope === Gif.LocalColorsOnly) {\n            const localSizeEst = 2000; //this._getSizeEstimateLocal(localPalettes, frames);\n            return _encodeLocal(frames, spec, localSizeEst, localPalettes);\n        }\n\n        const globalSizeEst = 2000; //this._getSizeEstimateGlobal(colorInfo, frames);\n        return _encodeGlobal(frames, spec, globalSizeEst, colorInfo);\n    }\n\n    _getSizeEstimateGlobal(globalPalette, frames) {\n        if (this._testInitialBufferSize > 0) {\n            return this._testInitialBufferSize;\n        }\n        let sizeEst = PER_GIF_OVERHEAD + 3*256 /* max palette size*/;\n        const pixelBitWidth = _getPixelBitWidth(globalPalette);\n        frames.forEach(frame => {\n            sizeEst += _getFrameSizeEst(frame, pixelBitWidth);\n        });\n        return sizeEst; // should be the upper limit\n    }\n\n    _getSizeEstimateLocal(palettes, frames) {\n        if (this._testInitialBufferSize > 0) {\n            return this._testInitialBufferSize;\n        }\n        let sizeEst = PER_GIF_OVERHEAD;\n        for (let i = 0; i < frames.length; ++i ) {\n            const palette = palettes[i];\n            const pixelBitWidth = _getPixelBitWidth(palette);\n            sizeEst += _getFrameSizeEst(frames[i], pixelBitWidth);\n        }\n        return sizeEst; // should be the upper limit\n    }\n}\nexports.GifCodec = GifCodec;\n\nfunction _colorLookupLinear(colors, color) {\n    const index = colors.indexOf(color);\n    return (index === -1 ? null : index);\n}\n\nfunction _colorLookupBinary(colors, color) {\n    // adapted from https://stackoverflow.com/a/10264318/650894\n    var lo = 0, hi = colors.length - 1, mid;\n    while (lo <= hi) {\n        mid = Math.floor((lo + hi)/2);\n        if (colors[mid] > color)\n            hi = mid - 1;\n        else if (colors[mid] < color)\n            lo = mid + 1;\n        else\n            return mid;\n    }\n    return null;\n}\n\nfunction _encodeGlobal(frames, spec, bufferSizeEst, globalPalette) {\n    // would be inefficient for frames to lookup colors in extended palette \n    const extendedGlobalPalette = {\n        colors: globalPalette.colors.slice(),\n        usesTransparency: globalPalette.usesTransparency\n    };\n    _extendPaletteToPowerOf2(extendedGlobalPalette);\n    const options = {\n        palette: extendedGlobalPalette.colors,\n        loop: spec.loops\n    };\n    let buffer = new Buffer(bufferSizeEst);\n    let gifWriter;\n    try {\n        gifWriter = new Omggif.GifWriter(buffer, spec.width, spec.height,\n                            options);\n    }\n    catch (err) {\n        throw new GifError(err);\n    }\n    for (let i = 0; i < frames.length; ++i) {\n        buffer = _writeFrame(gifWriter, i, frames[i], globalPalette, false);\n    }\n    return new Gif(buffer.slice(0, gifWriter.end()), frames, spec);\n}\n\nfunction _encodeLocal(frames, spec, bufferSizeEst, localPalettes) {\n    const options = {\n        loop: spec.loops\n    };\n    let buffer = new Buffer(bufferSizeEst);\n    let gifWriter;\n    try {\n        gifWriter = new Omggif.GifWriter(buffer, spec.width, spec.height,\n                            options);\n    }                            \n    catch (err) {\n        throw new GifError(err);\n    }\n    for (let i = 0; i < frames.length; ++i) {\n        buffer = _writeFrame(gifWriter, i, frames[i], localPalettes[i], true);\n    }\n    return new Gif(buffer.slice(0, gifWriter.end()), frames, spec);\n}\n\nfunction _extendPaletteToPowerOf2(palette) {\n    const colors = palette.colors;\n    if (palette.usesTransparency) {\n        colors.push(0);\n    }\n    const colorCount = colors.length;\n    let powerOf2 = 2;\n    while (colorCount > powerOf2) {\n        powerOf2 <<= 1;\n    }\n    colors.length = powerOf2;\n    colors.fill(0, colorCount);\n}\n\nfunction _getFrameSizeEst(frame, pixelBitWidth) {\n    let byteLength = frame.bitmap.width * frame.bitmap.height;\n    byteLength = Math.ceil(byteLength * pixelBitWidth / 8);\n    byteLength += Math.ceil(byteLength / 255); // add block size bytes\n    // assume maximum palete size because it might get extended for power of 2\n    return (PER_FRAME_OVERHEAD + byteLength + 3 * 256 /* largest palette */);\n}\n\nfunction _getIndexedImage(frameIndex, frame, palette) {\n    const colors = palette.colors;\n    const colorToIndexFunc = (colors.length <= 8 ? // guess at the break-even\n            _colorLookupLinear : _colorLookupBinary);\n    const colorBuffer = frame.bitmap.data;\n    const indexBuffer = new Buffer(colorBuffer.length/4);\n    let transparentIndex = colors.length;\n    let i = 0, j = 0;\n\n    while (i < colorBuffer.length) {\n        if (colorBuffer[i + 3] !== 0) {\n            const color = (colorBuffer.readUInt32BE(i, true) >> 8) & 0xFFFFFF;\n            // caller guarantees that the color will be in the palette\n            indexBuffer[j] = colorToIndexFunc(colors, color);\n        }\n        else {\n            indexBuffer[j] = transparentIndex;\n        }\n        i += 4; // skip alpha\n        ++j;\n    }\n\n    if (palette.usesTransparency) {\n        if (transparentIndex === 256) {\n            throw new GifError(`Frame ${frameIndex} already has 256 colors` +\n                    `and so can't use transparency`);\n        }\n    }\n    else {\n        transparentIndex = null;\n    }\n\n    return { buffer: indexBuffer, transparentIndex };\n}\n\nfunction _getPixelBitWidth(palette) {\n    let indexCount = palette.indexCount;\n    let pixelBitWidth = 0;\n    --indexCount; // start at maximum index\n    while (indexCount) {\n        ++pixelBitWidth;\n        indexCount >>= 1;\n    }\n    return (pixelBitWidth > 0 ? pixelBitWidth : 1);\n}\n\nfunction _writeFrame(gifWriter, frameIndex, frame, palette, isLocalPalette) {\n    if (frame.interlaced) {\n        throw new GifError(\"writing interlaced GIFs is not supported\");\n    }\n    const frameInfo = _getIndexedImage(frameIndex, frame, palette);\n    const options = {\n        delay: frame.delayCentisecs,\n        disposal: frame.disposalMethod,\n        transparent: frameInfo.transparentIndex\n    };\n    if (isLocalPalette) {\n        _extendPaletteToPowerOf2(palette); // ok 'cause palette never used again\n        options.palette = palette.colors;\n    }\n    try {\n        let buffer = gifWriter.getOutputBuffer();\n        let startOfFrame = gifWriter.getOutputBufferPosition();\n        let endOfFrame;\n        let tryAgain = true;\n\n        while (tryAgain) {\n            endOfFrame = gifWriter.addFrame(frame.xOffset, frame.yOffset,\n                    frame.bitmap.width, frame.bitmap.height, frameInfo.buffer, options);\n            tryAgain = false;\n            if (endOfFrame >= buffer.length - 1) {\n                const biggerBuffer = new Buffer(buffer.length * 1.5);\n                buffer.copy(biggerBuffer);\n                gifWriter.setOutputBuffer(biggerBuffer);\n                gifWriter.setOutputBufferPosition(startOfFrame);\n                buffer = biggerBuffer;\n                tryAgain = true;\n            }\n        }\n        return buffer;\n    }\n    catch (err) {\n        throw new GifError(err);\n    }\n}\n", "'use strict';\n\nconst BitmapImage = require('./bitmapimage');\nconst { Gif, GifError } = require('./gif');\nconst { GifCodec } = require('./gifcodec');\nconst { GifFrame } = require('./gifframe');\nconst GifUtil = require('./gifutil');\n\nmodule.exports = {\n    BitmapImage,\n    Gif,\n    GifCodec,\n    GifFrame,\n    GifUtil,\n    GifError\n};\n", "export default require(\"./node_modules/gifwrap/src/index.js\");"],
  "mappings": "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",
  "names": []
}
