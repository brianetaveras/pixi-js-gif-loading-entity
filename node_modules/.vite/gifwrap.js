import {
  fs_exports,
  init_fs
} from "./chunk-KT572D5I.js";
import {
  require_omggif
} from "./chunk-I6JQW2TB.js";
import {
  __commonJS
} from "./chunk-U3TMEWQO.js";

// node_modules/gifwrap/src/bitmapimage.js
var require_bitmapimage = __commonJS({
  "node_modules/gifwrap/src/bitmapimage.js"(exports, module) {
    "use strict";
    var BitmapImage = class {
      constructor(...args) {
        if (args.length === 0) {
          throw new Error("constructor requires parameters");
        }
        const firstArg = args[0];
        if (firstArg !== null && typeof firstArg === "object") {
          if (firstArg instanceof BitmapImage) {
            const sourceBitmap = firstArg.bitmap;
            this.bitmap = {
              width: sourceBitmap.width,
              height: sourceBitmap.height,
              data: new Buffer(sourceBitmap.width * sourceBitmap.height * 4)
            };
            sourceBitmap.data.copy(this.bitmap.data);
          } else if (firstArg.width && firstArg.height && firstArg.data) {
            this.bitmap = firstArg;
          } else {
            throw new Error("unrecognized constructor parameters");
          }
        } else if (typeof firstArg === "number" && typeof args[1] === "number") {
          const width = firstArg;
          const height = args[1];
          const thirdArg = args[2];
          this.bitmap = { width, height };
          if (Buffer.isBuffer(thirdArg)) {
            this.bitmap.data = thirdArg;
          } else {
            this.bitmap.data = new Buffer(width * height * 4);
            if (typeof thirdArg === "number") {
              this.fillRGBA(thirdArg);
            }
          }
        } else {
          throw new Error("unrecognized constructor parameters");
        }
      }
      blit(toImage, toX, toY, fromX, fromY, fromWidth, fromHeight) {
        if (fromX + fromWidth > this.bitmap.width) {
          throw new Error("copy exceeds width of source bitmap");
        }
        if (toX + fromWidth > toImage.bitmap.width) {
          throw new Error("copy exceeds width of target bitmap");
        }
        if (fromY + fromHeight > this.bitmap.height) {
          throw new Error("copy exceeds height of source bitmap");
        }
        if (toY + fromHeight > toImage.bitmap.height) {
          throw new Erro("copy exceeds height of target bitmap");
        }
        const sourceBuf = this.bitmap.data;
        const targetBuf = toImage.bitmap.data;
        const sourceByteWidth = this.bitmap.width * 4;
        const targetByteWidth = toImage.bitmap.width * 4;
        const copyByteWidth = fromWidth * 4;
        let si = fromY * sourceByteWidth + fromX * 4;
        let ti = toY * targetByteWidth + toX * 4;
        while (--fromHeight >= 0) {
          sourceBuf.copy(targetBuf, ti, si, si + copyByteWidth);
          si += sourceByteWidth;
          ti += targetByteWidth;
        }
        return this;
      }
      fillRGBA(rgba) {
        const buf = this.bitmap.data;
        const bufByteWidth = this.bitmap.height * 4;
        let bi = 0;
        while (bi < bufByteWidth) {
          buf.writeUInt32BE(rgba, bi);
          bi += 4;
        }
        while (bi < buf.length) {
          buf.copy(buf, bi, 0, bufByteWidth);
          bi += bufByteWidth;
        }
        return this;
      }
      getRGBA(x, y) {
        const bi = (y * this.bitmap.width + x) * 4;
        return this.bitmap.data.readUInt32BE(bi);
      }
      getRGBASet() {
        const rgbaSet = new Set();
        const buf = this.bitmap.data;
        for (let bi = 0; bi < buf.length; bi += 4) {
          rgbaSet.add(buf.readUInt32BE(bi, true));
        }
        return rgbaSet;
      }
      greyscale() {
        const buf = this.bitmap.data;
        this.scan(0, 0, this.bitmap.width, this.bitmap.height, (x, y, idx) => {
          const grey = Math.round(0.299 * buf[idx] + 0.587 * buf[idx + 1] + 0.114 * buf[idx + 2]);
          buf[idx] = grey;
          buf[idx + 1] = grey;
          buf[idx + 2] = grey;
        });
        return this;
      }
      reframe(xOffset, yOffset, width, height, fillRGBA) {
        const cropX = xOffset < 0 ? 0 : xOffset;
        const cropY = yOffset < 0 ? 0 : yOffset;
        const cropWidth = width + cropX > this.bitmap.width ? this.bitmap.width - cropX : width;
        const cropHeight = height + cropY > this.bitmap.height ? this.bitmap.height - cropY : height;
        const newX = xOffset < 0 ? -xOffset : 0;
        const newY = yOffset < 0 ? -yOffset : 0;
        let image;
        if (fillRGBA === void 0) {
          if (cropX !== xOffset || cropY != yOffset || cropWidth !== width || cropHeight !== height) {
            throw new GifError(`fillRGBA required for this reframing`);
          }
          image = new BitmapImage(width, height);
        } else {
          image = new BitmapImage(width, height, fillRGBA);
        }
        this.blit(image, newX, newY, cropX, cropY, cropWidth, cropHeight);
        this.bitmap = image.bitmap;
        return this;
      }
      scale(factor) {
        if (factor === 1) {
          return;
        }
        if (!Number.isInteger(factor) || factor < 1) {
          throw new Error("the scale must be an integer >= 1");
        }
        const sourceWidth = this.bitmap.width;
        const sourceHeight = this.bitmap.height;
        const destByteWidth = sourceWidth * factor * 4;
        const sourceBuf = this.bitmap.data;
        const destBuf = new Buffer(sourceHeight * destByteWidth * factor);
        let sourceIndex = 0;
        let priorDestRowIndex;
        let destIndex = 0;
        for (let y = 0; y < sourceHeight; ++y) {
          priorDestRowIndex = destIndex;
          for (let x = 0; x < sourceWidth; ++x) {
            const color = sourceBuf.readUInt32BE(sourceIndex, true);
            for (let cx = 0; cx < factor; ++cx) {
              destBuf.writeUInt32BE(color, destIndex);
              destIndex += 4;
            }
            sourceIndex += 4;
          }
          for (let cy = 1; cy < factor; ++cy) {
            destBuf.copy(destBuf, destIndex, priorDestRowIndex, destIndex);
            destIndex += destByteWidth;
            priorDestRowIndex += destByteWidth;
          }
        }
        this.bitmap = {
          width: sourceWidth * factor,
          height: sourceHeight * factor,
          data: destBuf
        };
        return this;
      }
      scanAllCoords(scanHandler) {
        const width = this.bitmap.width;
        const bufferLength = this.bitmap.data.length;
        let x = 0;
        let y = 0;
        for (let bi = 0; bi < bufferLength; bi += 4) {
          scanHandler(x, y, bi);
          if (++x === width) {
            x = 0;
            ++y;
          }
        }
      }
      scanAllIndexes(scanHandler) {
        const bufferLength = this.bitmap.data.length;
        for (let bi = 0; bi < bufferLength; bi += 4) {
          scanHandler(bi);
        }
      }
    };
    module.exports = BitmapImage;
  }
});

// node_modules/gifwrap/src/gif.js
var require_gif = __commonJS({
  "node_modules/gifwrap/src/gif.js"(exports) {
    "use strict";
    var Gif = class {
      constructor(buffer, frames, spec) {
        this.width = spec.width;
        this.height = spec.height;
        this.loops = spec.loops;
        this.usesTransparency = spec.usesTransparency;
        this.colorScope = spec.colorScope;
        this.frames = frames;
        this.buffer = buffer;
      }
    };
    Gif.GlobalColorsPreferred = 0;
    Gif.GlobalColorsOnly = 1;
    Gif.LocalColorsOnly = 2;
    var GifError2 = class extends Error {
      constructor(messageOrError) {
        super(messageOrError);
        if (messageOrError instanceof Error) {
          this.stack = "Gif" + messageOrError.stack;
        }
      }
    };
    exports.Gif = Gif;
    exports.GifError = GifError2;
  }
});

// node_modules/image-q/dist/iq.js
var require_iq = __commonJS({
  "node_modules/image-q/dist/iq.js"(exports, module) {
    (function webpackUniversalModuleDefinition(root, factory) {
      if (typeof exports === "object" && typeof module === "object")
        module.exports = factory();
      else if (typeof define === "function" && define.amd)
        define("iq", [], factory);
      else if (typeof exports === "object")
        exports["iq"] = factory();
      else
        root["iq"] = factory();
    })(exports, function() {
      return function(modules) {
        var installedModules = {};
        function __webpack_require__(moduleId) {
          if (installedModules[moduleId])
            return installedModules[moduleId].exports;
          var module2 = installedModules[moduleId] = {
            exports: {},
            id: moduleId,
            loaded: false
          };
          modules[moduleId].call(module2.exports, module2, module2.exports, __webpack_require__);
          module2.loaded = true;
          return module2.exports;
        }
        __webpack_require__.m = modules;
        __webpack_require__.c = installedModules;
        __webpack_require__.p = "";
        return __webpack_require__(0);
      }([
        function(module2, exports2, __webpack_require__) {
          "use strict";
          var constants = __webpack_require__(1);
          exports2.constants = constants;
          var conversion = __webpack_require__(3);
          exports2.conversion = conversion;
          var distance = __webpack_require__(12);
          exports2.distance = distance;
          var palette = __webpack_require__(20);
          exports2.palette = palette;
          var image = __webpack_require__(30);
          exports2.image = image;
          var quality = __webpack_require__(35);
          exports2.quality = quality;
          var utils = __webpack_require__(37);
          exports2.utils = utils;
        },
        function(module2, exports2, __webpack_require__) {
          "use strict";
          var bt709 = __webpack_require__(2);
          exports2.bt709 = bt709;
        },
        function(module2, exports2) {
          "use strict";
          var Y;
          (function(Y2) {
            Y2[Y2["RED"] = 0.2126] = "RED";
            Y2[Y2["GREEN"] = 0.7152] = "GREEN";
            Y2[Y2["BLUE"] = 0.0722] = "BLUE";
            Y2[Y2["WHITE"] = 1] = "WHITE";
          })(Y || (Y = {}));
          exports2.Y = Y;
          var x;
          (function(x2) {
            x2[x2["RED"] = 0.64] = "RED";
            x2[x2["GREEN"] = 0.3] = "GREEN";
            x2[x2["BLUE"] = 0.15] = "BLUE";
            x2[x2["WHITE"] = 0.3127] = "WHITE";
          })(x || (x = {}));
          exports2.x = x;
          var y;
          (function(y2) {
            y2[y2["RED"] = 0.33] = "RED";
            y2[y2["GREEN"] = 0.6] = "GREEN";
            y2[y2["BLUE"] = 0.06] = "BLUE";
            y2[y2["WHITE"] = 0.329] = "WHITE";
          })(y || (y = {}));
          exports2.y = y;
        },
        function(module2, exports2, __webpack_require__) {
          "use strict";
          var rgb2xyz_1 = __webpack_require__(4);
          exports2.rgb2xyz = rgb2xyz_1.rgb2xyz;
          var rgb2hsl_1 = __webpack_require__(5);
          exports2.rgb2hsl = rgb2hsl_1.rgb2hsl;
          var rgb2lab_1 = __webpack_require__(7);
          exports2.rgb2lab = rgb2lab_1.rgb2lab;
          var lab2xyz_1 = __webpack_require__(9);
          exports2.lab2xyz = lab2xyz_1.lab2xyz;
          var lab2rgb_1 = __webpack_require__(10);
          exports2.lab2rgb = lab2rgb_1.lab2rgb;
          var xyz2lab_1 = __webpack_require__(8);
          exports2.xyz2lab = xyz2lab_1.xyz2lab;
          var xyz2rgb_1 = __webpack_require__(11);
          exports2.xyz2rgb = xyz2rgb_1.xyz2rgb;
        },
        function(module2, exports2) {
          "use strict";
          function correctGamma(n) {
            return n > 0.04045 ? Math.pow((n + 0.055) / 1.055, 2.4) : n / 12.92;
          }
          function rgb2xyz(r, g, b) {
            r = correctGamma(r / 255);
            g = correctGamma(g / 255);
            b = correctGamma(b / 255);
            return {
              x: r * 0.4124 + g * 0.3576 + b * 0.1805,
              y: r * 0.2126 + g * 0.7152 + b * 0.0722,
              z: r * 0.0193 + g * 0.1192 + b * 0.9505
            };
          }
          exports2.rgb2xyz = rgb2xyz;
        },
        function(module2, exports2, __webpack_require__) {
          "use strict";
          var arithmetic_1 = __webpack_require__(6);
          function rgb2hsl(r, g, b) {
            var min = arithmetic_1.min3(r, g, b), max = arithmetic_1.max3(r, g, b), delta = max - min, l = (min + max) / 510;
            var s = 0;
            if (l > 0 && l < 1)
              s = delta / (l < 0.5 ? max + min : 510 - max - min);
            var h = 0;
            if (delta > 0) {
              if (max === r) {
                h = (g - b) / delta;
              } else if (max === g) {
                h = 2 + (b - r) / delta;
              } else {
                h = 4 + (r - g) / delta;
              }
              h *= 60;
              if (h < 0)
                h += 360;
            }
            return { h, s, l };
          }
          exports2.rgb2hsl = rgb2hsl;
        },
        function(module2, exports2) {
          "use strict";
          function degrees2radians(n) {
            return n * (Math.PI / 180);
          }
          exports2.degrees2radians = degrees2radians;
          function max3(a, b, c) {
            var m = a;
            m < b && (m = b);
            m < c && (m = c);
            return m;
          }
          exports2.max3 = max3;
          function min3(a, b, c) {
            var m = a;
            m > b && (m = b);
            m > c && (m = c);
            return m;
          }
          exports2.min3 = min3;
          function intInRange(value, low, high) {
            if (value > high)
              value = high;
            if (value < low)
              value = low;
            return value | 0;
          }
          exports2.intInRange = intInRange;
          function inRange0to255Rounded(n) {
            n = Math.round(n);
            if (n > 255)
              n = 255;
            else if (n < 0)
              n = 0;
            return n;
          }
          exports2.inRange0to255Rounded = inRange0to255Rounded;
          function inRange0to255(n) {
            if (n > 255)
              n = 255;
            else if (n < 0)
              n = 0;
            return n;
          }
          exports2.inRange0to255 = inRange0to255;
          function stableSort(arrayToSort, callback) {
            var type = typeof arrayToSort[0];
            var sorted;
            if (type === "number" || type === "string") {
              var ord_1 = Object.create(null);
              for (var i = 0, l = arrayToSort.length; i < l; i++) {
                var val = arrayToSort[i];
                if (ord_1[val] || ord_1[val] === 0)
                  continue;
                ord_1[val] = i;
              }
              sorted = arrayToSort.sort(function(a, b) {
                return callback(a, b) || ord_1[a] - ord_1[b];
              });
            } else {
              var ord2_1 = arrayToSort.slice(0);
              sorted = arrayToSort.sort(function(a, b) {
                return callback(a, b) || ord2_1.indexOf(a) - ord2_1.indexOf(b);
              });
            }
            return sorted;
          }
          exports2.stableSort = stableSort;
        },
        function(module2, exports2, __webpack_require__) {
          "use strict";
          var rgb2xyz_1 = __webpack_require__(4);
          var xyz2lab_1 = __webpack_require__(8);
          function rgb2lab(r, g, b) {
            var xyz = rgb2xyz_1.rgb2xyz(r, g, b);
            return xyz2lab_1.xyz2lab(xyz.x, xyz.y, xyz.z);
          }
          exports2.rgb2lab = rgb2lab;
        },
        function(module2, exports2) {
          "use strict";
          var refX = 0.95047, refY = 1, refZ = 1.08883;
          function pivot(n) {
            return n > 8856e-6 ? Math.pow(n, 1 / 3) : 7.787 * n + 16 / 116;
          }
          function xyz2lab(x, y, z) {
            x = pivot(x / refX);
            y = pivot(y / refY);
            z = pivot(z / refZ);
            if (116 * y - 16 < 0)
              throw new Error("xxx");
            return {
              L: Math.max(0, 116 * y - 16),
              a: 500 * (x - y),
              b: 200 * (y - z)
            };
          }
          exports2.xyz2lab = xyz2lab;
        },
        function(module2, exports2) {
          "use strict";
          var refX = 0.95047, refY = 1, refZ = 1.08883;
          function pivot(n) {
            return n > 0.206893034 ? Math.pow(n, 3) : (n - 16 / 116) / 7.787;
          }
          function lab2xyz(L, a, b) {
            var y = (L + 16) / 116, x = a / 500 + y, z = y - b / 200;
            return {
              x: refX * pivot(x),
              y: refY * pivot(y),
              z: refZ * pivot(z)
            };
          }
          exports2.lab2xyz = lab2xyz;
        },
        function(module2, exports2, __webpack_require__) {
          "use strict";
          var lab2xyz_1 = __webpack_require__(9);
          var xyz2rgb_1 = __webpack_require__(11);
          function lab2rgb(L, a, b) {
            var xyz = lab2xyz_1.lab2xyz(L, a, b);
            return xyz2rgb_1.xyz2rgb(xyz.x, xyz.y, xyz.z);
          }
          exports2.lab2rgb = lab2rgb;
        },
        function(module2, exports2, __webpack_require__) {
          "use strict";
          var arithmetic_1 = __webpack_require__(6);
          function correctGamma(n) {
            return n > 31308e-7 ? 1.055 * Math.pow(n, 1 / 2.4) - 0.055 : 12.92 * n;
          }
          function xyz2rgb(x, y, z) {
            var r = correctGamma(x * 3.2406 + y * -1.5372 + z * -0.4986), g = correctGamma(x * -0.9689 + y * 1.8758 + z * 0.0415), b = correctGamma(x * 0.0557 + y * -0.204 + z * 1.057);
            return {
              r: arithmetic_1.inRange0to255Rounded(r * 255),
              g: arithmetic_1.inRange0to255Rounded(g * 255),
              b: arithmetic_1.inRange0to255Rounded(b * 255)
            };
          }
          exports2.xyz2rgb = xyz2rgb;
        },
        function(module2, exports2, __webpack_require__) {
          "use strict";
          var abstractDistanceCalculator_1 = __webpack_require__(13);
          exports2.AbstractDistanceCalculator = abstractDistanceCalculator_1.AbstractDistanceCalculator;
          var cie94_1 = __webpack_require__(14);
          exports2.CIE94Textiles = cie94_1.CIE94Textiles;
          exports2.CIE94GraphicArts = cie94_1.CIE94GraphicArts;
          var ciede2000_1 = __webpack_require__(15);
          exports2.CIEDE2000 = ciede2000_1.CIEDE2000;
          var cmetric_1 = __webpack_require__(16);
          exports2.CMETRIC = cmetric_1.CMETRIC;
          var euclidean_1 = __webpack_require__(17);
          exports2.AbstractEuclidean = euclidean_1.AbstractEuclidean;
          exports2.Euclidean = euclidean_1.Euclidean;
          exports2.EuclideanRgbQuantWOAlpha = euclidean_1.EuclideanRgbQuantWOAlpha;
          exports2.EuclideanRgbQuantWithAlpha = euclidean_1.EuclideanRgbQuantWithAlpha;
          var manhattan_1 = __webpack_require__(18);
          exports2.AbstractManhattan = manhattan_1.AbstractManhattan;
          exports2.Manhattan = manhattan_1.Manhattan;
          exports2.ManhattanSRGB = manhattan_1.ManhattanSRGB;
          exports2.ManhattanNommyde = manhattan_1.ManhattanNommyde;
          var pngQuant_1 = __webpack_require__(19);
          exports2.PNGQUANT = pngQuant_1.PNGQUANT;
        },
        function(module2, exports2) {
          "use strict";
          var AbstractDistanceCalculator = function() {
            function AbstractDistanceCalculator2() {
              this._setDefaults();
              this.setWhitePoint(255, 255, 255, 255);
            }
            AbstractDistanceCalculator2.prototype.setWhitePoint = function(r, g, b, a) {
              this._whitePoint = {
                r: r > 0 ? 255 / r : 0,
                g: g > 0 ? 255 / g : 0,
                b: b > 0 ? 255 / b : 0,
                a: a > 0 ? 255 / a : 0
              };
              this._maxDistance = this.calculateRaw(r, g, b, a, 0, 0, 0, 0);
            };
            AbstractDistanceCalculator2.prototype.calculateNormalized = function(colorA, colorB) {
              return this.calculateRaw(colorA.r, colorA.g, colorA.b, colorA.a, colorB.r, colorB.g, colorB.b, colorB.a) / this._maxDistance;
            };
            AbstractDistanceCalculator2.prototype._setDefaults = function() {
            };
            return AbstractDistanceCalculator2;
          }();
          exports2.AbstractDistanceCalculator = AbstractDistanceCalculator;
        },
        function(module2, exports2, __webpack_require__) {
          "use strict";
          var __extends = this && this.__extends || function(d, b) {
            for (var p in b)
              if (b.hasOwnProperty(p))
                d[p] = b[p];
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
          var abstractDistanceCalculator_1 = __webpack_require__(13);
          var rgb2lab_1 = __webpack_require__(7);
          var arithmetic_1 = __webpack_require__(6);
          var AbstractCIE94 = function(_super) {
            __extends(AbstractCIE942, _super);
            function AbstractCIE942() {
              _super.apply(this, arguments);
            }
            AbstractCIE942.prototype.calculateRaw = function(r1, g1, b1, a1, r2, g2, b2, a2) {
              var lab1 = rgb2lab_1.rgb2lab(arithmetic_1.inRange0to255(r1 * this._whitePoint.r), arithmetic_1.inRange0to255(g1 * this._whitePoint.g), arithmetic_1.inRange0to255(b1 * this._whitePoint.b)), lab2 = rgb2lab_1.rgb2lab(arithmetic_1.inRange0to255(r2 * this._whitePoint.r), arithmetic_1.inRange0to255(g2 * this._whitePoint.g), arithmetic_1.inRange0to255(b2 * this._whitePoint.b));
              var dL = lab1.L - lab2.L, dA = lab1.a - lab2.a, dB = lab1.b - lab2.b, c1 = Math.sqrt(lab1.a * lab1.a + lab1.b * lab1.b), c2 = Math.sqrt(lab2.a * lab2.a + lab2.b * lab2.b), dC = c1 - c2;
              var deltaH = dA * dA + dB * dB - dC * dC;
              deltaH = deltaH < 0 ? 0 : Math.sqrt(deltaH);
              var dAlpha = (a2 - a1) * this._whitePoint.a * this._kA;
              return Math.sqrt(Math.pow(dL / this._Kl, 2) + Math.pow(dC / (1 + this._K1 * c1), 2) + Math.pow(deltaH / (1 + this._K2 * c1), 2) + Math.pow(dAlpha, 2));
            };
            return AbstractCIE942;
          }(abstractDistanceCalculator_1.AbstractDistanceCalculator);
          exports2.AbstractCIE94 = AbstractCIE94;
          var CIE94Textiles = function(_super) {
            __extends(CIE94Textiles2, _super);
            function CIE94Textiles2() {
              _super.apply(this, arguments);
            }
            CIE94Textiles2.prototype._setDefaults = function() {
              this._Kl = 2;
              this._K1 = 0.048;
              this._K2 = 0.014;
              this._kA = 0.25 * 50 / 255;
            };
            return CIE94Textiles2;
          }(AbstractCIE94);
          exports2.CIE94Textiles = CIE94Textiles;
          var CIE94GraphicArts = function(_super) {
            __extends(CIE94GraphicArts2, _super);
            function CIE94GraphicArts2() {
              _super.apply(this, arguments);
            }
            CIE94GraphicArts2.prototype._setDefaults = function() {
              this._Kl = 1;
              this._K1 = 0.045;
              this._K2 = 0.015;
              this._kA = 0.25 * 100 / 255;
            };
            return CIE94GraphicArts2;
          }(AbstractCIE94);
          exports2.CIE94GraphicArts = CIE94GraphicArts;
        },
        function(module2, exports2, __webpack_require__) {
          "use strict";
          var __extends = this && this.__extends || function(d, b) {
            for (var p in b)
              if (b.hasOwnProperty(p))
                d[p] = b[p];
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
          var abstractDistanceCalculator_1 = __webpack_require__(13);
          var rgb2lab_1 = __webpack_require__(7);
          var arithmetic_1 = __webpack_require__(6);
          var CIEDE2000 = function(_super) {
            __extends(CIEDE20002, _super);
            function CIEDE20002() {
              _super.apply(this, arguments);
            }
            CIEDE20002.prototype.calculateRaw = function(r1, g1, b1, a1, r2, g2, b2, a2) {
              var lab1 = rgb2lab_1.rgb2lab(arithmetic_1.inRange0to255(r1 * this._whitePoint.r), arithmetic_1.inRange0to255(g1 * this._whitePoint.g), arithmetic_1.inRange0to255(b1 * this._whitePoint.b)), lab2 = rgb2lab_1.rgb2lab(arithmetic_1.inRange0to255(r2 * this._whitePoint.r), arithmetic_1.inRange0to255(g2 * this._whitePoint.g), arithmetic_1.inRange0to255(b2 * this._whitePoint.b)), dA = (a2 - a1) * this._whitePoint.a * CIEDE20002._kA, dE2 = this.calculateRawInLab(lab1, lab2);
              return Math.sqrt(dE2 + dA * dA);
            };
            CIEDE20002.prototype.calculateRawInLab = function(Lab1, Lab2) {
              var L1 = Lab1.L, a1 = Lab1.a, b1 = Lab1.b;
              var L2 = Lab2.L, a2 = Lab2.a, b2 = Lab2.b;
              var C1 = Math.sqrt(a1 * a1 + b1 * b1), C2 = Math.sqrt(a2 * a2 + b2 * b2), pow_a_C1_C2_to_7 = Math.pow((C1 + C2) / 2, 7), G = 0.5 * (1 - Math.sqrt(pow_a_C1_C2_to_7 / (pow_a_C1_C2_to_7 + CIEDE20002._pow25to7))), a1p = (1 + G) * a1, a2p = (1 + G) * a2, C1p = Math.sqrt(a1p * a1p + b1 * b1), C2p = Math.sqrt(a2p * a2p + b2 * b2), C1pC2p = C1p * C2p, h1p = CIEDE20002._calculatehp(b1, a1p), h2p = CIEDE20002._calculatehp(b2, a2p), h_bar = Math.abs(h1p - h2p), dLp = L2 - L1, dCp = C2p - C1p, dHp = CIEDE20002._calculate_dHp(C1pC2p, h_bar, h2p, h1p), ahp = CIEDE20002._calculate_ahp(C1pC2p, h_bar, h1p, h2p), T = CIEDE20002._calculateT(ahp), aCp = (C1p + C2p) / 2, aLp_minus_50_square = Math.pow((L1 + L2) / 2 - 50, 2), S_L = 1 + 0.015 * aLp_minus_50_square / Math.sqrt(20 + aLp_minus_50_square), S_C = 1 + 0.045 * aCp, S_H = 1 + 0.015 * T * aCp, R_T = CIEDE20002._calculateRT(ahp, aCp), dLpSL = dLp / S_L, dCpSC = dCp / S_C, dHpSH = dHp / S_H;
              return Math.pow(dLpSL, 2) + Math.pow(dCpSC, 2) + Math.pow(dHpSH, 2) + R_T * dCpSC * dHpSH;
            };
            CIEDE20002._calculatehp = function(b, ap) {
              var hp = Math.atan2(b, ap);
              if (hp >= 0)
                return hp;
              return hp + CIEDE20002._deg360InRad;
            };
            CIEDE20002._calculateRT = function(ahp, aCp) {
              var aCp_to_7 = Math.pow(aCp, 7), R_C = 2 * Math.sqrt(aCp_to_7 / (aCp_to_7 + CIEDE20002._pow25to7)), delta_theta = CIEDE20002._deg30InRad * Math.exp(-Math.pow((ahp - CIEDE20002._deg275InRad) / CIEDE20002._deg25InRad, 2));
              return -Math.sin(2 * delta_theta) * R_C;
            };
            CIEDE20002._calculateT = function(ahp) {
              return 1 - 0.17 * Math.cos(ahp - CIEDE20002._deg30InRad) + 0.24 * Math.cos(ahp * 2) + 0.32 * Math.cos(ahp * 3 + CIEDE20002._deg6InRad) - 0.2 * Math.cos(ahp * 4 - CIEDE20002._deg63InRad);
            };
            CIEDE20002._calculate_ahp = function(C1pC2p, h_bar, h1p, h2p) {
              var hpSum = h1p + h2p;
              if (C1pC2p == 0)
                return hpSum;
              if (h_bar <= CIEDE20002._deg180InRad)
                return hpSum / 2;
              if (hpSum < CIEDE20002._deg360InRad)
                return (hpSum + CIEDE20002._deg360InRad) / 2;
              return (hpSum - CIEDE20002._deg360InRad) / 2;
            };
            CIEDE20002._calculate_dHp = function(C1pC2p, h_bar, h2p, h1p) {
              var dhp;
              if (C1pC2p == 0) {
                dhp = 0;
              } else if (h_bar <= CIEDE20002._deg180InRad) {
                dhp = h2p - h1p;
              } else if (h2p <= h1p) {
                dhp = h2p - h1p + CIEDE20002._deg360InRad;
              } else {
                dhp = h2p - h1p - CIEDE20002._deg360InRad;
              }
              return 2 * Math.sqrt(C1pC2p) * Math.sin(dhp / 2);
            };
            CIEDE20002._kA = 0.25 * 100 / 255;
            CIEDE20002._pow25to7 = Math.pow(25, 7);
            CIEDE20002._deg360InRad = arithmetic_1.degrees2radians(360);
            CIEDE20002._deg180InRad = arithmetic_1.degrees2radians(180);
            CIEDE20002._deg30InRad = arithmetic_1.degrees2radians(30);
            CIEDE20002._deg6InRad = arithmetic_1.degrees2radians(6);
            CIEDE20002._deg63InRad = arithmetic_1.degrees2radians(63);
            CIEDE20002._deg275InRad = arithmetic_1.degrees2radians(275);
            CIEDE20002._deg25InRad = arithmetic_1.degrees2radians(25);
            return CIEDE20002;
          }(abstractDistanceCalculator_1.AbstractDistanceCalculator);
          exports2.CIEDE2000 = CIEDE2000;
        },
        function(module2, exports2, __webpack_require__) {
          "use strict";
          var __extends = this && this.__extends || function(d, b) {
            for (var p in b)
              if (b.hasOwnProperty(p))
                d[p] = b[p];
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
          var abstractDistanceCalculator_1 = __webpack_require__(13);
          var CMETRIC = function(_super) {
            __extends(CMETRIC2, _super);
            function CMETRIC2() {
              _super.apply(this, arguments);
            }
            CMETRIC2.prototype.calculateRaw = function(r1, g1, b1, a1, r2, g2, b2, a2) {
              var rmean = (r1 + r2) / 2 * this._whitePoint.r, r = (r1 - r2) * this._whitePoint.r, g = (g1 - g2) * this._whitePoint.g, b = (b1 - b2) * this._whitePoint.b, dE = ((512 + rmean) * r * r >> 8) + 4 * g * g + ((767 - rmean) * b * b >> 8), dA = (a2 - a1) * this._whitePoint.a;
              return Math.sqrt(dE + dA * dA);
            };
            return CMETRIC2;
          }(abstractDistanceCalculator_1.AbstractDistanceCalculator);
          exports2.CMETRIC = CMETRIC;
        },
        function(module2, exports2, __webpack_require__) {
          "use strict";
          var __extends = this && this.__extends || function(d, b) {
            for (var p in b)
              if (b.hasOwnProperty(p))
                d[p] = b[p];
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
          var abstractDistanceCalculator_1 = __webpack_require__(13);
          var bt709_1 = __webpack_require__(2);
          var AbstractEuclidean = function(_super) {
            __extends(AbstractEuclidean2, _super);
            function AbstractEuclidean2() {
              _super.apply(this, arguments);
            }
            AbstractEuclidean2.prototype.calculateRaw = function(r1, g1, b1, a1, r2, g2, b2, a2) {
              var dR = r2 - r1, dG = g2 - g1, dB = b2 - b1, dA = a2 - a1;
              return Math.sqrt(this._kR * dR * dR + this._kG * dG * dG + this._kB * dB * dB + this._kA * dA * dA);
            };
            return AbstractEuclidean2;
          }(abstractDistanceCalculator_1.AbstractDistanceCalculator);
          exports2.AbstractEuclidean = AbstractEuclidean;
          var Euclidean = function(_super) {
            __extends(Euclidean2, _super);
            function Euclidean2() {
              _super.apply(this, arguments);
            }
            Euclidean2.prototype._setDefaults = function() {
              this._kR = 1;
              this._kG = 1;
              this._kB = 1;
              this._kA = 1;
            };
            return Euclidean2;
          }(AbstractEuclidean);
          exports2.Euclidean = Euclidean;
          var EuclideanRgbQuantWithAlpha = function(_super) {
            __extends(EuclideanRgbQuantWithAlpha2, _super);
            function EuclideanRgbQuantWithAlpha2() {
              _super.apply(this, arguments);
            }
            EuclideanRgbQuantWithAlpha2.prototype._setDefaults = function() {
              this._kR = bt709_1.Y.RED;
              this._kG = bt709_1.Y.GREEN;
              this._kB = bt709_1.Y.BLUE;
              this._kA = 1;
            };
            return EuclideanRgbQuantWithAlpha2;
          }(AbstractEuclidean);
          exports2.EuclideanRgbQuantWithAlpha = EuclideanRgbQuantWithAlpha;
          var EuclideanRgbQuantWOAlpha = function(_super) {
            __extends(EuclideanRgbQuantWOAlpha2, _super);
            function EuclideanRgbQuantWOAlpha2() {
              _super.apply(this, arguments);
            }
            EuclideanRgbQuantWOAlpha2.prototype._setDefaults = function() {
              this._kR = bt709_1.Y.RED;
              this._kG = bt709_1.Y.GREEN;
              this._kB = bt709_1.Y.BLUE;
              this._kA = 0;
            };
            return EuclideanRgbQuantWOAlpha2;
          }(AbstractEuclidean);
          exports2.EuclideanRgbQuantWOAlpha = EuclideanRgbQuantWOAlpha;
        },
        function(module2, exports2, __webpack_require__) {
          "use strict";
          var __extends = this && this.__extends || function(d, b) {
            for (var p in b)
              if (b.hasOwnProperty(p))
                d[p] = b[p];
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
          var abstractDistanceCalculator_1 = __webpack_require__(13);
          var bt709_1 = __webpack_require__(2);
          var AbstractManhattan = function(_super) {
            __extends(AbstractManhattan2, _super);
            function AbstractManhattan2() {
              _super.apply(this, arguments);
            }
            AbstractManhattan2.prototype.calculateRaw = function(r1, g1, b1, a1, r2, g2, b2, a2) {
              var dR = r2 - r1, dG = g2 - g1, dB = b2 - b1, dA = a2 - a1;
              if (dR < 0)
                dR = 0 - dR;
              if (dG < 0)
                dG = 0 - dG;
              if (dB < 0)
                dB = 0 - dB;
              if (dA < 0)
                dA = 0 - dA;
              return this._kR * dR + this._kG * dG + this._kB * dB + this._kA * dA;
            };
            return AbstractManhattan2;
          }(abstractDistanceCalculator_1.AbstractDistanceCalculator);
          exports2.AbstractManhattan = AbstractManhattan;
          var Manhattan = function(_super) {
            __extends(Manhattan2, _super);
            function Manhattan2() {
              _super.apply(this, arguments);
            }
            Manhattan2.prototype._setDefaults = function() {
              this._kR = 1;
              this._kG = 1;
              this._kB = 1;
              this._kA = 1;
            };
            return Manhattan2;
          }(AbstractManhattan);
          exports2.Manhattan = Manhattan;
          var ManhattanNommyde = function(_super) {
            __extends(ManhattanNommyde2, _super);
            function ManhattanNommyde2() {
              _super.apply(this, arguments);
            }
            ManhattanNommyde2.prototype._setDefaults = function() {
              this._kR = 0.4984;
              this._kG = 0.8625;
              this._kB = 0.2979;
              this._kA = 1;
            };
            return ManhattanNommyde2;
          }(AbstractManhattan);
          exports2.ManhattanNommyde = ManhattanNommyde;
          var ManhattanSRGB = function(_super) {
            __extends(ManhattanSRGB2, _super);
            function ManhattanSRGB2() {
              _super.apply(this, arguments);
            }
            ManhattanSRGB2.prototype._setDefaults = function() {
              this._kR = bt709_1.Y.RED;
              this._kG = bt709_1.Y.GREEN;
              this._kB = bt709_1.Y.BLUE;
              this._kA = 1;
            };
            return ManhattanSRGB2;
          }(AbstractManhattan);
          exports2.ManhattanSRGB = ManhattanSRGB;
        },
        function(module2, exports2, __webpack_require__) {
          "use strict";
          var __extends = this && this.__extends || function(d, b) {
            for (var p in b)
              if (b.hasOwnProperty(p))
                d[p] = b[p];
            function __() {
              this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
          };
          var abstractDistanceCalculator_1 = __webpack_require__(13);
          var PNGQUANT = function(_super) {
            __extends(PNGQUANT2, _super);
            function PNGQUANT2() {
              _super.apply(this, arguments);
            }
            PNGQUANT2.prototype.calculateRaw = function(r1, g1, b1, a1, r2, g2, b2, a2) {
              var alphas = (a2 - a1) * this._whitePoint.a;
              return this._colordifference_ch(r1 * this._whitePoint.r, r2 * this._whitePoint.r, alphas) + this._colordifference_ch(g1 * this._whitePoint.g, g2 * this._whitePoint.g, alphas) + this._colordifference_ch(b1 * this._whitePoint.b, b2 * this._whitePoint.b, alphas);
            };
            PNGQUANT2.prototype._colordifference_ch = function(x, y, alphas) {
              var black = x - y, white = black + alphas;
              return black * black + white * white;
            };
            return PNGQUANT2;
          }(abstractDistanceCalculator_1.AbstractDistanceCalculator);
          exports2.PNGQUANT = PNGQUANT;
        },
        function(module2, exports2, __webpack_require__) {
          "use strict";
          var neuquant_1 = __webpack_require__(21);
          exports2.NeuQuant = neuquant_1.NeuQuant;
          var neuquantFloat_1 = __webpack_require__(25);
          exports2.NeuQuantFloat = neuquantFloat_1.NeuQuantFloat;
          var rgbquant_1 = __webpack_require__(26);
          exports2.RGBQuant = rgbquant_1.RGBQuant;
          var colorHistogram_1 = __webpack_require__(27);
          exports2.ColorHistogram = colorHistogram_1.ColorHistogram;
          var wuQuant_1 = __webpack_require__(29);
          exports2.WuQuant = wuQuant_1.WuQuant;
          exports2.WuColorCube = wuQuant_1.WuColorCube;
        },
        function(module2, exports2, __webpack_require__) {
          "use strict";
          var palette_1 = __webpack_require__(22);
          var point_1 = __webpack_require__(24);
          var networkBiasShift = 3;
          var Neuron = function() {
            function Neuron2(defaultValue) {
              this.r = this.g = this.b = this.a = defaultValue;
            }
            Neuron2.prototype.toPoint = function() {
              return point_1.Point.createByRGBA(this.r >> networkBiasShift, this.g >> networkBiasShift, this.b >> networkBiasShift, this.a >> networkBiasShift);
            };
            Neuron2.prototype.subtract = function(r, g, b, a) {
              this.r -= r | 0;
              this.g -= g | 0;
              this.b -= b | 0;
              this.a -= a | 0;
            };
            return Neuron2;
          }();
          var NeuQuant = function() {
            function NeuQuant2(colorDistanceCalculator, colors) {
              if (colors === void 0) {
                colors = 256;
              }
              this._distance = colorDistanceCalculator;
              this._pointArray = [];
              this._sampleFactor = 1;
              this._networkSize = colors;
              this._distance.setWhitePoint(255 << networkBiasShift, 255 << networkBiasShift, 255 << networkBiasShift, 255 << networkBiasShift);
            }
            NeuQuant2.prototype.sample = function(pointBuffer) {
              this._pointArray = this._pointArray.concat(pointBuffer.getPointArray());
            };
            NeuQuant2.prototype.quantize = function() {
              this._init();
              this._learn();
              return this._buildPalette();
            };
            NeuQuant2.prototype._init = function() {
              this._freq = [];
              this._bias = [];
              this._radPower = [];
              this._network = [];
              for (var i = 0; i < this._networkSize; i++) {
                this._network[i] = new Neuron((i << networkBiasShift + 8) / this._networkSize | 0);
                this._freq[i] = NeuQuant2._initialBias / this._networkSize | 0;
                this._bias[i] = 0;
              }
            };
            NeuQuant2.prototype._learn = function() {
              var sampleFactor = this._sampleFactor;
              var pointsNumber = this._pointArray.length;
              if (pointsNumber < NeuQuant2._minpicturebytes)
                sampleFactor = 1;
              var alphadec = 30 + (sampleFactor - 1) / 3 | 0, pointsToSample = pointsNumber / sampleFactor | 0;
              var delta = pointsToSample / NeuQuant2._nCycles | 0, alpha = NeuQuant2._initAlpha, radius = (this._networkSize >> 3) * NeuQuant2._radiusBias;
              var rad = radius >> NeuQuant2._radiusBiasShift;
              if (rad <= 1)
                rad = 0;
              for (var i = 0; i < rad; i++) {
                this._radPower[i] = alpha * ((rad * rad - i * i) * NeuQuant2._radBias / (rad * rad)) >>> 0;
              }
              var step;
              if (pointsNumber < NeuQuant2._minpicturebytes) {
                step = 1;
              } else if (pointsNumber % NeuQuant2._prime1 != 0) {
                step = NeuQuant2._prime1;
              } else if (pointsNumber % NeuQuant2._prime2 != 0) {
                step = NeuQuant2._prime2;
              } else if (pointsNumber % NeuQuant2._prime3 != 0) {
                step = NeuQuant2._prime3;
              } else {
                step = NeuQuant2._prime4;
              }
              for (var i = 0, pointIndex = 0; i < pointsToSample; ) {
                var point = this._pointArray[pointIndex], b = point.b << networkBiasShift, g = point.g << networkBiasShift, r = point.r << networkBiasShift, a = point.a << networkBiasShift, neuronIndex = this._contest(b, g, r, a);
                this._alterSingle(alpha, neuronIndex, b, g, r, a);
                if (rad !== 0)
                  this._alterNeighbour(rad, neuronIndex, b, g, r, a);
                pointIndex += step;
                if (pointIndex >= pointsNumber)
                  pointIndex -= pointsNumber;
                i++;
                if (delta === 0)
                  delta = 1;
                if (i % delta === 0) {
                  alpha -= alpha / alphadec | 0;
                  radius -= radius / NeuQuant2._radiusDecrease | 0;
                  rad = radius >> NeuQuant2._radiusBiasShift;
                  if (rad <= 1)
                    rad = 0;
                  for (var j = 0; j < rad; j++)
                    this._radPower[j] = alpha * ((rad * rad - j * j) * NeuQuant2._radBias / (rad * rad)) >>> 0;
                }
              }
            };
            NeuQuant2.prototype._buildPalette = function() {
              var palette = new palette_1.Palette();
              this._network.forEach(function(neuron) {
                palette.add(neuron.toPoint());
              });
              palette.sort();
              return palette;
            };
            NeuQuant2.prototype._alterNeighbour = function(rad, i, b, g, r, al) {
              var lo = i - rad;
              if (lo < -1)
                lo = -1;
              var hi = i + rad;
              if (hi > this._networkSize)
                hi = this._networkSize;
              var j = i + 1, k = i - 1, m = 1;
              while (j < hi || k > lo) {
                var a = this._radPower[m++] / NeuQuant2._alphaRadBias;
                if (j < hi) {
                  var p = this._network[j++];
                  p.subtract(a * (p.r - r), a * (p.g - g), a * (p.b - b), a * (p.a - al));
                }
                if (k > lo) {
                  var p = this._network[k--];
                  p.subtract(a * (p.r - r), a * (p.g - g), a * (p.b - b), a * (p.a - al));
                }
              }
            };
            NeuQuant2.prototype._alterSingle = function(alpha, i, b, g, r, a) {
              alpha /= NeuQuant2._initAlpha;
              var n = this._network[i];
              n.subtract(alpha * (n.r - r), alpha * (n.g - g), alpha * (n.b - b), alpha * (n.a - a));
            };
            NeuQuant2.prototype._contest = function(b, g, r, a) {
              var multiplier = 255 * 4 << networkBiasShift;
              var bestd = ~(1 << 31), bestbiasd = bestd, bestpos = -1, bestbiaspos = bestpos;
              for (var i = 0; i < this._networkSize; i++) {
                var n = this._network[i], dist = this._distance.calculateNormalized(n, { r, g, b, a }) * multiplier | 0;
                if (dist < bestd) {
                  bestd = dist;
                  bestpos = i;
                }
                var biasdist = dist - (this._bias[i] >> NeuQuant2._initialBiasShift - networkBiasShift);
                if (biasdist < bestbiasd) {
                  bestbiasd = biasdist;
                  bestbiaspos = i;
                }
                var betafreq = this._freq[i] >> NeuQuant2._betaShift;
                this._freq[i] -= betafreq;
                this._bias[i] += betafreq << NeuQuant2._gammaShift;
              }
              this._freq[bestpos] += NeuQuant2._beta;
              this._bias[bestpos] -= NeuQuant2._betaGamma;
              return bestbiaspos;
            };
            NeuQuant2._prime1 = 499;
            NeuQuant2._prime2 = 491;
            NeuQuant2._prime3 = 487;
            NeuQuant2._prime4 = 503;
            NeuQuant2._minpicturebytes = NeuQuant2._prime4;
            NeuQuant2._nCycles = 100;
            NeuQuant2._initialBiasShift = 16;
            NeuQuant2._initialBias = 1 << NeuQuant2._initialBiasShift;
            NeuQuant2._gammaShift = 10;
            NeuQuant2._betaShift = 10;
            NeuQuant2._beta = NeuQuant2._initialBias >> NeuQuant2._betaShift;
            NeuQuant2._betaGamma = NeuQuant2._initialBias << NeuQuant2._gammaShift - NeuQuant2._betaShift;
            NeuQuant2._radiusBiasShift = 6;
            NeuQuant2._radiusBias = 1 << NeuQuant2._radiusBiasShift;
            NeuQuant2._radiusDecrease = 30;
            NeuQuant2._alphaBiasShift = 10;
            NeuQuant2._initAlpha = 1 << NeuQuant2._alphaBiasShift;
            NeuQuant2._radBiasShift = 8;
            NeuQuant2._radBias = 1 << NeuQuant2._radBiasShift;
            NeuQuant2._alphaRadBiasShift = NeuQuant2._alphaBiasShift + NeuQuant2._radBiasShift;
            NeuQuant2._alphaRadBias = 1 << NeuQuant2._alphaRadBiasShift;
            return NeuQuant2;
          }();
          exports2.NeuQuant = NeuQuant;
        },
        function(module2, exports2, __webpack_require__) {
          "use strict";
          var pointContainer_1 = __webpack_require__(23);
          var rgb2hsl_1 = __webpack_require__(5);
          var hueGroups = 10;
          function hueGroup(hue, segmentsNumber) {
            var maxHue = 360, seg = maxHue / segmentsNumber, half = seg / 2;
            for (var i = 1, mid = seg - half; i < segmentsNumber; i++, mid += seg) {
              if (hue >= mid && hue < mid + seg)
                return i;
            }
            return 0;
          }
          exports2.hueGroup = hueGroup;
          var Palette = function() {
            function Palette2() {
              this._pointArray = [];
              this._i32idx = {};
              this._pointContainer = new pointContainer_1.PointContainer();
              this._pointContainer.setHeight(1);
              this._pointArray = this._pointContainer.getPointArray();
            }
            Palette2.prototype.add = function(color) {
              this._pointArray.push(color);
              this._pointContainer.setWidth(this._pointArray.length);
            };
            Palette2.prototype.has = function(color) {
              for (var i = this._pointArray.length - 1; i >= 0; i--) {
                if (color.uint32 === this._pointArray[i].uint32)
                  return true;
              }
              return false;
            };
            Palette2.prototype.getNearestColor = function(colorDistanceCalculator, color) {
              return this._pointArray[this.getNearestIndex(colorDistanceCalculator, color) | 0];
            };
            Palette2.prototype.getPointContainer = function() {
              return this._pointContainer;
            };
            Palette2.prototype._nearestPointFromCache = function(key) {
              return typeof this._i32idx[key] === "number" ? this._i32idx[key] : -1;
            };
            Palette2.prototype.getNearestIndex = function(colorDistanceCalculator, point) {
              var idx = this._nearestPointFromCache("" + point.uint32);
              if (idx >= 0)
                return idx;
              var minimalDistance = Number.MAX_VALUE;
              idx = 0;
              for (var i = 0, l = this._pointArray.length; i < l; i++) {
                var p = this._pointArray[i], distance = colorDistanceCalculator.calculateRaw(point.r, point.g, point.b, point.a, p.r, p.g, p.b, p.a);
                if (distance < minimalDistance) {
                  minimalDistance = distance;
                  idx = i;
                }
              }
              this._i32idx[point.uint32] = idx;
              return idx;
            };
            Palette2.prototype.sort = function() {
              this._i32idx = {};
              this._pointArray.sort(function(a, b) {
                var hslA = rgb2hsl_1.rgb2hsl(a.r, a.g, a.b), hslB = rgb2hsl_1.rgb2hsl(b.r, b.g, b.b);
                var hueA = a.r === a.g && a.g === a.b ? 0 : 1 + hueGroup(hslA.h, hueGroups), hueB = b.r === b.g && b.g === b.b ? 0 : 1 + hueGroup(hslB.h, hueGroups);
                var hueDiff = hueB - hueA;
                if (hueDiff)
                  return -hueDiff;
                var lA = a.getLuminosity(true), lB = b.getLuminosity(true);
                if (lB - lA !== 0)
                  return lB - lA;
                var satDiff = (hslB.s * 100 | 0) - (hslA.s * 100 | 0);
                if (satDiff)
                  return -satDiff;
                return 0;
              });
            };
            return Palette2;
          }();
          exports2.Palette = Palette;
        },
        function(module2, exports2, __webpack_require__) {
          "use strict";
          var point_1 = __webpack_require__(24);
          var PointContainer = function() {
            function PointContainer2() {
              this._width = 0;
              this._height = 0;
              this._pointArray = [];
            }
            PointContainer2.prototype.getWidth = function() {
              return this._width;
            };
            PointContainer2.prototype.getHeight = function() {
              return this._height;
            };
            PointContainer2.prototype.setWidth = function(width) {
              this._width = width;
            };
            PointContainer2.prototype.setHeight = function(height) {
              this._height = height;
            };
            PointContainer2.prototype.getPointArray = function() {
              return this._pointArray;
            };
            PointContainer2.prototype.clone = function() {
              var clone = new PointContainer2();
              clone._width = this._width;
              clone._height = this._height;
              for (var i = 0, l = this._pointArray.length; i < l; i++) {
                clone._pointArray[i] = point_1.Point.createByUint32(this._pointArray[i].uint32 | 0);
              }
              return clone;
            };
            PointContainer2.prototype.toUint32Array = function() {
              var l = this._pointArray.length, uint32Array = new Uint32Array(l);
              for (var i = 0; i < l; i++) {
                uint32Array[i] = this._pointArray[i].uint32;
              }
              return uint32Array;
            };
            PointContainer2.prototype.toUint8Array = function() {
              return new Uint8Array(this.toUint32Array().buffer);
            };
            PointContainer2.fromHTMLImageElement = function(img) {
              var width = img.naturalWidth, height = img.naturalHeight;
              var canvas = document.createElement("canvas");
              canvas.width = width;
              canvas.height = height;
              var ctx = canvas.getContext("2d");
              ctx.drawImage(img, 0, 0, width, height, 0, 0, width, height);
              return PointContainer2.fromHTMLCanvasElement(canvas);
            };
            PointContainer2.fromHTMLCanvasElement = function(canvas) {
              var width = canvas.width, height = canvas.height;
              var ctx = canvas.getContext("2d"), imgData = ctx.getImageData(0, 0, width, height);
              return PointContainer2.fromImageData(imgData);
            };
            PointContainer2.fromNodeCanvas = function(canvas) {
              return PointContainer2.fromHTMLCanvasElement(canvas);
            };
            PointContainer2.fromImageData = function(imageData) {
              var width = imageData.width, height = imageData.height;
              return PointContainer2.fromCanvasPixelArray(imageData.data, width, height);
            };
            PointContainer2.fromArray = function(byteArray, width, height) {
              var uint8array = new Uint8Array(byteArray);
              return PointContainer2.fromUint8Array(uint8array, width, height);
            };
            PointContainer2.fromCanvasPixelArray = function(data, width, height) {
              return PointContainer2.fromArray(data, width, height);
            };
            PointContainer2.fromUint8Array = function(uint8array, width, height) {
              return PointContainer2.fromUint32Array(new Uint32Array(uint8array.buffer), width, height);
            };
            PointContainer2.fromUint32Array = function(uint32array, width, height) {
              var container = new PointContainer2();
              container._width = width;
              container._height = height;
              for (var i = 0, l = uint32array.length; i < l; i++) {
                container._pointArray[i] = point_1.Point.createByUint32(uint32array[i] | 0);
              }
              return container;
            };
            return PointContainer2;
          }();
          exports2.PointContainer = PointContainer;
        },
        function(module2, exports2, __webpack_require__) {
          "use strict";
          var bt709_1 = __webpack_require__(2);
          var Point = function() {
            function Point2() {
              this.uint32 = -1 >>> 0;
              this.r = this.g = this.b = this.a = 0;
              this.rgba = new Array(4);
              this.rgba[0] = 0;
              this.rgba[1] = 0;
              this.rgba[2] = 0;
              this.rgba[3] = 0;
            }
            Point2.createByQuadruplet = function(quadruplet) {
              var point = new Point2();
              point.r = quadruplet[0] | 0;
              point.g = quadruplet[1] | 0;
              point.b = quadruplet[2] | 0;
              point.a = quadruplet[3] | 0;
              point._loadUINT32();
              point._loadQuadruplet();
              return point;
            };
            Point2.createByRGBA = function(red, green, blue, alpha) {
              var point = new Point2();
              point.r = red | 0;
              point.g = green | 0;
              point.b = blue | 0;
              point.a = alpha | 0;
              point._loadUINT32();
              point._loadQuadruplet();
              return point;
            };
            Point2.createByUint32 = function(uint32) {
              var point = new Point2();
              point.uint32 = uint32 >>> 0;
              point._loadRGBA();
              point._loadQuadruplet();
              return point;
            };
            Point2.prototype.from = function(point) {
              this.r = point.r;
              this.g = point.g;
              this.b = point.b;
              this.a = point.a;
              this.uint32 = point.uint32;
              this.rgba[0] = point.r;
              this.rgba[1] = point.g;
              this.rgba[2] = point.b;
              this.rgba[3] = point.a;
            };
            Point2.prototype.getLuminosity = function(useAlphaChannel) {
              var r = this.r, g = this.g, b = this.b;
              if (useAlphaChannel) {
                r = Math.min(255, 255 - this.a + this.a * r / 255);
                g = Math.min(255, 255 - this.a + this.a * g / 255);
                b = Math.min(255, 255 - this.a + this.a * b / 255);
              }
              return r * bt709_1.Y.RED + g * bt709_1.Y.GREEN + b * bt709_1.Y.BLUE;
            };
            Point2.prototype._loadUINT32 = function() {
              this.uint32 = (this.a << 24 | this.b << 16 | this.g << 8 | this.r) >>> 0;
            };
            Point2.prototype._loadRGBA = function() {
              this.r = this.uint32 & 255;
              this.g = this.uint32 >>> 8 & 255;
              this.b = this.uint32 >>> 16 & 255;
              this.a = this.uint32 >>> 24 & 255;
            };
            Point2.prototype._loadQuadruplet = function() {
              this.rgba[0] = this.r;
              this.rgba[1] = this.g;
              this.rgba[2] = this.b;
              this.rgba[3] = this.a;
            };
            return Point2;
          }();
          exports2.Point = Point;
        },
        function(module2, exports2, __webpack_require__) {
          "use strict";
          var palette_1 = __webpack_require__(22);
          var point_1 = __webpack_require__(24);
          var networkBiasShift = 3;
          var NeuronFloat = function() {
            function NeuronFloat2(defaultValue) {
              this.r = this.g = this.b = this.a = defaultValue;
            }
            NeuronFloat2.prototype.toPoint = function() {
              return point_1.Point.createByRGBA(this.r >> networkBiasShift, this.g >> networkBiasShift, this.b >> networkBiasShift, this.a >> networkBiasShift);
            };
            NeuronFloat2.prototype.subtract = function(r, g, b, a) {
              this.r -= r;
              this.g -= g;
              this.b -= b;
              this.a -= a;
            };
            return NeuronFloat2;
          }();
          var NeuQuantFloat = function() {
            function NeuQuantFloat2(colorDistanceCalculator, colors) {
              if (colors === void 0) {
                colors = 256;
              }
              this._distance = colorDistanceCalculator;
              this._pointArray = [];
              this._sampleFactor = 1;
              this._networkSize = colors;
              this._distance.setWhitePoint(255 << networkBiasShift, 255 << networkBiasShift, 255 << networkBiasShift, 255 << networkBiasShift);
            }
            NeuQuantFloat2.prototype.sample = function(pointBuffer) {
              this._pointArray = this._pointArray.concat(pointBuffer.getPointArray());
            };
            NeuQuantFloat2.prototype.quantize = function() {
              this._init();
              this._learn();
              return this._buildPalette();
            };
            NeuQuantFloat2.prototype._init = function() {
              this._freq = [];
              this._bias = [];
              this._radPower = [];
              this._network = [];
              for (var i = 0; i < this._networkSize; i++) {
                this._network[i] = new NeuronFloat((i << networkBiasShift + 8) / this._networkSize);
                this._freq[i] = NeuQuantFloat2._initialBias / this._networkSize;
                this._bias[i] = 0;
              }
            };
            NeuQuantFloat2.prototype._learn = function() {
              var sampleFactor = this._sampleFactor;
              var pointsNumber = this._pointArray.length;
              if (pointsNumber < NeuQuantFloat2._minpicturebytes)
                sampleFactor = 1;
              var alphadec = 30 + (sampleFactor - 1) / 3, pointsToSample = pointsNumber / sampleFactor;
              var delta = pointsToSample / NeuQuantFloat2._nCycles | 0, alpha = NeuQuantFloat2._initAlpha, radius = (this._networkSize >> 3) * NeuQuantFloat2._radiusBias;
              var rad = radius >> NeuQuantFloat2._radiusBiasShift;
              if (rad <= 1)
                rad = 0;
              for (var i = 0; i < rad; i++) {
                this._radPower[i] = alpha * ((rad * rad - i * i) * NeuQuantFloat2._radBias / (rad * rad));
              }
              var step;
              if (pointsNumber < NeuQuantFloat2._minpicturebytes) {
                step = 1;
              } else if (pointsNumber % NeuQuantFloat2._prime1 != 0) {
                step = NeuQuantFloat2._prime1;
              } else if (pointsNumber % NeuQuantFloat2._prime2 != 0) {
                step = NeuQuantFloat2._prime2;
              } else if (pointsNumber % NeuQuantFloat2._prime3 != 0) {
                step = NeuQuantFloat2._prime3;
              } else {
                step = NeuQuantFloat2._prime4;
              }
              for (var i = 0, pointIndex = 0; i < pointsToSample; ) {
                var point = this._pointArray[pointIndex], b = point.b << networkBiasShift, g = point.g << networkBiasShift, r = point.r << networkBiasShift, a = point.a << networkBiasShift, neuronIndex = this._contest(b, g, r, a);
                this._alterSingle(alpha, neuronIndex, b, g, r, a);
                if (rad != 0)
                  this._alterNeighbour(rad, neuronIndex, b, g, r, a);
                pointIndex += step;
                if (pointIndex >= pointsNumber)
                  pointIndex -= pointsNumber;
                i++;
                if (delta == 0)
                  delta = 1;
                if (i % delta == 0) {
                  alpha -= alpha / alphadec;
                  radius -= radius / NeuQuantFloat2._radiusDecrease;
                  rad = radius >> NeuQuantFloat2._radiusBiasShift;
                  if (rad <= 1)
                    rad = 0;
                  for (var j = 0; j < rad; j++)
                    this._radPower[j] = alpha * ((rad * rad - j * j) * NeuQuantFloat2._radBias / (rad * rad));
                }
              }
            };
            NeuQuantFloat2.prototype._buildPalette = function() {
              var palette = new palette_1.Palette();
              this._network.forEach(function(neuron) {
                palette.add(neuron.toPoint());
              });
              palette.sort();
              return palette;
            };
            NeuQuantFloat2.prototype._alterNeighbour = function(rad, i, b, g, r, al) {
              var lo = i - rad;
              if (lo < -1)
                lo = -1;
              var hi = i + rad;
              if (hi > this._networkSize)
                hi = this._networkSize;
              var j = i + 1, k = i - 1, m = 1;
              while (j < hi || k > lo) {
                var a = this._radPower[m++] / NeuQuantFloat2._alphaRadBias;
                if (j < hi) {
                  var p = this._network[j++];
                  p.subtract(a * (p.r - r), a * (p.g - g), a * (p.b - b), a * (p.a - al));
                }
                if (k > lo) {
                  var p = this._network[k--];
                  p.subtract(a * (p.r - r), a * (p.g - g), a * (p.b - b), a * (p.a - al));
                }
              }
            };
            NeuQuantFloat2.prototype._alterSingle = function(alpha, i, b, g, r, a) {
              alpha /= NeuQuantFloat2._initAlpha;
              var n = this._network[i];
              n.subtract(alpha * (n.r - r), alpha * (n.g - g), alpha * (n.b - b), alpha * (n.a - a));
            };
            NeuQuantFloat2.prototype._contest = function(b, g, r, al) {
              var multiplier = 255 * 4 << networkBiasShift;
              var bestd = ~(1 << 31), bestbiasd = bestd, bestpos = -1, bestbiaspos = bestpos;
              for (var i = 0; i < this._networkSize; i++) {
                var n = this._network[i], dist = this._distance.calculateNormalized(n, { r, g, b, a: al }) * multiplier;
                if (dist < bestd) {
                  bestd = dist;
                  bestpos = i;
                }
                var biasdist = dist - (this._bias[i] >> NeuQuantFloat2._initialBiasShift - networkBiasShift);
                if (biasdist < bestbiasd) {
                  bestbiasd = biasdist;
                  bestbiaspos = i;
                }
                var betafreq = this._freq[i] >> NeuQuantFloat2._betaShift;
                this._freq[i] -= betafreq;
                this._bias[i] += betafreq << NeuQuantFloat2._gammaShift;
              }
              this._freq[bestpos] += NeuQuantFloat2._beta;
              this._bias[bestpos] -= NeuQuantFloat2._betaGamma;
              return bestbiaspos;
            };
            NeuQuantFloat2._prime1 = 499;
            NeuQuantFloat2._prime2 = 491;
            NeuQuantFloat2._prime3 = 487;
            NeuQuantFloat2._prime4 = 503;
            NeuQuantFloat2._minpicturebytes = NeuQuantFloat2._prime4;
            NeuQuantFloat2._nCycles = 100;
            NeuQuantFloat2._initialBiasShift = 16;
            NeuQuantFloat2._initialBias = 1 << NeuQuantFloat2._initialBiasShift;
            NeuQuantFloat2._gammaShift = 10;
            NeuQuantFloat2._betaShift = 10;
            NeuQuantFloat2._beta = NeuQuantFloat2._initialBias >> NeuQuantFloat2._betaShift;
            NeuQuantFloat2._betaGamma = NeuQuantFloat2._initialBias << NeuQuantFloat2._gammaShift - NeuQuantFloat2._betaShift;
            NeuQuantFloat2._radiusBiasShift = 6;
            NeuQuantFloat2._radiusBias = 1 << NeuQuantFloat2._radiusBiasShift;
            NeuQuantFloat2._radiusDecrease = 30;
            NeuQuantFloat2._alphaBiasShift = 10;
            NeuQuantFloat2._initAlpha = 1 << NeuQuantFloat2._alphaBiasShift;
            NeuQuantFloat2._radBiasShift = 8;
            NeuQuantFloat2._radBias = 1 << NeuQuantFloat2._radBiasShift;
            NeuQuantFloat2._alphaRadBiasShift = NeuQuantFloat2._alphaBiasShift + NeuQuantFloat2._radBiasShift;
            NeuQuantFloat2._alphaRadBias = 1 << NeuQuantFloat2._alphaRadBiasShift;
            return NeuQuantFloat2;
          }();
          exports2.NeuQuantFloat = NeuQuantFloat;
        },
        function(module2, exports2, __webpack_require__) {
          "use strict";
          var palette_1 = __webpack_require__(22);
          var point_1 = __webpack_require__(24);
          var colorHistogram_1 = __webpack_require__(27);
          var arithmetic_1 = __webpack_require__(6);
          var RemovedColor = function() {
            function RemovedColor2(index, color, distance) {
              this.index = index;
              this.color = color;
              this.distance = distance;
            }
            return RemovedColor2;
          }();
          var RGBQuant = function() {
            function RGBQuant2(colorDistanceCalculator, colors, method) {
              if (colors === void 0) {
                colors = 256;
              }
              if (method === void 0) {
                method = 2;
              }
              this._distance = colorDistanceCalculator;
              this._colors = colors;
              this._histogram = new colorHistogram_1.ColorHistogram(method, colors);
              this._initialDistance = 0.01;
              this._distanceIncrement = 5e-3;
            }
            RGBQuant2.prototype.sample = function(image) {
              this._histogram.sample(image);
            };
            RGBQuant2.prototype.quantize = function() {
              var idxi32 = this._histogram.getImportanceSortedColorsIDXI32();
              if (idxi32.length === 0) {
                throw new Error("No colors in image");
              }
              var palette = this._buildPalette(idxi32);
              palette.sort();
              return palette;
            };
            RGBQuant2.prototype._buildPalette = function(idxi32) {
              var palette = new palette_1.Palette(), colorArray = palette.getPointContainer().getPointArray(), usageArray = new Array(idxi32.length);
              for (var i = 0; i < idxi32.length; i++) {
                colorArray.push(point_1.Point.createByUint32(idxi32[i]));
                usageArray[i] = 1;
              }
              var len = colorArray.length, memDist = [];
              var palLen = len, thold = this._initialDistance;
              while (palLen > this._colors) {
                memDist.length = 0;
                for (var i = 0; i < len; i++) {
                  if (usageArray[i] === 0)
                    continue;
                  var pxi = colorArray[i];
                  for (var j = i + 1; j < len; j++) {
                    if (usageArray[j] === 0)
                      continue;
                    var pxj = colorArray[j];
                    var dist = this._distance.calculateNormalized(pxi, pxj);
                    if (dist < thold) {
                      memDist.push(new RemovedColor(j, pxj, dist));
                      usageArray[j] = 0;
                      palLen--;
                    }
                  }
                }
                thold += palLen > this._colors * 3 ? this._initialDistance : this._distanceIncrement;
              }
              if (palLen < this._colors) {
                arithmetic_1.stableSort(memDist, function(a, b) {
                  return b.distance - a.distance;
                });
                var k = 0;
                while (palLen < this._colors && k < memDist.length) {
                  var removedColor = memDist[k];
                  usageArray[removedColor.index] = 1;
                  palLen++;
                  k++;
                }
              }
              var colors = colorArray.length;
              for (var colorIndex = colors - 1; colorIndex >= 0; colorIndex--) {
                if (usageArray[colorIndex] === 0) {
                  if (colorIndex !== colors - 1) {
                    colorArray[colorIndex] = colorArray[colors - 1];
                  }
                  --colors;
                }
              }
              colorArray.length = colors;
              return palette;
            };
            return RGBQuant2;
          }();
          exports2.RGBQuant = RGBQuant;
        },
        function(module2, exports2, __webpack_require__) {
          "use strict";
          var hueStatistics_1 = __webpack_require__(28);
          var arithmetic_1 = __webpack_require__(6);
          var ColorHistogram = function() {
            function ColorHistogram2(method, colors) {
              this._method = method;
              this._minHueCols = colors << 2;
              this._initColors = colors << 2;
              this._hueStats = new hueStatistics_1.HueStatistics(ColorHistogram2._hueGroups, this._minHueCols);
              this._histogram = Object.create(null);
            }
            ColorHistogram2.prototype.sample = function(pointBuffer) {
              switch (this._method) {
                case 1:
                  this._colorStats1D(pointBuffer);
                  break;
                case 2:
                  this._colorStats2D(pointBuffer);
                  break;
              }
            };
            ColorHistogram2.prototype.getImportanceSortedColorsIDXI32 = function() {
              var _this = this;
              var sorted = arithmetic_1.stableSort(Object.keys(this._histogram), function(a, b) {
                return _this._histogram[b] - _this._histogram[a];
              });
              if (sorted.length === 0) {
                return [];
              }
              var idxi32;
              switch (this._method) {
                case 1:
                  var initialColorsLimit = Math.min(sorted.length, this._initColors), last = sorted[initialColorsLimit - 1], freq = this._histogram[last];
                  idxi32 = sorted.slice(0, initialColorsLimit);
                  var pos = initialColorsLimit, len = sorted.length;
                  while (pos < len && this._histogram[sorted[pos]] == freq)
                    idxi32.push(sorted[pos++]);
                  this._hueStats.injectIntoArray(idxi32);
                  break;
                case 2:
                  idxi32 = sorted;
                  break;
                default:
                  throw new Error("Incorrect method");
              }
              return idxi32.map(function(v) {
                return +v;
              });
            };
            ColorHistogram2.prototype._colorStats1D = function(pointBuffer) {
              var histG = this._histogram, pointArray = pointBuffer.getPointArray(), len = pointArray.length;
              for (var i = 0; i < len; i++) {
                var col = pointArray[i].uint32;
                this._hueStats.check(col);
                if (col in histG)
                  histG[col]++;
                else
                  histG[col] = 1;
              }
            };
            ColorHistogram2.prototype._colorStats2D = function(pointBuffer) {
              var _this = this;
              var width = pointBuffer.getWidth(), height = pointBuffer.getHeight(), pointArray = pointBuffer.getPointArray();
              var boxW = ColorHistogram2._boxSize[0], boxH = ColorHistogram2._boxSize[1], area = boxW * boxH, boxes = this._makeBoxes(width, height, boxW, boxH), histG = this._histogram;
              boxes.forEach(function(box) {
                var effc = Math.round(box.w * box.h / area) * ColorHistogram2._boxPixels;
                if (effc < 2)
                  effc = 2;
                var histL = {};
                _this._iterateBox(box, width, function(i) {
                  var col = pointArray[i].uint32;
                  _this._hueStats.check(col);
                  if (col in histG)
                    histG[col]++;
                  else if (col in histL) {
                    if (++histL[col] >= effc)
                      histG[col] = histL[col];
                  } else
                    histL[col] = 1;
                });
              });
              this._hueStats.injectIntoDictionary(histG);
            };
            ColorHistogram2.prototype._iterateBox = function(bbox, wid, fn) {
              var b = bbox, i0 = b.y * wid + b.x, i1 = (b.y + b.h - 1) * wid + (b.x + b.w - 1), incr = wid - b.w + 1;
              var cnt = 0, i = i0;
              do {
                fn.call(this, i);
                i += ++cnt % b.w == 0 ? incr : 1;
              } while (i <= i1);
            };
            ColorHistogram2.prototype._makeBoxes = function(width, height, stepX, stepY) {
              var wrem = width % stepX, hrem = height % stepY, xend = width - wrem, yend = height - hrem, boxesArray = [];
              for (var y = 0; y < height; y += stepY)
                for (var x = 0; x < width; x += stepX)
                  boxesArray.push({ x, y, w: x == xend ? wrem : stepX, h: y == yend ? hrem : stepY });
              return boxesArray;
            };
            ColorHistogram2._boxSize = [64, 64];
            ColorHistogram2._boxPixels = 2;
            ColorHistogram2._hueGroups = 10;
            return ColorHistogram2;
          }();
          exports2.ColorHistogram = ColorHistogram;
        },
        function(module2, exports2, __webpack_require__) {
          "use strict";
          var rgb2hsl_1 = __webpack_require__(5);
          var palette_1 = __webpack_require__(22);
          var HueGroup = function() {
            function HueGroup2() {
              this.num = 0;
              this.cols = [];
            }
            return HueGroup2;
          }();
          var HueStatistics = function() {
            function HueStatistics2(numGroups, minCols) {
              this._numGroups = numGroups;
              this._minCols = minCols;
              this._stats = [];
              for (var i = 0; i <= numGroups; i++) {
                this._stats[i] = new HueGroup();
              }
              this._groupsFull = 0;
            }
            HueStatistics2.prototype.check = function(i32) {
              if (this._groupsFull == this._numGroups + 1) {
                this.check = function() {
                };
              }
              var r = i32 & 255, g = i32 >>> 8 & 255, b = i32 >>> 16 & 255, hg = r == g && g == b ? 0 : 1 + palette_1.hueGroup(rgb2hsl_1.rgb2hsl(r, g, b).h, this._numGroups), gr = this._stats[hg], min = this._minCols;
              gr.num++;
              if (gr.num > min)
                return;
              if (gr.num == min)
                this._groupsFull++;
              if (gr.num <= min)
                this._stats[hg].cols.push(i32);
            };
            HueStatistics2.prototype.injectIntoDictionary = function(histG) {
              for (var i = 0; i <= this._numGroups; i++) {
                if (this._stats[i].num <= this._minCols) {
                  this._stats[i].cols.forEach(function(col) {
                    if (!histG[col])
                      histG[col] = 1;
                    else
                      histG[col]++;
                  });
                }
              }
            };
            HueStatistics2.prototype.injectIntoArray = function(histG) {
              for (var i = 0; i <= this._numGroups; i++) {
                if (this._stats[i].num <= this._minCols) {
                  this._stats[i].cols.forEach(function(col) {
                    if (histG.indexOf(col) == -1)
                      histG.push(col);
                  });
                }
              }
            };
            return HueStatistics2;
          }();
          exports2.HueStatistics = HueStatistics;
        },
        function(module2, exports2, __webpack_require__) {
          "use strict";
          var palette_1 = __webpack_require__(22);
          var point_1 = __webpack_require__(24);
          function createArray1D(dimension1) {
            var a = [];
            for (var k = 0; k < dimension1; k++) {
              a[k] = 0;
            }
            return a;
          }
          function createArray4D(dimension1, dimension2, dimension3, dimension4) {
            var a = new Array(dimension1);
            for (var i = 0; i < dimension1; i++) {
              a[i] = new Array(dimension2);
              for (var j = 0; j < dimension2; j++) {
                a[i][j] = new Array(dimension3);
                for (var k = 0; k < dimension3; k++) {
                  a[i][j][k] = new Array(dimension4);
                  for (var l = 0; l < dimension4; l++) {
                    a[i][j][k][l] = 0;
                  }
                }
              }
            }
            return a;
          }
          function createArray3D(dimension1, dimension2, dimension3) {
            var a = new Array(dimension1);
            for (var i = 0; i < dimension1; i++) {
              a[i] = new Array(dimension2);
              for (var j = 0; j < dimension2; j++) {
                a[i][j] = new Array(dimension3);
                for (var k = 0; k < dimension3; k++) {
                  a[i][j][k] = 0;
                }
              }
            }
            return a;
          }
          function fillArray3D(a, dimension1, dimension2, dimension3, value) {
            for (var i = 0; i < dimension1; i++) {
              a[i] = [];
              for (var j = 0; j < dimension2; j++) {
                a[i][j] = [];
                for (var k = 0; k < dimension3; k++) {
                  a[i][j][k] = value;
                }
              }
            }
          }
          function fillArray1D(a, dimension1, value) {
            for (var i = 0; i < dimension1; i++) {
              a[i] = value;
            }
          }
          var WuColorCube = function() {
            function WuColorCube2() {
            }
            return WuColorCube2;
          }();
          exports2.WuColorCube = WuColorCube;
          var WuQuant = function() {
            function WuQuant2(colorDistanceCalculator, colors, significantBitsPerChannel) {
              if (colors === void 0) {
                colors = 256;
              }
              if (significantBitsPerChannel === void 0) {
                significantBitsPerChannel = 5;
              }
              this._distance = colorDistanceCalculator;
              this._setQuality(significantBitsPerChannel);
              this._initialize(colors);
            }
            WuQuant2.prototype.sample = function(image) {
              var pointArray = image.getPointArray();
              for (var i = 0, l = pointArray.length; i < l; i++) {
                this._addColor(pointArray[i]);
              }
              this._pixels = this._pixels.concat(pointArray);
            };
            WuQuant2.prototype.quantize = function() {
              this._preparePalette();
              var palette = new palette_1.Palette();
              for (var paletteIndex = 0; paletteIndex < this._colors; paletteIndex++) {
                if (this._sums[paletteIndex] > 0) {
                  var sum = this._sums[paletteIndex], r = this._reds[paletteIndex] / sum, g = this._greens[paletteIndex] / sum, b = this._blues[paletteIndex] / sum, a = this._alphas[paletteIndex] / sum;
                  var color = point_1.Point.createByRGBA(r | 0, g | 0, b | 0, a | 0);
                  palette.add(color);
                }
              }
              palette.sort();
              return palette;
            };
            WuQuant2.prototype._preparePalette = function() {
              this._calculateMoments();
              var next = 0, volumeVariance = createArray1D(this._colors);
              for (var cubeIndex = 1; cubeIndex < this._colors; ++cubeIndex) {
                if (this._cut(this._cubes[next], this._cubes[cubeIndex])) {
                  volumeVariance[next] = this._cubes[next].volume > 1 ? this._calculateVariance(this._cubes[next]) : 0;
                  volumeVariance[cubeIndex] = this._cubes[cubeIndex].volume > 1 ? this._calculateVariance(this._cubes[cubeIndex]) : 0;
                } else {
                  volumeVariance[next] = 0;
                  cubeIndex--;
                }
                next = 0;
                var temp = volumeVariance[0];
                for (var index = 1; index <= cubeIndex; ++index) {
                  if (volumeVariance[index] > temp) {
                    temp = volumeVariance[index];
                    next = index;
                  }
                }
                if (temp <= 0) {
                  this._colors = cubeIndex + 1;
                  break;
                }
              }
              var lookupRed = [], lookupGreen = [], lookupBlue = [], lookupAlpha = [];
              for (var k = 0; k < this._colors; ++k) {
                var weight = WuQuant2._volume(this._cubes[k], this._weights);
                if (weight > 0) {
                  lookupRed[k] = WuQuant2._volume(this._cubes[k], this._momentsRed) / weight | 0;
                  lookupGreen[k] = WuQuant2._volume(this._cubes[k], this._momentsGreen) / weight | 0;
                  lookupBlue[k] = WuQuant2._volume(this._cubes[k], this._momentsBlue) / weight | 0;
                  lookupAlpha[k] = WuQuant2._volume(this._cubes[k], this._momentsAlpha) / weight | 0;
                } else {
                  lookupRed[k] = 0;
                  lookupGreen[k] = 0;
                  lookupBlue[k] = 0;
                  lookupAlpha[k] = 0;
                }
              }
              this._reds = createArray1D(this._colors + 1);
              this._greens = createArray1D(this._colors + 1);
              this._blues = createArray1D(this._colors + 1);
              this._alphas = createArray1D(this._colors + 1);
              this._sums = createArray1D(this._colors + 1);
              for (var index = 0, l = this._pixels.length; index < l; index++) {
                var color = this._pixels[index];
                var match = -1;
                var bestMatch = match, bestDistance = Number.MAX_VALUE;
                for (var lookup = 0; lookup < this._colors; lookup++) {
                  var foundRed = lookupRed[lookup], foundGreen = lookupGreen[lookup], foundBlue = lookupBlue[lookup], foundAlpha = lookupAlpha[lookup];
                  var distance = this._distance.calculateRaw(foundRed, foundGreen, foundBlue, foundAlpha, color.r, color.g, color.b, color.a);
                  if (distance < bestDistance) {
                    bestDistance = distance;
                    bestMatch = lookup;
                  }
                }
                this._reds[bestMatch] += color.r;
                this._greens[bestMatch] += color.g;
                this._blues[bestMatch] += color.b;
                this._alphas[bestMatch] += color.a;
                this._sums[bestMatch]++;
              }
            };
            WuQuant2.prototype._addColor = function(color) {
              var bitsToRemove = 8 - this._significantBitsPerChannel, indexRed = (color.r >> bitsToRemove) + 1, indexGreen = (color.g >> bitsToRemove) + 1, indexBlue = (color.b >> bitsToRemove) + 1, indexAlpha = (color.a >> bitsToRemove) + 1;
              this._weights[indexAlpha][indexRed][indexGreen][indexBlue]++;
              this._momentsRed[indexAlpha][indexRed][indexGreen][indexBlue] += color.r;
              this._momentsGreen[indexAlpha][indexRed][indexGreen][indexBlue] += color.g;
              this._momentsBlue[indexAlpha][indexRed][indexGreen][indexBlue] += color.b;
              this._momentsAlpha[indexAlpha][indexRed][indexGreen][indexBlue] += color.a;
              this._moments[indexAlpha][indexRed][indexGreen][indexBlue] += this._table[color.r] + this._table[color.g] + this._table[color.b] + this._table[color.a];
            };
            WuQuant2.prototype._calculateMoments = function() {
              var area = [], areaRed = [], areaGreen = [], areaBlue = [], areaAlpha = [], area2 = [];
              var xarea = createArray3D(this._sideSize, this._sideSize, this._sideSize), xareaRed = createArray3D(this._sideSize, this._sideSize, this._sideSize), xareaGreen = createArray3D(this._sideSize, this._sideSize, this._sideSize), xareaBlue = createArray3D(this._sideSize, this._sideSize, this._sideSize), xareaAlpha = createArray3D(this._sideSize, this._sideSize, this._sideSize), xarea2 = createArray3D(this._sideSize, this._sideSize, this._sideSize);
              for (var alphaIndex = 1; alphaIndex <= this._alphaMaxSideIndex; ++alphaIndex) {
                fillArray3D(xarea, this._sideSize, this._sideSize, this._sideSize, 0);
                fillArray3D(xareaRed, this._sideSize, this._sideSize, this._sideSize, 0);
                fillArray3D(xareaGreen, this._sideSize, this._sideSize, this._sideSize, 0);
                fillArray3D(xareaBlue, this._sideSize, this._sideSize, this._sideSize, 0);
                fillArray3D(xareaAlpha, this._sideSize, this._sideSize, this._sideSize, 0);
                fillArray3D(xarea2, this._sideSize, this._sideSize, this._sideSize, 0);
                for (var redIndex = 1; redIndex <= this._maxSideIndex; ++redIndex) {
                  fillArray1D(area, this._sideSize, 0);
                  fillArray1D(areaRed, this._sideSize, 0);
                  fillArray1D(areaGreen, this._sideSize, 0);
                  fillArray1D(areaBlue, this._sideSize, 0);
                  fillArray1D(areaAlpha, this._sideSize, 0);
                  fillArray1D(area2, this._sideSize, 0);
                  for (var greenIndex = 1; greenIndex <= this._maxSideIndex; ++greenIndex) {
                    var line = 0, lineRed = 0, lineGreen = 0, lineBlue = 0, lineAlpha = 0, line2 = 0;
                    for (var blueIndex = 1; blueIndex <= this._maxSideIndex; ++blueIndex) {
                      line += this._weights[alphaIndex][redIndex][greenIndex][blueIndex];
                      lineRed += this._momentsRed[alphaIndex][redIndex][greenIndex][blueIndex];
                      lineGreen += this._momentsGreen[alphaIndex][redIndex][greenIndex][blueIndex];
                      lineBlue += this._momentsBlue[alphaIndex][redIndex][greenIndex][blueIndex];
                      lineAlpha += this._momentsAlpha[alphaIndex][redIndex][greenIndex][blueIndex];
                      line2 += this._moments[alphaIndex][redIndex][greenIndex][blueIndex];
                      area[blueIndex] += line;
                      areaRed[blueIndex] += lineRed;
                      areaGreen[blueIndex] += lineGreen;
                      areaBlue[blueIndex] += lineBlue;
                      areaAlpha[blueIndex] += lineAlpha;
                      area2[blueIndex] += line2;
                      xarea[redIndex][greenIndex][blueIndex] = xarea[redIndex - 1][greenIndex][blueIndex] + area[blueIndex];
                      xareaRed[redIndex][greenIndex][blueIndex] = xareaRed[redIndex - 1][greenIndex][blueIndex] + areaRed[blueIndex];
                      xareaGreen[redIndex][greenIndex][blueIndex] = xareaGreen[redIndex - 1][greenIndex][blueIndex] + areaGreen[blueIndex];
                      xareaBlue[redIndex][greenIndex][blueIndex] = xareaBlue[redIndex - 1][greenIndex][blueIndex] + areaBlue[blueIndex];
                      xareaAlpha[redIndex][greenIndex][blueIndex] = xareaAlpha[redIndex - 1][greenIndex][blueIndex] + areaAlpha[blueIndex];
                      xarea2[redIndex][greenIndex][blueIndex] = xarea2[redIndex - 1][greenIndex][blueIndex] + area2[blueIndex];
                      this._weights[alphaIndex][redIndex][greenIndex][blueIndex] = this._weights[alphaIndex - 1][redIndex][greenIndex][blueIndex] + xarea[redIndex][greenIndex][blueIndex];
                      this._momentsRed[alphaIndex][redIndex][greenIndex][blueIndex] = this._momentsRed[alphaIndex - 1][redIndex][greenIndex][blueIndex] + xareaRed[redIndex][greenIndex][blueIndex];
                      this._momentsGreen[alphaIndex][redIndex][greenIndex][blueIndex] = this._momentsGreen[alphaIndex - 1][redIndex][greenIndex][blueIndex] + xareaGreen[redIndex][greenIndex][blueIndex];
                      this._momentsBlue[alphaIndex][redIndex][greenIndex][blueIndex] = this._momentsBlue[alphaIndex - 1][redIndex][greenIndex][blueIndex] + xareaBlue[redIndex][greenIndex][blueIndex];
                      this._momentsAlpha[alphaIndex][redIndex][greenIndex][blueIndex] = this._momentsAlpha[alphaIndex - 1][redIndex][greenIndex][blueIndex] + xareaAlpha[redIndex][greenIndex][blueIndex];
                      this._moments[alphaIndex][redIndex][greenIndex][blueIndex] = this._moments[alphaIndex - 1][redIndex][greenIndex][blueIndex] + xarea2[redIndex][greenIndex][blueIndex];
                    }
                  }
                }
              }
            };
            WuQuant2._volumeFloat = function(cube, moment) {
              return moment[cube.alphaMaximum][cube.redMaximum][cube.greenMaximum][cube.blueMaximum] - moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][cube.blueMaximum] - moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][cube.blueMaximum] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] - moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][cube.blueMaximum] + moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMaximum] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMaximum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] - (moment[cube.alphaMaximum][cube.redMaximum][cube.greenMaximum][cube.blueMinimum] - moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][cube.blueMinimum] - moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] - moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum]);
            };
            WuQuant2._volume = function(cube, moment) {
              return WuQuant2._volumeFloat(cube, moment) | 0;
            };
            WuQuant2._top = function(cube, direction, position, moment) {
              var result;
              switch (direction) {
                case WuQuant2.alpha:
                  result = moment[position][cube.redMaximum][cube.greenMaximum][cube.blueMaximum] - moment[position][cube.redMaximum][cube.greenMinimum][cube.blueMaximum] - moment[position][cube.redMinimum][cube.greenMaximum][cube.blueMaximum] + moment[position][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] - (moment[position][cube.redMaximum][cube.greenMaximum][cube.blueMinimum] - moment[position][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] - moment[position][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] + moment[position][cube.redMinimum][cube.greenMinimum][cube.blueMinimum]);
                  break;
                case WuQuant2.red:
                  result = moment[cube.alphaMaximum][position][cube.greenMaximum][cube.blueMaximum] - moment[cube.alphaMaximum][position][cube.greenMinimum][cube.blueMaximum] - moment[cube.alphaMinimum][position][cube.greenMaximum][cube.blueMaximum] + moment[cube.alphaMinimum][position][cube.greenMinimum][cube.blueMaximum] - (moment[cube.alphaMaximum][position][cube.greenMaximum][cube.blueMinimum] - moment[cube.alphaMaximum][position][cube.greenMinimum][cube.blueMinimum] - moment[cube.alphaMinimum][position][cube.greenMaximum][cube.blueMinimum] + moment[cube.alphaMinimum][position][cube.greenMinimum][cube.blueMinimum]);
                  break;
                case WuQuant2.green:
                  result = moment[cube.alphaMaximum][cube.redMaximum][position][cube.blueMaximum] - moment[cube.alphaMaximum][cube.redMinimum][position][cube.blueMaximum] - moment[cube.alphaMinimum][cube.redMaximum][position][cube.blueMaximum] + moment[cube.alphaMinimum][cube.redMinimum][position][cube.blueMaximum] - (moment[cube.alphaMaximum][cube.redMaximum][position][cube.blueMinimum] - moment[cube.alphaMaximum][cube.redMinimum][position][cube.blueMinimum] - moment[cube.alphaMinimum][cube.redMaximum][position][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMinimum][position][cube.blueMinimum]);
                  break;
                case WuQuant2.blue:
                  result = moment[cube.alphaMaximum][cube.redMaximum][cube.greenMaximum][position] - moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][position] - moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][position] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][position] - (moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][position] - moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][position] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][position] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][position]);
                  break;
                default:
                  throw new Error("impossible");
              }
              return result | 0;
            };
            WuQuant2._bottom = function(cube, direction, moment) {
              switch (direction) {
                case WuQuant2.alpha:
                  return -moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][cube.blueMaximum] + moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMaximum] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMaximum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] - (-moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum]);
                case WuQuant2.red:
                  return -moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][cube.blueMaximum] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMaximum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] - (-moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum]);
                case WuQuant2.green:
                  return -moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][cube.blueMaximum] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] + moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMaximum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] - (-moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum]);
                case WuQuant2.blue:
                  return -moment[cube.alphaMaximum][cube.redMaximum][cube.greenMaximum][cube.blueMinimum] + moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] - moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum] - (-moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum]);
                default:
                  return 0;
              }
            };
            WuQuant2.prototype._calculateVariance = function(cube) {
              var volumeRed = WuQuant2._volume(cube, this._momentsRed), volumeGreen = WuQuant2._volume(cube, this._momentsGreen), volumeBlue = WuQuant2._volume(cube, this._momentsBlue), volumeAlpha = WuQuant2._volume(cube, this._momentsAlpha), volumeMoment = WuQuant2._volumeFloat(cube, this._moments), volumeWeight = WuQuant2._volume(cube, this._weights), distance = volumeRed * volumeRed + volumeGreen * volumeGreen + volumeBlue * volumeBlue + volumeAlpha * volumeAlpha;
              return volumeMoment - distance / volumeWeight;
            };
            WuQuant2.prototype._maximize = function(cube, direction, first, last, wholeRed, wholeGreen, wholeBlue, wholeAlpha, wholeWeight) {
              var bottomRed = WuQuant2._bottom(cube, direction, this._momentsRed) | 0, bottomGreen = WuQuant2._bottom(cube, direction, this._momentsGreen) | 0, bottomBlue = WuQuant2._bottom(cube, direction, this._momentsBlue) | 0, bottomAlpha = WuQuant2._bottom(cube, direction, this._momentsAlpha) | 0, bottomWeight = WuQuant2._bottom(cube, direction, this._weights) | 0;
              var result = 0, cutPosition = -1;
              for (var position = first; position < last; ++position) {
                var halfRed = bottomRed + WuQuant2._top(cube, direction, position, this._momentsRed), halfGreen = bottomGreen + WuQuant2._top(cube, direction, position, this._momentsGreen), halfBlue = bottomBlue + WuQuant2._top(cube, direction, position, this._momentsBlue), halfAlpha = bottomAlpha + WuQuant2._top(cube, direction, position, this._momentsAlpha), halfWeight = bottomWeight + WuQuant2._top(cube, direction, position, this._weights);
                if (halfWeight != 0) {
                  var halfDistance = halfRed * halfRed + halfGreen * halfGreen + halfBlue * halfBlue + halfAlpha * halfAlpha, temp = halfDistance / halfWeight;
                  halfRed = wholeRed - halfRed;
                  halfGreen = wholeGreen - halfGreen;
                  halfBlue = wholeBlue - halfBlue;
                  halfAlpha = wholeAlpha - halfAlpha;
                  halfWeight = wholeWeight - halfWeight;
                  if (halfWeight != 0) {
                    halfDistance = halfRed * halfRed + halfGreen * halfGreen + halfBlue * halfBlue + halfAlpha * halfAlpha;
                    temp += halfDistance / halfWeight;
                    if (temp > result) {
                      result = temp;
                      cutPosition = position;
                    }
                  }
                }
              }
              return { max: result, position: cutPosition };
            };
            WuQuant2.prototype._cut = function(first, second) {
              var direction;
              var wholeRed = WuQuant2._volume(first, this._momentsRed), wholeGreen = WuQuant2._volume(first, this._momentsGreen), wholeBlue = WuQuant2._volume(first, this._momentsBlue), wholeAlpha = WuQuant2._volume(first, this._momentsAlpha), wholeWeight = WuQuant2._volume(first, this._weights), red = this._maximize(first, WuQuant2.red, first.redMinimum + 1, first.redMaximum, wholeRed, wholeGreen, wholeBlue, wholeAlpha, wholeWeight), green = this._maximize(first, WuQuant2.green, first.greenMinimum + 1, first.greenMaximum, wholeRed, wholeGreen, wholeBlue, wholeAlpha, wholeWeight), blue = this._maximize(first, WuQuant2.blue, first.blueMinimum + 1, first.blueMaximum, wholeRed, wholeGreen, wholeBlue, wholeAlpha, wholeWeight), alpha = this._maximize(first, WuQuant2.alpha, first.alphaMinimum + 1, first.alphaMaximum, wholeRed, wholeGreen, wholeBlue, wholeAlpha, wholeWeight);
              if (alpha.max >= red.max && alpha.max >= green.max && alpha.max >= blue.max) {
                direction = WuQuant2.alpha;
                if (alpha.position < 0)
                  return false;
              } else {
                if (red.max >= alpha.max && red.max >= green.max && red.max >= blue.max) {
                  direction = WuQuant2.red;
                } else if (green.max >= alpha.max && green.max >= red.max && green.max >= blue.max) {
                  direction = WuQuant2.green;
                } else {
                  direction = WuQuant2.blue;
                }
              }
              second.redMaximum = first.redMaximum;
              second.greenMaximum = first.greenMaximum;
              second.blueMaximum = first.blueMaximum;
              second.alphaMaximum = first.alphaMaximum;
              switch (direction) {
                case WuQuant2.red:
                  second.redMinimum = first.redMaximum = red.position;
                  second.greenMinimum = first.greenMinimum;
                  second.blueMinimum = first.blueMinimum;
                  second.alphaMinimum = first.alphaMinimum;
                  break;
                case WuQuant2.green:
                  second.greenMinimum = first.greenMaximum = green.position;
                  second.redMinimum = first.redMinimum;
                  second.blueMinimum = first.blueMinimum;
                  second.alphaMinimum = first.alphaMinimum;
                  break;
                case WuQuant2.blue:
                  second.blueMinimum = first.blueMaximum = blue.position;
                  second.redMinimum = first.redMinimum;
                  second.greenMinimum = first.greenMinimum;
                  second.alphaMinimum = first.alphaMinimum;
                  break;
                case WuQuant2.alpha:
                  second.alphaMinimum = first.alphaMaximum = alpha.position;
                  second.blueMinimum = first.blueMinimum;
                  second.redMinimum = first.redMinimum;
                  second.greenMinimum = first.greenMinimum;
                  break;
              }
              first.volume = (first.redMaximum - first.redMinimum) * (first.greenMaximum - first.greenMinimum) * (first.blueMaximum - first.blueMinimum) * (first.alphaMaximum - first.alphaMinimum);
              second.volume = (second.redMaximum - second.redMinimum) * (second.greenMaximum - second.greenMinimum) * (second.blueMaximum - second.blueMinimum) * (second.alphaMaximum - second.alphaMinimum);
              return true;
            };
            WuQuant2.prototype._initialize = function(colors) {
              this._colors = colors;
              this._cubes = [];
              for (var cubeIndex = 0; cubeIndex < colors; cubeIndex++) {
                this._cubes[cubeIndex] = new WuColorCube();
              }
              this._cubes[0].redMinimum = 0;
              this._cubes[0].greenMinimum = 0;
              this._cubes[0].blueMinimum = 0;
              this._cubes[0].alphaMinimum = 0;
              this._cubes[0].redMaximum = this._maxSideIndex;
              this._cubes[0].greenMaximum = this._maxSideIndex;
              this._cubes[0].blueMaximum = this._maxSideIndex;
              this._cubes[0].alphaMaximum = this._alphaMaxSideIndex;
              this._weights = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize);
              this._momentsRed = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize);
              this._momentsGreen = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize);
              this._momentsBlue = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize);
              this._momentsAlpha = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize);
              this._moments = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize);
              this._table = [];
              for (var tableIndex = 0; tableIndex < 256; ++tableIndex) {
                this._table[tableIndex] = tableIndex * tableIndex;
              }
              this._pixels = [];
            };
            WuQuant2.prototype._setQuality = function(significantBitsPerChannel) {
              if (significantBitsPerChannel === void 0) {
                significantBitsPerChannel = 5;
              }
              this._significantBitsPerChannel = significantBitsPerChannel;
              this._maxSideIndex = 1 << this._significantBitsPerChannel;
              this._alphaMaxSideIndex = this._maxSideIndex;
              this._sideSize = this._maxSideIndex + 1;
              this._alphaSideSize = this._alphaMaxSideIndex + 1;
            };
            WuQuant2.alpha = 3;
            WuQuant2.red = 2;
            WuQuant2.green = 1;
            WuQuant2.blue = 0;
            return WuQuant2;
          }();
          exports2.WuQuant = WuQuant;
        },
        function(module2, exports2, __webpack_require__) {
          "use strict";
          var nearestColor_1 = __webpack_require__(31);
          exports2.NearestColor = nearestColor_1.NearestColor;
          var array_1 = __webpack_require__(32);
          exports2.ErrorDiffusionArray = array_1.ErrorDiffusionArray;
          exports2.ErrorDiffusionArrayKernel = array_1.ErrorDiffusionArrayKernel;
          var riemersma_1 = __webpack_require__(33);
          exports2.ErrorDiffusionRiemersma = riemersma_1.ErrorDiffusionRiemersma;
        },
        function(module2, exports2) {
          "use strict";
          var NearestColor = function() {
            function NearestColor2(colorDistanceCalculator) {
              this._distance = colorDistanceCalculator;
            }
            NearestColor2.prototype.quantize = function(pointBuffer, palette) {
              var pointArray = pointBuffer.getPointArray(), width = pointBuffer.getWidth(), height = pointBuffer.getHeight();
              for (var y = 0; y < height; y++) {
                for (var x = 0, idx = y * width; x < width; x++, idx++) {
                  var point = pointArray[idx];
                  point.from(palette.getNearestColor(this._distance, point));
                }
              }
              return pointBuffer;
            };
            return NearestColor2;
          }();
          exports2.NearestColor = NearestColor;
        },
        function(module2, exports2, __webpack_require__) {
          "use strict";
          var point_1 = __webpack_require__(24);
          var arithmetic_1 = __webpack_require__(6);
          (function(ErrorDiffusionArrayKernel2) {
            ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2["FloydSteinberg"] = 0] = "FloydSteinberg";
            ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2["FalseFloydSteinberg"] = 1] = "FalseFloydSteinberg";
            ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2["Stucki"] = 2] = "Stucki";
            ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2["Atkinson"] = 3] = "Atkinson";
            ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2["Jarvis"] = 4] = "Jarvis";
            ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2["Burkes"] = 5] = "Burkes";
            ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2["Sierra"] = 6] = "Sierra";
            ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2["TwoSierra"] = 7] = "TwoSierra";
            ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2["SierraLite"] = 8] = "SierraLite";
          })(exports2.ErrorDiffusionArrayKernel || (exports2.ErrorDiffusionArrayKernel = {}));
          var ErrorDiffusionArrayKernel = exports2.ErrorDiffusionArrayKernel;
          var ErrorDiffusionArray = function() {
            function ErrorDiffusionArray2(colorDistanceCalculator, kernel, serpentine, minimumColorDistanceToDither, calculateErrorLikeGIMP) {
              if (serpentine === void 0) {
                serpentine = true;
              }
              if (minimumColorDistanceToDither === void 0) {
                minimumColorDistanceToDither = 0;
              }
              if (calculateErrorLikeGIMP === void 0) {
                calculateErrorLikeGIMP = false;
              }
              this._setKernel(kernel);
              this._distance = colorDistanceCalculator;
              this._minColorDistance = minimumColorDistanceToDither;
              this._serpentine = serpentine;
              this._calculateErrorLikeGIMP = calculateErrorLikeGIMP;
            }
            ErrorDiffusionArray2.prototype.quantize = function(pointBuffer, palette) {
              var pointArray = pointBuffer.getPointArray(), originalPoint = new point_1.Point(), width = pointBuffer.getWidth(), height = pointBuffer.getHeight(), errorLines = [];
              var dir = 1, maxErrorLines = 1;
              for (var i = 0; i < this._kernel.length; i++) {
                var kernelErrorLines = this._kernel[i][2] + 1;
                if (maxErrorLines < kernelErrorLines)
                  maxErrorLines = kernelErrorLines;
              }
              for (var i = 0; i < maxErrorLines; i++) {
                this._fillErrorLine(errorLines[i] = [], width);
              }
              for (var y = 0; y < height; y++) {
                if (this._serpentine)
                  dir = dir * -1;
                var lni = y * width, xStart = dir == 1 ? 0 : width - 1, xEnd = dir == 1 ? width : -1;
                this._fillErrorLine(errorLines[0], width);
                errorLines.push(errorLines.shift());
                var errorLine = errorLines[0];
                for (var x = xStart, idx = lni + xStart; x !== xEnd; x += dir, idx += dir) {
                  var point = pointArray[idx], error = errorLine[x];
                  originalPoint.from(point);
                  var correctedPoint = point_1.Point.createByRGBA(arithmetic_1.inRange0to255Rounded(point.r + error[0]), arithmetic_1.inRange0to255Rounded(point.g + error[1]), arithmetic_1.inRange0to255Rounded(point.b + error[2]), arithmetic_1.inRange0to255Rounded(point.a + error[3]));
                  var palettePoint = palette.getNearestColor(this._distance, correctedPoint);
                  point.from(palettePoint);
                  if (this._minColorDistance) {
                    var dist = this._distance.calculateNormalized(point, palettePoint);
                    if (dist < this._minColorDistance)
                      continue;
                  }
                  var er = void 0, eg = void 0, eb = void 0, ea = void 0;
                  if (this._calculateErrorLikeGIMP) {
                    er = correctedPoint.r - palettePoint.r;
                    eg = correctedPoint.g - palettePoint.g;
                    eb = correctedPoint.b - palettePoint.b;
                    ea = correctedPoint.a - palettePoint.a;
                  } else {
                    er = originalPoint.r - palettePoint.r;
                    eg = originalPoint.g - palettePoint.g;
                    eb = originalPoint.b - palettePoint.b;
                    ea = originalPoint.a - palettePoint.a;
                  }
                  var dStart = dir == 1 ? 0 : this._kernel.length - 1, dEnd = dir == 1 ? this._kernel.length : -1;
                  for (var i = dStart; i !== dEnd; i += dir) {
                    var x1 = this._kernel[i][1] * dir, y1 = this._kernel[i][2];
                    if (x1 + x >= 0 && x1 + x < width && y1 + y >= 0 && y1 + y < height) {
                      var d = this._kernel[i][0], e = errorLines[y1][x1 + x];
                      e[0] = e[0] + er * d;
                      e[1] = e[1] + eg * d;
                      e[2] = e[2] + eb * d;
                      e[3] = e[3] + ea * d;
                    }
                  }
                }
              }
              return pointBuffer;
            };
            ErrorDiffusionArray2.prototype._fillErrorLine = function(errorLine, width) {
              if (errorLine.length > width) {
                errorLine.length = width;
              }
              var l = errorLine.length;
              for (var i = 0; i < l; i++) {
                var error = errorLine[i];
                error[0] = error[1] = error[2] = error[3] = 0;
              }
              for (var i = l; i < width; i++) {
                errorLine[i] = [0, 0, 0, 0];
              }
            };
            ErrorDiffusionArray2.prototype._setKernel = function(kernel) {
              switch (kernel) {
                case ErrorDiffusionArrayKernel.FloydSteinberg:
                  this._kernel = [
                    [7 / 16, 1, 0],
                    [3 / 16, -1, 1],
                    [5 / 16, 0, 1],
                    [1 / 16, 1, 1]
                  ];
                  break;
                case ErrorDiffusionArrayKernel.FalseFloydSteinberg:
                  this._kernel = [
                    [3 / 8, 1, 0],
                    [3 / 8, 0, 1],
                    [2 / 8, 1, 1]
                  ];
                  break;
                case ErrorDiffusionArrayKernel.Stucki:
                  this._kernel = [
                    [8 / 42, 1, 0],
                    [4 / 42, 2, 0],
                    [2 / 42, -2, 1],
                    [4 / 42, -1, 1],
                    [8 / 42, 0, 1],
                    [4 / 42, 1, 1],
                    [2 / 42, 2, 1],
                    [1 / 42, -2, 2],
                    [2 / 42, -1, 2],
                    [4 / 42, 0, 2],
                    [2 / 42, 1, 2],
                    [1 / 42, 2, 2]
                  ];
                  break;
                case ErrorDiffusionArrayKernel.Atkinson:
                  this._kernel = [
                    [1 / 8, 1, 0],
                    [1 / 8, 2, 0],
                    [1 / 8, -1, 1],
                    [1 / 8, 0, 1],
                    [1 / 8, 1, 1],
                    [1 / 8, 0, 2]
                  ];
                  break;
                case ErrorDiffusionArrayKernel.Jarvis:
                  this._kernel = [
                    [7 / 48, 1, 0],
                    [5 / 48, 2, 0],
                    [3 / 48, -2, 1],
                    [5 / 48, -1, 1],
                    [7 / 48, 0, 1],
                    [5 / 48, 1, 1],
                    [3 / 48, 2, 1],
                    [1 / 48, -2, 2],
                    [3 / 48, -1, 2],
                    [5 / 48, 0, 2],
                    [3 / 48, 1, 2],
                    [1 / 48, 2, 2]
                  ];
                  break;
                case ErrorDiffusionArrayKernel.Burkes:
                  this._kernel = [
                    [8 / 32, 1, 0],
                    [4 / 32, 2, 0],
                    [2 / 32, -2, 1],
                    [4 / 32, -1, 1],
                    [8 / 32, 0, 1],
                    [4 / 32, 1, 1],
                    [2 / 32, 2, 1]
                  ];
                  break;
                case ErrorDiffusionArrayKernel.Sierra:
                  this._kernel = [
                    [5 / 32, 1, 0],
                    [3 / 32, 2, 0],
                    [2 / 32, -2, 1],
                    [4 / 32, -1, 1],
                    [5 / 32, 0, 1],
                    [4 / 32, 1, 1],
                    [2 / 32, 2, 1],
                    [2 / 32, -1, 2],
                    [3 / 32, 0, 2],
                    [2 / 32, 1, 2]
                  ];
                  break;
                case ErrorDiffusionArrayKernel.TwoSierra:
                  this._kernel = [
                    [4 / 16, 1, 0],
                    [3 / 16, 2, 0],
                    [1 / 16, -2, 1],
                    [2 / 16, -1, 1],
                    [3 / 16, 0, 1],
                    [2 / 16, 1, 1],
                    [1 / 16, 2, 1]
                  ];
                  break;
                case ErrorDiffusionArrayKernel.SierraLite:
                  this._kernel = [
                    [2 / 4, 1, 0],
                    [1 / 4, -1, 1],
                    [1 / 4, 0, 1]
                  ];
                  break;
                default:
                  throw new Error("ErrorDiffusionArray: unknown kernel = " + kernel);
              }
            };
            return ErrorDiffusionArray2;
          }();
          exports2.ErrorDiffusionArray = ErrorDiffusionArray;
        },
        function(module2, exports2, __webpack_require__) {
          "use strict";
          var hilbertCurve_1 = __webpack_require__(34);
          var point_1 = __webpack_require__(24);
          var arithmetic_1 = __webpack_require__(6);
          var ErrorDiffusionRiemersma = function() {
            function ErrorDiffusionRiemersma2(colorDistanceCalculator, errorQueueSize, errorPropagation) {
              if (errorQueueSize === void 0) {
                errorQueueSize = 16;
              }
              if (errorPropagation === void 0) {
                errorPropagation = 1;
              }
              this._distance = colorDistanceCalculator;
              this._errorPropagation = errorPropagation;
              this._errorQueueSize = errorQueueSize;
              this._max = this._errorQueueSize;
              this._createWeights();
            }
            ErrorDiffusionRiemersma2.prototype.quantize = function(pointBuffer, palette) {
              var _this = this;
              var curve = new hilbertCurve_1.HilbertCurveBase(), pointArray = pointBuffer.getPointArray(), width = pointBuffer.getWidth(), height = pointBuffer.getHeight(), errorQueue = [];
              var head = 0;
              for (var i = 0; i < this._errorQueueSize; i++) {
                errorQueue[i] = { r: 0, g: 0, b: 0, a: 0 };
              }
              curve.walk(width, height, function(x, y) {
                var p = pointArray[x + y * width];
                var r = p.r, g = p.g, b = p.b, a = p.a;
                for (var i2 = 0; i2 < _this._errorQueueSize; i2++) {
                  var weight = _this._weights[i2], e = errorQueue[(i2 + head) % _this._errorQueueSize];
                  r += e.r * weight;
                  g += e.g * weight;
                  b += e.b * weight;
                  a += e.a * weight;
                }
                var correctedPoint = point_1.Point.createByRGBA(arithmetic_1.inRange0to255Rounded(r), arithmetic_1.inRange0to255Rounded(g), arithmetic_1.inRange0to255Rounded(b), arithmetic_1.inRange0to255Rounded(a));
                var quantizedPoint = palette.getNearestColor(_this._distance, correctedPoint);
                head = (head + 1) % _this._errorQueueSize;
                var tail = (head + _this._errorQueueSize - 1) % _this._errorQueueSize;
                errorQueue[tail].r = p.r - quantizedPoint.r;
                errorQueue[tail].g = p.g - quantizedPoint.g;
                errorQueue[tail].b = p.b - quantizedPoint.b;
                errorQueue[tail].a = p.a - quantizedPoint.a;
                p.from(quantizedPoint);
              });
              return pointBuffer;
            };
            ErrorDiffusionRiemersma2.prototype._createWeights = function() {
              this._weights = [];
              var multiplier = Math.exp(Math.log(this._max) / (this._errorQueueSize - 1));
              for (var i = 0, next = 1; i < this._errorQueueSize; i++) {
                this._weights[i] = (next + 0.5 | 0) / this._max * this._errorPropagation;
                next *= multiplier;
              }
            };
            return ErrorDiffusionRiemersma2;
          }();
          exports2.ErrorDiffusionRiemersma = ErrorDiffusionRiemersma;
        },
        function(module2, exports2) {
          "use strict";
          var Direction;
          (function(Direction2) {
            Direction2[Direction2["NONE"] = 0] = "NONE";
            Direction2[Direction2["UP"] = 1] = "UP";
            Direction2[Direction2["LEFT"] = 2] = "LEFT";
            Direction2[Direction2["RIGHT"] = 3] = "RIGHT";
            Direction2[Direction2["DOWN"] = 4] = "DOWN";
          })(Direction || (Direction = {}));
          var HilbertCurveBase = function() {
            function HilbertCurveBase2() {
            }
            HilbertCurveBase2.prototype.walk = function(width, height, visitorCallback) {
              this._x = 0;
              this._y = 0;
              this._d = 0;
              this._width = width;
              this._height = height;
              this._callback = visitorCallback;
              var maxBound = Math.max(width, height);
              this._level = Math.log(maxBound) / Math.log(2) + 1 | 0;
              this._walkHilbert(Direction.UP);
              this._visit(Direction.NONE);
            };
            HilbertCurveBase2.prototype._walkHilbert = function(direction) {
              if (this._level < 1)
                return;
              this._level--;
              switch (direction) {
                case Direction.LEFT:
                  this._walkHilbert(Direction.UP);
                  this._visit(Direction.RIGHT);
                  this._walkHilbert(Direction.LEFT);
                  this._visit(Direction.DOWN);
                  this._walkHilbert(Direction.LEFT);
                  this._visit(Direction.LEFT);
                  this._walkHilbert(Direction.DOWN);
                  break;
                case Direction.RIGHT:
                  this._walkHilbert(Direction.DOWN);
                  this._visit(Direction.LEFT);
                  this._walkHilbert(Direction.RIGHT);
                  this._visit(Direction.UP);
                  this._walkHilbert(Direction.RIGHT);
                  this._visit(Direction.RIGHT);
                  this._walkHilbert(Direction.UP);
                  break;
                case Direction.UP:
                  this._walkHilbert(Direction.LEFT);
                  this._visit(Direction.DOWN);
                  this._walkHilbert(Direction.UP);
                  this._visit(Direction.RIGHT);
                  this._walkHilbert(Direction.UP);
                  this._visit(Direction.UP);
                  this._walkHilbert(Direction.RIGHT);
                  break;
                case Direction.DOWN:
                  this._walkHilbert(Direction.RIGHT);
                  this._visit(Direction.UP);
                  this._walkHilbert(Direction.DOWN);
                  this._visit(Direction.LEFT);
                  this._walkHilbert(Direction.DOWN);
                  this._visit(Direction.DOWN);
                  this._walkHilbert(Direction.LEFT);
                  break;
                default:
                  break;
              }
              this._level++;
            };
            HilbertCurveBase2.prototype._visit = function(direction) {
              if (this._x >= 0 && this._x < this._width && this._y >= 0 && this._y < this._height) {
                this._callback(this._x, this._y, this._d);
                this._d++;
              }
              switch (direction) {
                case Direction.LEFT:
                  this._x--;
                  break;
                case Direction.RIGHT:
                  this._x++;
                  break;
                case Direction.UP:
                  this._y--;
                  break;
                case Direction.DOWN:
                  this._y++;
                  break;
              }
            };
            return HilbertCurveBase2;
          }();
          exports2.HilbertCurveBase = HilbertCurveBase;
        },
        function(module2, exports2, __webpack_require__) {
          "use strict";
          var ssim_1 = __webpack_require__(36);
          exports2.SSIM = ssim_1.SSIM;
        },
        function(module2, exports2, __webpack_require__) {
          "use strict";
          var bt709_1 = __webpack_require__(2);
          var K1 = 0.01, K2 = 0.03;
          var SSIM = function() {
            function SSIM2() {
            }
            SSIM2.prototype.compare = function(image1, image2) {
              if (image1.getHeight() !== image2.getHeight() || image1.getWidth() !== image2.getWidth()) {
                throw new Error("Images have different sizes!");
              }
              var bitsPerComponent = 8, L = (1 << bitsPerComponent) - 1, c1 = Math.pow(K1 * L, 2), c2 = Math.pow(K2 * L, 2);
              var numWindows = 0, mssim = 0;
              this._iterate(image1, image2, function(lumaValues1, lumaValues2, averageLumaValue1, averageLumaValue2) {
                var sigxy = 0, sigsqx = 0, sigsqy = 0;
                for (var i = 0; i < lumaValues1.length; i++) {
                  sigsqx += Math.pow(lumaValues1[i] - averageLumaValue1, 2);
                  sigsqy += Math.pow(lumaValues2[i] - averageLumaValue2, 2);
                  sigxy += (lumaValues1[i] - averageLumaValue1) * (lumaValues2[i] - averageLumaValue2);
                }
                var numPixelsInWin = lumaValues1.length - 1;
                sigsqx /= numPixelsInWin;
                sigsqy /= numPixelsInWin;
                sigxy /= numPixelsInWin;
                var numerator = (2 * averageLumaValue1 * averageLumaValue2 + c1) * (2 * sigxy + c2), denominator = (Math.pow(averageLumaValue1, 2) + Math.pow(averageLumaValue2, 2) + c1) * (sigsqx + sigsqy + c2), ssim = numerator / denominator;
                mssim += ssim;
                numWindows++;
              });
              return mssim / numWindows;
            };
            SSIM2.prototype._iterate = function(image1, image2, callback) {
              var windowSize = 8, width = image1.getWidth(), height = image1.getHeight();
              for (var y = 0; y < height; y += windowSize) {
                for (var x = 0; x < width; x += windowSize) {
                  var windowWidth = Math.min(windowSize, width - x), windowHeight = Math.min(windowSize, height - y);
                  var lumaValues1 = this._calculateLumaValuesForWindow(image1, x, y, windowWidth, windowHeight), lumaValues2 = this._calculateLumaValuesForWindow(image2, x, y, windowWidth, windowHeight), averageLuma1 = this._calculateAverageLuma(lumaValues1), averageLuma2 = this._calculateAverageLuma(lumaValues2);
                  callback(lumaValues1, lumaValues2, averageLuma1, averageLuma2);
                }
              }
            };
            SSIM2.prototype._calculateLumaValuesForWindow = function(image, x, y, width, height) {
              var pointArray = image.getPointArray(), lumaValues = [];
              var counter = 0;
              for (var j = y; j < y + height; j++) {
                var offset = j * image.getWidth();
                for (var i = x; i < x + width; i++) {
                  var point = pointArray[offset + i];
                  lumaValues[counter] = point.r * bt709_1.Y.RED + point.g * bt709_1.Y.GREEN + point.b * bt709_1.Y.BLUE;
                  counter++;
                }
              }
              return lumaValues;
            };
            SSIM2.prototype._calculateAverageLuma = function(lumaValues) {
              var sumLuma = 0;
              for (var i = 0; i < lumaValues.length; i++) {
                sumLuma += lumaValues[i];
              }
              return sumLuma / lumaValues.length;
            };
            return SSIM2;
          }();
          exports2.SSIM = SSIM;
        },
        function(module2, exports2, __webpack_require__) {
          "use strict";
          var arithmetic = __webpack_require__(6);
          exports2.arithmetic = arithmetic;
          var hueStatistics_1 = __webpack_require__(28);
          exports2.HueStatistics = hueStatistics_1.HueStatistics;
          var palette_1 = __webpack_require__(22);
          exports2.Palette = palette_1.Palette;
          var point_1 = __webpack_require__(24);
          exports2.Point = point_1.Point;
          var pointContainer_1 = __webpack_require__(23);
          exports2.PointContainer = pointContainer_1.PointContainer;
        }
      ]);
    });
  }
});

// node_modules/gifwrap/src/gifframe.js
var require_gifframe = __commonJS({
  "node_modules/gifwrap/src/gifframe.js"(exports) {
    "use strict";
    var BitmapImage = require_bitmapimage();
    var { GifError: GifError2 } = require_gif();
    var GifFrame = class extends BitmapImage {
      constructor(...args) {
        super(...args);
        if (args[0] instanceof GifFrame) {
          const source = args[0];
          this.xOffset = source.xOffset;
          this.yOffset = source.yOffset;
          this.disposalMethod = source.disposalMethod;
          this.delayCentisecs = source.delayCentisecs;
          this.interlaced = source.interlaced;
        } else {
          const lastArg = args[args.length - 1];
          let options = {};
          if (typeof lastArg === "object" && !(lastArg instanceof BitmapImage)) {
            options = lastArg;
          }
          this.xOffset = options.xOffset || 0;
          this.yOffset = options.yOffset || 0;
          this.disposalMethod = options.disposalMethod !== void 0 ? options.disposalMethod : GifFrame.DisposeToBackgroundColor;
          this.delayCentisecs = options.delayCentisecs || 8;
          this.interlaced = options.interlaced || false;
        }
      }
      getPalette() {
        const colorSet = new Set();
        const buf = this.bitmap.data;
        let i = 0;
        let usesTransparency = false;
        while (i < buf.length) {
          if (buf[i + 3] === 0) {
            usesTransparency = true;
          } else {
            const color = buf.readUInt32BE(i, true) >> 8 & 16777215;
            colorSet.add(color);
          }
          i += 4;
        }
        const colors = new Array(colorSet.size);
        const iter = colorSet.values();
        for (i = 0; i < colors.length; ++i) {
          colors[i] = iter.next().value;
        }
        colors.sort((a, b) => a - b);
        let indexCount = colors.length;
        if (usesTransparency) {
          ++indexCount;
        }
        return { colors, usesTransparency, indexCount };
      }
    };
    GifFrame.DisposeToAnything = 0;
    GifFrame.DisposeNothing = 1;
    GifFrame.DisposeToBackgroundColor = 2;
    GifFrame.DisposeToPrevious = 3;
    exports.GifFrame = GifFrame;
  }
});

// node_modules/gifwrap/src/gifutil.js
var require_gifutil = __commonJS({
  "node_modules/gifwrap/src/gifutil.js"(exports) {
    "use strict";
    var fs = (init_fs(), fs_exports);
    var ImageQ = require_iq();
    var BitmapImage = require_bitmapimage();
    var { GifFrame } = require_gifframe();
    var { GifError: GifError2 } = require_gif();
    var { GifCodec } = require_gifcodec();
    var INVALID_SUFFIXES = [".jpg", ".jpeg", ".png", ".bmp"];
    var defaultCodec = new GifCodec();
    exports.cloneFrames = function(frames) {
      let clones = [];
      frames.forEach((frame) => {
        clones.push(new GifFrame(frame));
      });
      return clones;
    };
    exports.getColorInfo = function(frames, maxGlobalIndex) {
      let usesTransparency = false;
      const palettes = [];
      for (let i = 0; i < frames.length; ++i) {
        let palette = frames[i].getPalette();
        if (palette.usesTransparency) {
          usesTransparency = true;
        }
        if (palette.indexCount > 256) {
          throw new GifError2(`Frame ${i} uses more than 256 color indexes`);
        }
        palettes.push(palette);
      }
      if (maxGlobalIndex === 0) {
        return { usesTransparency, palettes };
      }
      const globalColorSet = new Set();
      palettes.forEach((palette) => {
        palette.colors.forEach((color) => {
          globalColorSet.add(color);
        });
      });
      let indexCount = globalColorSet.size;
      if (usesTransparency) {
        ++indexCount;
      }
      if (maxGlobalIndex && indexCount > maxGlobalIndex) {
        return { usesTransparency, palettes };
      }
      const colors = new Array(globalColorSet.size);
      const iter = globalColorSet.values();
      for (let i = 0; i < colors.length; ++i) {
        colors[i] = iter.next().value;
      }
      colors.sort((a, b) => a - b);
      return { colors, indexCount, usesTransparency, palettes };
    };
    exports.copyAsJimp = function(jimp, bitmapImageToCopy) {
      return exports.shareAsJimp(jimp, new BitmapImage(bitmapImageToCopy));
    };
    exports.getMaxDimensions = function(frames) {
      let maxWidth = 0, maxHeight = 0;
      frames.forEach((frame) => {
        const width = frame.xOffset + frame.bitmap.width;
        if (width > maxWidth) {
          maxWidth = width;
        }
        const height = frame.yOffset + frame.bitmap.height;
        if (height > maxHeight) {
          maxHeight = height;
        }
      });
      return { maxWidth, maxHeight };
    };
    exports.quantizeDekker = function(imageOrImages, maxColorIndexes, dither) {
      maxColorIndexes = maxColorIndexes || 256;
      _quantize(imageOrImages, "NeuQuantFloat", maxColorIndexes, 0, dither);
    };
    exports.quantizeSorokin = function(imageOrImages, maxColorIndexes, histogram, dither) {
      maxColorIndexes = maxColorIndexes || 256;
      histogram = histogram || "min-pop";
      let histogramID;
      switch (histogram) {
        case "min-pop":
          histogramID = 2;
          break;
        case "top-pop":
          histogramID = 1;
          break;
        default:
          throw new Error(`Invalid quantizeSorokin histogram '${histogram}'`);
      }
      _quantize(imageOrImages, "RGBQuant", maxColorIndexes, histogramID, dither);
    };
    exports.quantizeWu = function(imageOrImages, maxColorIndexes, significantBits, dither) {
      maxColorIndexes = maxColorIndexes || 256;
      significantBits = significantBits || 5;
      if (significantBits < 1 || significantBits > 8) {
        throw new Error("Invalid quantization quality");
      }
      _quantize(imageOrImages, "WuQuant", maxColorIndexes, significantBits, dither);
    };
    exports.read = function(source, decoder) {
      decoder = decoder || defaultCodec;
      if (Buffer.isBuffer(source)) {
        return decoder.decodeGif(source);
      }
      return _readBinary(source).then((buffer) => {
        return decoder.decodeGif(buffer);
      });
    };
    exports.shareAsJimp = function(jimp, bitmapImageToShare) {
      const jimpImage = new jimp(bitmapImageToShare.bitmap.width, bitmapImageToShare.bitmap.height, 0);
      jimpImage.bitmap.data = bitmapImageToShare.bitmap.data;
      return jimpImage;
    };
    exports.write = function(path, frames, spec, encoder) {
      encoder = encoder || defaultCodec;
      const matches = path.match(/\.[a-zA-Z]+$/);
      if (matches !== null && INVALID_SUFFIXES.includes(matches[0].toLowerCase())) {
        throw new Error(`GIF '${path}' has an unexpected suffix`);
      }
      return encoder.encodeGif(frames, spec).then((gif) => {
        return _writeBinary(path, gif.buffer).then(() => {
          return gif;
        });
      });
    };
    function _quantize(imageOrImages, method, maxColorIndexes, modifier, dither) {
      const images = Array.isArray(imageOrImages) ? imageOrImages : [imageOrImages];
      const ditherAlgs = [
        "FloydSteinberg",
        "FalseFloydSteinberg",
        "Stucki",
        "Atkinson",
        "Jarvis",
        "Burkes",
        "Sierra",
        "TwoSierra",
        "SierraLite"
      ];
      if (dither) {
        if (ditherAlgs.indexOf(dither.ditherAlgorithm) < 0) {
          throw new Error(`Invalid ditherAlgorithm '${dither.ditherAlgorithm}'`);
        }
        if (dither.serpentine === void 0) {
          dither.serpentine = true;
        }
        if (dither.minimumColorDistanceToDither === void 0) {
          dither.minimumColorDistanceToDither = 0;
        }
        if (dither.calculateErrorLikeGIMP === void 0) {
          dither.calculateErrorLikeGIMP = false;
        }
      }
      const distCalculator = new ImageQ.distance.Euclidean();
      const quantizer = new ImageQ.palette[method](distCalculator, maxColorIndexes, modifier);
      let imageMaker;
      if (dither) {
        imageMaker = new ImageQ.image.ErrorDiffusionArray(distCalculator, ImageQ.image.ErrorDiffusionArrayKernel[dither.ditherAlgorithm], dither.serpentine, dither.minimumColorDistanceToDither, dither.calculateErrorLikeGIMP);
      } else {
        imageMaker = new ImageQ.image.NearestColor(distCalculator);
      }
      const inputContainers = [];
      images.forEach((image) => {
        const imageBuf = image.bitmap.data;
        const inputBuf = new ArrayBuffer(imageBuf.length);
        const inputArray = new Uint32Array(inputBuf);
        for (let bi = 0, ai = 0; bi < imageBuf.length; bi += 4, ++ai) {
          inputArray[ai] = imageBuf.readUInt32LE(bi, true);
        }
        const inputContainer = ImageQ.utils.PointContainer.fromUint32Array(inputArray, image.bitmap.width, image.bitmap.height);
        quantizer.sample(inputContainer);
        inputContainers.push(inputContainer);
      });
      const limitedPalette = quantizer.quantize();
      for (let i = 0; i < images.length; ++i) {
        const imageBuf = images[i].bitmap.data;
        const outputContainer = imageMaker.quantize(inputContainers[i], limitedPalette);
        const outputArray = outputContainer.toUint32Array();
        for (let bi = 0, ai = 0; bi < imageBuf.length; bi += 4, ++ai) {
          imageBuf.writeUInt32LE(outputArray[ai], bi);
        }
      }
    }
    function _readBinary(path) {
      return new Promise((resolve, reject) => {
        fs.readFile(path, (err, buffer) => {
          if (err) {
            return reject(err);
          }
          return resolve(buffer);
        });
      });
    }
    function _writeBinary(path, buffer) {
      return new Promise((resolve, reject) => {
        fs.writeFile(path, buffer, (err) => {
          if (err) {
            return reject(err);
          }
          return resolve();
        });
      });
    }
  }
});

// node_modules/gifwrap/src/gifcodec.js
var require_gifcodec = __commonJS({
  "node_modules/gifwrap/src/gifcodec.js"(exports) {
    "use strict";
    var Omggif = require_omggif();
    var { Gif, GifError: GifError2 } = require_gif();
    var GifUtil;
    process.nextTick(() => {
      GifUtil = require_gifutil();
    });
    var { GifFrame } = require_gifframe();
    var PER_GIF_OVERHEAD = 200;
    var PER_FRAME_OVERHEAD = 100;
    var GifCodec = class {
      constructor(options = {}) {
        this._transparentRGB = null;
        if (typeof options.transparentRGB === "number" && options.transparentRGB !== 0) {
          this._transparentRGBA = options.transparentRGB * 256;
        }
        this._testInitialBufferSize = 0;
      }
      decodeGif(buffer) {
        try {
          let reader;
          try {
            reader = new Omggif.GifReader(buffer);
          } catch (err) {
            throw new GifError2(err);
          }
          const frameCount = reader.numFrames();
          const frames = [];
          const spec = {
            width: reader.width,
            height: reader.height,
            loops: reader.loopCount()
          };
          spec.usesTransparency = false;
          for (let i = 0; i < frameCount; ++i) {
            const frameInfo = this._decodeFrame(reader, i, spec.usesTransparency);
            frames.push(frameInfo.frame);
            if (frameInfo.usesTransparency) {
              spec.usesTransparency = true;
            }
          }
          return Promise.resolve(new Gif(buffer, frames, spec));
        } catch (err) {
          return Promise.reject(err);
        }
      }
      encodeGif(frames, spec = {}) {
        try {
          if (frames === null || frames.length === 0) {
            throw new GifError2("there are no frames");
          }
          const dims = GifUtil.getMaxDimensions(frames);
          spec = Object.assign({}, spec);
          spec.width = dims.maxWidth;
          spec.height = dims.maxHeight;
          spec.loops = spec.loops || 0;
          spec.colorScope = spec.colorScope || Gif.GlobalColorsPreferred;
          return Promise.resolve(this._encodeGif(frames, spec));
        } catch (err) {
          return Promise.reject(err);
        }
      }
      _decodeFrame(reader, frameIndex, alreadyUsedTransparency) {
        let info, buffer;
        try {
          info = reader.frameInfo(frameIndex);
          buffer = new Buffer(reader.width * reader.height * 4);
          reader.decodeAndBlitFrameRGBA(frameIndex, buffer);
          if (info.width !== reader.width || info.height !== reader.height) {
            if (info.y) {
              buffer = buffer.slice(info.y * reader.width * 4);
            }
            if (reader.width > info.width) {
              for (let ii = 0; ii < info.height; ++ii) {
                buffer.copy(buffer, ii * info.width * 4, (info.x + ii * reader.width) * 4, (info.x + ii * reader.width) * 4 + info.width * 4);
              }
            }
            buffer = buffer.slice(0, info.width * info.height * 4);
          }
        } catch (err) {
          throw new GifError2(err);
        }
        let usesTransparency = false;
        if (this._transparentRGBA === null) {
          if (!alreadyUsedTransparency) {
            for (let i = 3; i < buffer.length; i += 4) {
              if (buffer[i] === 0) {
                usesTransparency = true;
                i = buffer.length;
              }
            }
          }
        } else {
          for (let i = 3; i < buffer.length; i += 4) {
            if (buffer[i] === 0) {
              buffer.writeUInt32BE(this._transparentRGBA, i - 3);
              usesTransparency = true;
            }
          }
        }
        const frame = new GifFrame(info.width, info.height, buffer, {
          xOffset: info.x,
          yOffset: info.y,
          disposalMethod: info.disposal,
          interlaced: info.interlaced,
          delayCentisecs: info.delay
        });
        return { frame, usesTransparency };
      }
      _encodeGif(frames, spec) {
        let colorInfo;
        if (spec.colorScope === Gif.LocalColorsOnly) {
          colorInfo = GifUtil.getColorInfo(frames, 0);
        } else {
          colorInfo = GifUtil.getColorInfo(frames, 256);
          if (!colorInfo.colors) {
            if (spec.colorScope === Gif.GlobalColorsOnly) {
              throw new GifError2("Too many color indexes for global color table");
            }
            spec.colorScope = Gif.LocalColorsOnly;
          }
        }
        spec.usesTransparency = colorInfo.usesTransparency;
        const localPalettes = colorInfo.palettes;
        if (spec.colorScope === Gif.LocalColorsOnly) {
          const localSizeEst = 2e3;
          return _encodeLocal(frames, spec, localSizeEst, localPalettes);
        }
        const globalSizeEst = 2e3;
        return _encodeGlobal(frames, spec, globalSizeEst, colorInfo);
      }
      _getSizeEstimateGlobal(globalPalette, frames) {
        if (this._testInitialBufferSize > 0) {
          return this._testInitialBufferSize;
        }
        let sizeEst = PER_GIF_OVERHEAD + 3 * 256;
        const pixelBitWidth = _getPixelBitWidth(globalPalette);
        frames.forEach((frame) => {
          sizeEst += _getFrameSizeEst(frame, pixelBitWidth);
        });
        return sizeEst;
      }
      _getSizeEstimateLocal(palettes, frames) {
        if (this._testInitialBufferSize > 0) {
          return this._testInitialBufferSize;
        }
        let sizeEst = PER_GIF_OVERHEAD;
        for (let i = 0; i < frames.length; ++i) {
          const palette = palettes[i];
          const pixelBitWidth = _getPixelBitWidth(palette);
          sizeEst += _getFrameSizeEst(frames[i], pixelBitWidth);
        }
        return sizeEst;
      }
    };
    exports.GifCodec = GifCodec;
    function _colorLookupLinear(colors, color) {
      const index = colors.indexOf(color);
      return index === -1 ? null : index;
    }
    function _colorLookupBinary(colors, color) {
      var lo = 0, hi = colors.length - 1, mid;
      while (lo <= hi) {
        mid = Math.floor((lo + hi) / 2);
        if (colors[mid] > color)
          hi = mid - 1;
        else if (colors[mid] < color)
          lo = mid + 1;
        else
          return mid;
      }
      return null;
    }
    function _encodeGlobal(frames, spec, bufferSizeEst, globalPalette) {
      const extendedGlobalPalette = {
        colors: globalPalette.colors.slice(),
        usesTransparency: globalPalette.usesTransparency
      };
      _extendPaletteToPowerOf2(extendedGlobalPalette);
      const options = {
        palette: extendedGlobalPalette.colors,
        loop: spec.loops
      };
      let buffer = new Buffer(bufferSizeEst);
      let gifWriter;
      try {
        gifWriter = new Omggif.GifWriter(buffer, spec.width, spec.height, options);
      } catch (err) {
        throw new GifError2(err);
      }
      for (let i = 0; i < frames.length; ++i) {
        buffer = _writeFrame(gifWriter, i, frames[i], globalPalette, false);
      }
      return new Gif(buffer.slice(0, gifWriter.end()), frames, spec);
    }
    function _encodeLocal(frames, spec, bufferSizeEst, localPalettes) {
      const options = {
        loop: spec.loops
      };
      let buffer = new Buffer(bufferSizeEst);
      let gifWriter;
      try {
        gifWriter = new Omggif.GifWriter(buffer, spec.width, spec.height, options);
      } catch (err) {
        throw new GifError2(err);
      }
      for (let i = 0; i < frames.length; ++i) {
        buffer = _writeFrame(gifWriter, i, frames[i], localPalettes[i], true);
      }
      return new Gif(buffer.slice(0, gifWriter.end()), frames, spec);
    }
    function _extendPaletteToPowerOf2(palette) {
      const colors = palette.colors;
      if (palette.usesTransparency) {
        colors.push(0);
      }
      const colorCount = colors.length;
      let powerOf2 = 2;
      while (colorCount > powerOf2) {
        powerOf2 <<= 1;
      }
      colors.length = powerOf2;
      colors.fill(0, colorCount);
    }
    function _getFrameSizeEst(frame, pixelBitWidth) {
      let byteLength = frame.bitmap.width * frame.bitmap.height;
      byteLength = Math.ceil(byteLength * pixelBitWidth / 8);
      byteLength += Math.ceil(byteLength / 255);
      return PER_FRAME_OVERHEAD + byteLength + 3 * 256;
    }
    function _getIndexedImage(frameIndex, frame, palette) {
      const colors = palette.colors;
      const colorToIndexFunc = colors.length <= 8 ? _colorLookupLinear : _colorLookupBinary;
      const colorBuffer = frame.bitmap.data;
      const indexBuffer = new Buffer(colorBuffer.length / 4);
      let transparentIndex = colors.length;
      let i = 0, j = 0;
      while (i < colorBuffer.length) {
        if (colorBuffer[i + 3] !== 0) {
          const color = colorBuffer.readUInt32BE(i, true) >> 8 & 16777215;
          indexBuffer[j] = colorToIndexFunc(colors, color);
        } else {
          indexBuffer[j] = transparentIndex;
        }
        i += 4;
        ++j;
      }
      if (palette.usesTransparency) {
        if (transparentIndex === 256) {
          throw new GifError2(`Frame ${frameIndex} already has 256 colorsand so can't use transparency`);
        }
      } else {
        transparentIndex = null;
      }
      return { buffer: indexBuffer, transparentIndex };
    }
    function _getPixelBitWidth(palette) {
      let indexCount = palette.indexCount;
      let pixelBitWidth = 0;
      --indexCount;
      while (indexCount) {
        ++pixelBitWidth;
        indexCount >>= 1;
      }
      return pixelBitWidth > 0 ? pixelBitWidth : 1;
    }
    function _writeFrame(gifWriter, frameIndex, frame, palette, isLocalPalette) {
      if (frame.interlaced) {
        throw new GifError2("writing interlaced GIFs is not supported");
      }
      const frameInfo = _getIndexedImage(frameIndex, frame, palette);
      const options = {
        delay: frame.delayCentisecs,
        disposal: frame.disposalMethod,
        transparent: frameInfo.transparentIndex
      };
      if (isLocalPalette) {
        _extendPaletteToPowerOf2(palette);
        options.palette = palette.colors;
      }
      try {
        let buffer = gifWriter.getOutputBuffer();
        let startOfFrame = gifWriter.getOutputBufferPosition();
        let endOfFrame;
        let tryAgain = true;
        while (tryAgain) {
          endOfFrame = gifWriter.addFrame(frame.xOffset, frame.yOffset, frame.bitmap.width, frame.bitmap.height, frameInfo.buffer, options);
          tryAgain = false;
          if (endOfFrame >= buffer.length - 1) {
            const biggerBuffer = new Buffer(buffer.length * 1.5);
            buffer.copy(biggerBuffer);
            gifWriter.setOutputBuffer(biggerBuffer);
            gifWriter.setOutputBufferPosition(startOfFrame);
            buffer = biggerBuffer;
            tryAgain = true;
          }
        }
        return buffer;
      } catch (err) {
        throw new GifError2(err);
      }
    }
  }
});

// node_modules/gifwrap/src/index.js
var require_src = __commonJS({
  "node_modules/gifwrap/src/index.js"(exports, module) {
    "use strict";
    var BitmapImage = require_bitmapimage();
    var { Gif, GifError: GifError2 } = require_gif();
    var { GifCodec } = require_gifcodec();
    var { GifFrame } = require_gifframe();
    var GifUtil = require_gifutil();
    module.exports = {
      BitmapImage,
      Gif,
      GifCodec,
      GifFrame,
      GifUtil,
      GifError: GifError2
    };
  }
});

// dep:gifwrap
var gifwrap_default = require_src();
export {
  gifwrap_default as default
};
/**
 * @preserve
 * Copyright 2015-2016 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * cie94.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2016 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * ciede2000.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2016 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * cmetric.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2016 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * constants.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2016 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * euclidean.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2016 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * hueStatistics.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2016 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * iq.ts - Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2016 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * lab2rgb.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2016 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * lab2xyz.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2016 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * manhattanNeuQuant.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2016 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * palette.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2016 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * pngQuant.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2016 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * point.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2016 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * pointContainer.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2016 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * rgb2hsl.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2016 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * rgb2lab.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2016 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * rgb2xyz.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2016 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * wuQuant.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2016 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * xyz2lab.ts - part of Image Quantization Library
 */
/**
 * @preserve
 * Copyright 2015-2016 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * xyz2rgb.ts - part of Image Quantization Library
 */
/**
 * @preserve TypeScript port:
 * Copyright 2015-2016 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * colorHistogram.ts - part of Image Quantization Library
 */
/**
 * @preserve TypeScript port:
 * Copyright 2015-2016 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * neuquant.ts - part of Image Quantization Library
 */
/**
 * @preserve TypeScript port:
 * Copyright 2015-2016 Igor Bezkrovnyi
 * All rights reserved. (MIT Licensed)
 *
 * rgbquant.ts - part of Image Quantization Library
 */
//# sourceMappingURL=gifwrap.js.map
